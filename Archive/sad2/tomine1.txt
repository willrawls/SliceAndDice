Attribute VB_Name = "wzmain_mod"
Option Compare Database
Option Explicit
  Global pg_stObjectName As String
  Global pg_iObjectType As Integer
  Global pg_oWordApp As Object
  Global pg_oWordBasic As Object
Global pvt_fpkd As FPK_DATA
Global PVT_LCID As Long
Global xlh_iObjType As Integer
Global xlh_stAttachmentName As String
Global xlh_stFileName As String
Global xlh_stSheetName As String
Global xlh_stRangeName As String
Type XTQ_BUILDINFO
    dbCode As Database
    rsStrings As Recordset
    iObjType As Integer
    stRecSrc As String
    cRowHdrs As Integer
    rgstRowHdrs() As String
    stColHdr As String
    tColHdr As Integer
    idxDateGrp As Integer
    stDateGrpFxn As String
    stValCol As String
    tValCol As Integer
    stValFxn As String
    fGrandTotals As Boolean
    stXtqName As String
    iOpenMode As Integer
    fShowHelp As Boolean
End Type
Global xtq_binfo As XTQ_BUILDINFO
Global xtq_rgfi() As WLIB_FLDINFO
Global xtq_cFlds As Integer
Global xtq_tqbd As FPK_TQBDATA
Function pm_Entry(stSrcTblQry As String)
On Error GoTo pmEntryErr
    Const FORMCANCELLED = 2501
    If (stSrcTblQry = "") Then
        pg_iObjectType = Application.CurrentObjectType
        pg_stObjectName = Application.CurrentObjectName
    Else
        pg_iObjectType = 999
        pg_stObjectName = stSrcTblQry
    End If
    Set pg_oWordApp = Nothing
    DoCmd.OpenForm "pm_frmMain", , , , , A_DIALOG
    Exit Function
pmEntryErr:
    If (Err <> FORMCANCELLED) Then MsgBox Error$
    Exit Function
End Function
Function pvt_Entry(stDataSrc As String) As Variant
On Error GoTo Pvt_Entry_Err
    PVT_LCID = wlib_GetLCID()
    DoCmd.OpenForm "pvt_FrmMain", , , , , acDialog, stDataSrc
Pvt_Entry_Exit:
    Exit Function
Pvt_Entry_Err:
    If (Err <> 2501) Then
        wlib_HandleError Err, Error$
    End If
    Resume Pvt_Entry_Exit
End Function
Function xlh_FStartWizard(iObjType As Integer, stTableName As String, stFilename As String, fHasFieldNames As Integer, stRangeName As String) As Integer
On Error GoTo xlh_FStartWizard_Err
    Dim db As Database
    Dim td As TableDef
    Dim fMatch As Boolean
    Set db = CurrentDb()
    For Each td In db.TableDefs
        If Len(td.Connect) Then
            fMatch = (InStr(td.Connect, "DATABASE=" & stFilename) > 0) And _
                     (td.SourceTableName = stRangeName) And _
                     (InStr(td.Connect, "HDR=" & IIf(fHasFieldNames, "YES", "NO")) > 0)
        End If
        If fMatch Then Exit For
    Next td
    If Not fMatch Then
        DoCmd.TransferSpreadsheet acLink, 5, stTableName, stFilename, fHasFieldNames, stRangeName
    End If
    xlh_stAttachmentName = stTableName
    xlh_iObjType = iObjType
    xlh_stFileName = stFilename
    xlh_stRangeName = stRangeName
    xlh_stSheetName = ""
    DoCmd.OpenForm "xlh_frm", acNormal, , , , acHidden
    xlh_FStartWizard = True
xlh_FStartWizard_Exit:
On Error Resume Next
    db.close
    Exit Function
xlh_FStartWizard_Err:
    xlh_FStartWizard = False
    Resume xlh_FStartWizard_Exit
End Function
Function xlh_FStartConvert(stFilename As String, stSheetName As String, stRangeName As String) As Integer
On Error GoTo xlh_FStartConvert_Err
    If DBEngine(0)(0).Updatable = False Then GoTo xlh_FStartConvert_Exit
    xlh_stFileName = stFilename
    xlh_stSheetName = stSheetName
    xlh_stRangeName = stRangeName
    xlh_iObjType = acTable
    xlh_stAttachmentName = ""
    DoCmd.OpenForm "xlh_frm", acNormal, , , , acHidden
    xlh_FStartConvert = True
xlh_FStartConvert_Exit:
    Exit Function
xlh_FStartConvert_Err:
    xlh_FStartConvert = False
    Resume xlh_FStartConvert_Exit
End Function
Public Function xtq_Entry() As Variant
On Error GoTo xtq_Entry_Err
    wlib_OpenCurrentDB
    Set xtq_binfo.dbCode = CodeDb()
    Set xtq_binfo.rsStrings = xtq_binfo.dbCode.OpenRecordset("xtq_TblStrings", DB_OPEN_TABLE)
    xtq_binfo.rsStrings.Index = "PrimaryKey"
    wlib_StartAddIn 119, xtq_binfo.rsStrings, "String"
    DoCmd.OpenForm "xtq_FrmMain", A_NORMAL, , , , A_DIALOG
xtq_Entry_Exit:
    On Error Resume Next
    wlib_EndAddIn
    xtq_binfo.rsStrings.close
    xtq_binfo.dbCode.close
    wlib_CloseCurrentDB
    Erase xtq_rgfi
    Erase xtq_binfo.rgstRowHdrs
    Exit Function
xtq_Entry_Err:
    If Err <> 2501 Then
        wlib_HandleError Err, Error$
    End If
    Resume xtq_Entry_Exit
End Function

'---
Attribute VB_Name = "wzlib_mod"
Option Compare Database
Option Explicit
Global wlib_cDbCurRefs As Integer
Global wlib_rgaii() As WLIB_ADDININFO
Global wlib_caii As Integer
Global wlib_dbCur As Database
Global wlib_stRecordSource As String
Global wlib_stBackendList As String
Global wlib_hMsain As Long
Type WLIB_FLDINFO
    stName As String
    iType As Integer
    lSize As Long
    stBaseTbl As String
    stBaseFld As String
    lAttributes As Long
End Type
Type WLIB_ADDININFO
    stName As String
    rsStrings As Recordset
    stStringsField As String
End Type
Declare Function wlib_ErrGetObjNames Lib "msaccess.exe" Alias "#79" (ByVal vWks As Variant, ByVal vDB As Variant, ByVal iObjType As Integer, ByVal lFlags As Long, rgstObj() As String, ByVal iStart As Integer, cObj As Integer) As Long
Declare Function wlib_ErrSortStringArray Lib "msaccess.exe" Alias "#81" (rgst() As String) As Long
Declare Function wlib_ErrWpListSites Lib "msaccess.exe" Alias "#69" (ByRef cSites As Long, rgstSites() As String) As Long
Declare Function wlib_ErrWriteRegVal Lib "msaccess.exe" Alias "#71" (ByVal hkeyRoot As Long, ByVal lpszSubKey As String, ByVal lpszValName As String, lpData As Any, ByVal dwType As Long) As Long
Declare Function wlib_FileExists Lib "msaccess.exe" Alias "#57" (ByVal lpszSrc As String) As Integer
Declare Function wlib_FIsValidIdent Lib "msaccess.exe" Alias "#84" (ByVal lpszIdentCand As String) As Boolean
Declare Function wlib_ObjTypOfSzRS Lib "msaccess.exe" Alias "#83" (ByVal lpszRS As String) As Integer
Declare Sub wlib_SplitPath Lib "msaccess.exe" Alias "#59" (ByVal lpszPath As String, ByVal lpszDrive As String, ByVal lpszDir As String, ByVal lpszFname As String, ByVal lpszExt As String)
Declare Function wlib_GetLCID Lib "msaccess.exe" Alias "#51" () As Long
Declare Function wlib_WizHelp Lib "msaccess.exe" Alias "#44" (ByVal lpszHelpFile As String, ByVal wCmd As Integer, ByVal lContextID As Long) As Integer
Declare Function wlib_GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" (ByVal LCID As Long, ByVal LCTYPE As Long, lpData As Any, ByVal cchData As Integer) As Integer
Declare Function wlib_GetUserDefLCID Lib "kernel32" Alias "GetUserDefaultLCID" () As Long
Declare Function wlib_GetWindowWord Lib "USER32" (ByVal Hwnd As Long, ByVal nIndex As Long) As Long
Declare Function wlib_IsCharAlphaNumeric Lib "USER32" Alias "IsCharAlphaNumericA" (ByVal cLong As Long) As Long
Declare Function wlib_LoadLibrary Lib "kernel32" Alias "LoadLibraryA" (ByVal lpLibFileName As String) As Long
Declare Function wlib_LoadString Lib "USER32" Alias "LoadStringA" (ByVal hInstance As Long, ByVal wID As Long, ByVal lpBuffer As Any, ByVal nBufferMax As Long) As Long
Declare Function wlib_OemToChar Lib "USER32" Alias "OemToCharA" (ByVal szSrc As String, ByVal szDst As String) As Long
Declare Function wlib_SetActiveWindow Lib "USER32" Alias "SetActiveWindow" (ByVal Hwnd As Long) As Long
Declare Function wlib_ShowWindow Lib "USER32" (ByVal Hwnd As Long, ByVal nCmdShow As Long) As Long
Declare Sub wlib_OutputDebugString Lib "kernel32" (ByVal lpOutputString As String)
Type WLIB_RECT
    Left As Long
    top As Long
    Right As Long
    bottom As Long
End Type
Type WLIB_POINT
    x As Long
    y As Long
End Type
Type WLIB_SIZE
    cx As Long
    cy As Long
End Type
Type WLIB_OFFICEGETFILENAMEINFO
    hwndOwner As Long
    szAppName As String * 255
    szDlgTitle As String * 255
    szOpenTitle As String * 255
    szFile As String * 4096
    szInitialDir As String * 255
    szFilter As String * 255
    nFilterIndex As Long
    lView As Long
    flags As Long
End Type
Type WLIB_LOGFONT
    lfHeight As Long
    lfWidth As Long
    lfEscapement As Long
    lfOrientation As Long
    lfWeight As Long
    lfItalic As Integer
    lfUnderline As Integer
    lfStrikeOut As Integer
    lfCharSet As Integer
    lfOutPrecision As Integer
    lfClipPrecision As Integer
    lfQuality As Integer
    lfPitchAndFamily As Integer
    lfFaceName As String * 32
End Type
Type WLIB_DBOBJ
    iObjType As Integer
    stName As String
    lFlags As Long
End Type
Type WLIB_ST_PRTDEVMODE
    rgb As String * 1024
End Type
Type WLIB_PRTDEVMODE
    stDeviceName As String * 16
    iSpecVersion As Integer
    iDriverVersion As Integer
    iSize As Integer
    iDriverExtra As Integer
    lFields As Long
    iOrientation As Integer
    iPaperSize As Integer
    iPaperLength As Integer
    iPaperWidth As Integer
    iScale As Integer
    iCopies As Integer
    iDefaultSource As Integer
    iPrintQuality As Integer
    iColor As Integer
    iDuplex As Integer
    iResolution As Integer
    iTTOption As Integer
    iCollate As Integer
    stFormName As String * 16
    iLogPixels As Integer
    lBitsPerPel As Long
    lPelsWidth As Long
    lPelsHeight As Long
    lDisplayFlags As Long
    lDisplayFrequency As Long
End Type
Type WLIB_ST_PRTMIP
    rgb As String * 28
End Type
Type WLIB_PRTMIP
    dxLeftMargin As Long
    dyTopMargin As Long
    dxRightMargin As Long
    dyBottomMargin As Long
    fDataOnly As Long
    dxFormSize As Long
    dyFormSize As Long
    fDefaultSize As Long
    cxColumns As Long
    xFormSpacing As Long
    yFormSpacing As Long
    radItemOrder As Long
    fFastPrint As Long
    fDatasheet As Long
End Type
Type wlib_FONTINFO
    fRasterFont As Long
    rgstName As String * 32
End Type
Declare Function wlib_CreateFontIndirect Lib "gdi32" Alias "CreateFontIndirectA" (lpLogFont As WLIB_LOGFONT) As Long
Declare Function wlib_DeleteObject Lib "gdi32" Alias "DeleteObject" (ByVal hObject As Long) As Long
Declare Function wlib_DestroyMenu Lib "USER32" Alias "DestroyMenu" (ByVal hmenu As Long) As Long
Declare Function wlib_GetActiveWindow Lib "USER32" Alias "GetActiveWindow" () As Long
Declare Function wlib_GetDC Lib "USER32" Alias "GetDC" (ByVal Hwnd As Long) As Long
Declare Function wlib_GetDeviceCaps Lib "gdi32" Alias "GetDeviceCaps" (ByVal hDC As Long, ByVal nIndex As Long) As Long
Declare Function wlib_GetFocus Lib "USER32" Alias "GetFocus" () As Long
Declare Function wlib_GetParent Lib "USER32" Alias "GetParent" (ByVal Hwnd As Long) As Long
Declare Function wlib_GetPrivateProfileSection Lib "kernel32" Alias "GetPrivateProfileSectionA" (ByVal lpAppName As String, ByVal lpReturnedString As String, ByVal nSize As Long, lpFileName As String) As Long
Declare Function wlib_GetPrivateProfileString Lib "kernel32" Alias "GetPrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
Declare Function wlib_GetSystemMetrics Lib "USER32" Alias "GetSystemMetrics" (ByVal nIndex As Long) As Long
Declare Function wlib_GetTempFileName Lib "kernel32" Alias "GetTempFileNameA" (ByVal lpszTempDir As String, ByVal lpszPrefix As String, ByVal uUnique As Long, ByVal lpszTempBuf As String) As Long
Declare Function wlib_GetTempPath Lib "kernel32" Alias "GetTempPathA" (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long
Declare Function wlib_GetTextExtentPoint Lib "gdi32" Alias "GetTextExtentPointA" (ByVal hDC As Long, ByVal lpszString As String, ByVal cbString As Long, lpSize As WLIB_SIZE) As Long
Declare Function wlib_ReleaseDC Lib "USER32" Alias "ReleaseDC" (ByVal Hwnd As Long, ByVal hDC As Long) As Long
Declare Function wlib_SelectObject Lib "gdi32" Alias "SelectObject" (ByVal hDC As Long, ByVal hObject As Long) As Long
Declare Function wlib_SendMessage Lib "USER32" Alias "SendMessageA" (ByVal Hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long
Declare Function wlib_SetForegroundWindow Lib "USER32" Alias "SetForegroundWindow" (ByVal Hwnd As Long) As Long
Declare Function wlib_WritePrivateProfileString Lib "kernel32" Alias "WritePrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As Any, lpString As Any, ByVal lplFileName As String) As Long
Declare Function wlib_GetProfileInt Lib "kernel32" Alias "GetProfileIntA" (ByVal lpApplicationName As String, ByVal lpKeyName As String, ByVal lDefault As Long) As Long
Declare Function wlib_WinHelp Lib "USER32" Alias "WinHelpA" (ByVal Hwnd As Long, ByVal lpHelpFile As String, ByVal wCommand As Long, ByVal dwData As Any) As Long
Declare Sub wlib_GetWindowRect Lib "USER32" Alias "GetWindowRect" (ByVal Hwnd As Long, lpRect As WLIB_RECT)
Declare Sub wlib_MoveWindow Lib "USER32" Alias "MoveWindow" (ByVal Hwnd As Long, ByVal x As Long, ByVal y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal bRepaint As Long)
Declare Function MSAU_OfficeGetFileName Lib "msaccess.exe" Alias "#56" (gfni As WLIB_OFFICEGETFILENAMEINFO, ByVal fOpen As Integer) As Long
Declare Function wlib_FullPath Lib "msaccess.exe" Alias "#58" (ByVal lpszAbsPath As String, ByVal lpszFullPath As String, ByVal cchFullPathMax As Integer) As Integer
Declare Function wlib_FTwipsFromFont Lib "msaccess.exe" Alias "#67" (ByVal stFontName As String, ByVal iSize As Long, ByVal iWeight As Long, ByVal fItalic As Long, ByVal fUnderline As Long, ByVal cch As Long, ByVal stCaption As String, ByVal cchUseMaxWidth As Long, dx As Long, dy As Long) As Integer
Declare Function wlib_MSAUAnalyzeTable Lib "msaccess.exe" Alias "#77" (wrk As Object, db As Object, ByVal stQueryName As String, ByVal fDebug As Long, ByVal stStatus As String) As Long
Declare Function wlib_MSAUAnalyzeQuery Lib "msaccess.exe" Alias "#76" (wrk As Object, db As Object, ByVal stQueryName As String, ByVal stSuggestions As String) As Long
Declare Function wlib_MSAUFillInHashValues Lib "msaccess.exe" Alias "#78" (wrk As Object, db As Object, ByVal stTypoTableName As String, ByVal stDataFields As String, ByVal lGranularity As Long) As Long
Declare Function wlib_GetFontCount Lib "msaccess.exe" Alias "#61" (ByVal hDC As Long) As Long
Declare Function wlib_GetFontList Lib "msaccess.exe" Alias "#62" (ByVal hDC As Long, fiFonts() As wlib_FONTINFO) As Long
Declare Function wlib_GetSizeCount Lib "msaccess.exe" Alias "#63" (ByVal hDC As Long, ByVal szFont As String) As Long
Declare Function wlib_GetSizeList Lib "msaccess.exe" Alias "#64" (ByVal hDC As Long, ByVal szFont As String, lSizeList() As Long) As Long
Declare Function wlib_ErrGetRegKeyInfo Lib "msaccess.exe" Alias "#72" (ByVal hkeyRoot As Long, ByVal lpszSubKey As String, lpcSubKeys As Long, lpcValues As Long) As Long
Declare Function wlib_ErrGetRegVal Lib "msaccess.exe" Alias "#70" (ByVal hkeyRoot As Long, ByVal lpszSubKey As String, ByVal lpszValName As String, lpData As Any, ByVal cbMax As Long) As Long
Declare Function wlib_ErrGetRegValName Lib "msaccess.exe" Alias "#73" (ByVal hkeyRoot As Long, ByVal lpszSubKey As String, ByVal iValue As Long, ByVal lpszValName As String, ByVal cbMax As Long, lpdwType As Long) As Long
Declare Function wlib_ErrWriteRegKey Lib "msaccess.exe" Alias "#74" (ByVal hkeyRoot As Long, ByVal lpszSubKey As String, ByVal lpszClass As String) As Long
Declare Function wlib_ErrGetRegKey Lib "msaccess.exe" Alias "#75" (ByVal hkeyRoot As Long, ByVal lpszSubKey As String, ByVal iSubKey As Long, ByVal lpszName As String, ByVal cbMax As Long) As Long
Declare Function wlib_RegOpenKeyEx Lib "advapi32" Alias "RegOpenKeyExA" (ByVal hkeyRoot As Long, ByVal lpszSubKey As String, ByVal ulOptions As Long, ByVal samDesired As Long, phkeyResult As Long) As Long
Declare Function wlib_RegCloseKey Lib "advapi32" Alias "RegCloseKey" (ByVal hkey As Long) As Long
Declare Function wlib_RegDeleteKey Lib "advapi32" Alias "RegDeleteKeyA" (ByVal hkey As Long, ByVal lpszSubKey As String) As Long
Declare Function wlib_RegDeleteValue Lib "advapi32" Alias "RegDeleteValueA" (ByVal hkey As Long, ByVal lpszValue As String) As Long
Declare Function wlib_ErrGetDbobjList Lib "msaccess.exe" Alias "#80" (ByVal vWks As Variant, ByVal vDB As Variant, ByVal iObjType As Integer, ByVal lFlags As Long, rgdbobj() As WLIB_DBOBJ, ByVal iStart As Integer, cObj As Integer) As Long
Declare Function wlib_ErrSortDbobjArray Lib "msaccess.exe" Alias "#82" (rgst() As WLIB_DBOBJ, ByVal fNamesOnly As Long) As Long
Declare Function wlib_FBracketLpsz Lib "msaccess.exe" Alias "#43" (ByVal lpsz As String, ByVal cchLpsz As Long, ByVal flags As Long) As Long
Declare Function wlib_FUniqueIndexTableFieldEx Lib "msaccess.exe" Alias "#40" (ByVal lpszTblName As String, ByVal lpszColNames As String) As Long
Declare Function wlib_FEnglishPictToLocal Lib "msaccess.exe" Alias "#47" (ByVal lpszSrc As String, ByVal lpszDest As String, ByVal cchMax As Long) As Long
Declare Sub wlib_AccChooseColor Lib "msaccess.exe" Alias "#53" (ByVal Hwnd As Long, rgb As Long)
Dim cHourglassRefs As Integer
Function wlib_GetByteOfString(st As String) As Long
On Error GoTo wlib_GetByteOfString_Err
    Dim ich As Integer
    Dim ch As String
    Dim stBuf As String
    Dim cch As Long
    cch = 0
    stBuf = st
    For ich = 1 To Len(stBuf)
        ch = Mid$(stBuf, ich, 1)
        If Asc(ch) < 0 Then
            cch = cch + 2
        Else
            cch = cch + 1
        End If
    Next ich
    wlib_GetByteOfString = cch
wlib_GetByteOfString_Exit:
    Exit Function
wlib_GetByteOfString_Err:
    Resume wlib_GetByteOfString_Exit
End Function
Function wlib_GetNumOfChar(st As String, iNum As Long) As Long
On Error GoTo wlib_GetNumOfChar_Err
    Dim ich As Integer
    Dim ipch As Integer
    Dim ch As String
    Dim crch As Long
    Dim stBuf As String
    Dim cch As Long
    cch = iNum
    stBuf = st
    ipch = 1
    crch = 0
    Do Until (crch >= cch) Or (crch >= Len(st))
        ch = Mid$(stBuf, ipch, 1)
        If Asc(ch) < 0 Then
            cch = cch - 1
        End If
        If Not (Asc(ch) = 0) Then
            crch = crch + 1
        End If
        ipch = ipch + 1
    Loop
wlib_GetNumOfChar_Exit:
    wlib_GetNumOfChar = wlib_Min(crch, cch)
    Exit Function
wlib_GetNumOfChar_Err:
    Resume wlib_GetNumOfChar_Exit
End Function
Function wlib_GetObjList(db As Database, iObjType As Integer, rgstObj() As String, lFlags As Long) As Integer
    Dim cObj As Integer
    Dim lErr As Long
    If (GetOption("Show System Objects")) Then lFlags = lFlags Or &H10000000
    If (GetOption("Show Hidden Objects")) Then lFlags = lFlags Or &H20000000
    Select Case iObjType
        Case acTable:
            cObj = db.TableDefs.Count
        Case acQuery
            cObj = db.QueryDefs.Count
        Case acForm:
            cObj = db.Containers!Forms.Documents.Count
        Case acReport:
            cObj = db.Containers!Reports.Documents.Count
        Case acMacro:
            cObj = db.Containers!Scripts.Documents.Count
        Case acModule:
            cObj = db.Containers!Modules.Documents.Count
    End Select
    If (cObj > 0) Then
        ReDim rgstObj(1 To cObj)
        lErr = wlib_ErrGetObjNames(Workspaces(0), db, iObjType, lFlags, rgstObj, 0, cObj)
        If (lErr <> 0) Then Error lErr
    End If
    If (cObj > 0) Then
        ReDim Preserve rgstObj(1 To cObj)
        lErr = wlib_ErrSortStringArray(rgstObj)
        If (lErr <> 0) Then Error lErr
    Else
        Erase rgstObj
    End If
    wlib_GetObjList = cObj
End Function
Sub wlib_CloseCurrentDB()
    If (wlib_cDbCurRefs = 1) Then
       wlib_dbCur.close
       Set wlib_dbCur = Nothing
    End If
    wlib_cDbCurRefs = wlib_cDbCurRefs - 1
End Sub
Sub wlib_EndAddIn()
On Error GoTo wlib_EndAddIn_Err
    wlib_caii = wlib_caii - 1
    If wlib_caii > 0 Then
        ReDim Preserve wlib_rgaii(wlib_caii - 1)
    Else
        Erase wlib_rgaii
    End If
    If wlib_caii > 0 Then
        If Len(wlib_rgaii(wlib_caii - 1).stName) Then
            SysCmd acSysCmdSetStatus, wlib_rgaii(wlib_caii - 1).stName
        End If
    Else
        SysCmd acSysCmdClearStatus
    End If
wlib_EndAddIn_Exit:
    Exit Sub
wlib_EndAddIn_Err:
    MsgBox Error$
    Resume wlib_EndAddIn_Exit
End Sub
Function wlib_ErrNameOK(dbDoc As Database, iDocType As Integer, stName As String) As Integer
  Dim cont As Container
  Dim iCnt As Integer
    If (Not wlib_FValidObjectName(stName)) Then
       wlib_ErrNameOK = 0
       Exit Function
    End If
    If (SysCmd(acSysCmdGetObjectState, iDocType, stName) And OBJSTATE_OPEN) Then
       wlib_ErrNameOK = 1
       Exit Function
    End If
    If iDocType = acTable Or iDocType = acQuery Then
        dbDoc.Relations.Refresh
        For iCnt = 0 To dbDoc.Relations.Count - 1
            If dbDoc.Relations(iCnt).Table = stName Or dbDoc.Relations(iCnt).ForeignTable = stName Then
               wlib_ErrNameOK = 3
               Exit Function
            End If
        Next iCnt
    End If
    Select Case iDocType
      Case acTable, acQuery
        Set cont = dbDoc.Containers("Tables")
      Case acForm
        Set cont = dbDoc.Containers("Forms")
      Case acReport
        Set cont = dbDoc.Containers("Reports")
      Case acMacro
        Set cont = dbDoc.Containers("Scripts")
      Case acModule
        Set cont = dbDoc.Containers("Modules")
    End Select
    cont.Documents.Refresh
    For iCnt = 0 To cont.Documents.Count - 1
        If cont.Documents(iCnt).Name = stName Then
            wlib_ErrNameOK = 2
            Exit Function
        End If
    Next iCnt
    wlib_ErrNameOK = -1
End Function
Sub wlib_HandleError(lErr As Long, stErr As String)
    Dim iPointer As Integer
    iPointer = Screen.MousePointer
    If (iPointer > 0) Then
        Screen.MousePointer = 0
    End If
    If (lErr = 3008) Or (lErr = 3009) _
                Or (lErr = 3261) Or (lErr = 3262) Then
        MsgBox wlib_StFromWlibIds(6), vbOKOnly Or vbExclamation
    ElseIf (wlib_caii > 0) Then
        If (lErr >= 31000 And lErr <= 32000) Then
            MsgBox wlib_StFromIds(lErr), vbOKOnly Or vbInformation, wlib_rgaii(wlib_caii - 1).stName
        Else
            If (lErr >= 2000 And lErr <= 2999) And (stErr = Error$(2000)) Then
                MsgBox wlib_StFromAccessIds(lErr), vbOKOnly Or vbInformation, wlib_rgaii(wlib_caii - 1).stName
            Else
                MsgBox stErr, vbOKOnly Or vbInformation, wlib_rgaii(wlib_caii - 1).stName
            End If
        End If
    Else
        MsgBox stErr, vbOKOnly Or vbInformation
    End If
    If (iPointer > 0) Then
        Screen.MousePointer = iPointer
    End If
End Sub
Function wlib_IMsgBox(id As Long, stInsert As String, iType As Integer, Optional HelpFile, Optional Context) As Integer
    Dim st As String
    Dim iPointer As Integer
    iPointer = Screen.MousePointer
    If (iPointer > 0) Then
        Screen.MousePointer = 0
    End If
    st = wlib_StFromIdsWithInsert(id, stInsert)
    If wlib_caii = 0 Then
        wlib_IMsgBox = MsgBox(st, iType, , HelpFile, Context)
    Else
        wlib_IMsgBox = MsgBox(st, iType, wlib_rgaii(wlib_caii - 1).stName, HelpFile, Context)
    End If
    If (iPointer > 0) Then
        Screen.MousePointer = iPointer
    End If
End Function
Function wlib_Min(ByVal c1 As Integer, ByVal c2 As Integer) As Integer
    If (c1 < c2) Then
        wlib_Min = c1
    Else
        wlib_Min = c2
    End If
End Function
Sub wlib_OpenCurrentDB()
    If (wlib_cDbCurRefs = 0) Then
        Set wlib_dbCur = CurrentDb()
    End If
    wlib_cDbCurRefs = wlib_cDbCurRefs + 1
End Sub
Sub wlib_SmartCtlPropSet(ByRef Ctl As Control, stProp As String, vVal As Variant)
    If (Ctl.Properties(stProp) <> vVal) Then Ctl.Properties(stProp) = vVal
End Sub
Sub wlib_StartAddIn(vAddInName As Variant, rsStrings As Recordset, stField As String)
On Error GoTo wlib_StartAddin_Err
    ReDim Preserve wlib_rgaii(wlib_caii)
    wlib_caii = wlib_caii + 1
    If Not (rsStrings Is Nothing) Then
        Set wlib_rgaii(wlib_caii - 1).rsStrings = rsStrings
        wlib_rgaii(wlib_caii - 1).stStringsField = stField
    End If
    If IsNumeric(vAddInName) Then
        wlib_rgaii(wlib_caii - 1).stName = wlib_StFromIds((vAddInName))
    Else
        wlib_rgaii(wlib_caii - 1).stName = vAddInName
    End If
    SysCmd acSysCmdSetStatus, wlib_rgaii(wlib_caii - 1).stName
wlib_StartAddin_Exit:
    Exit Sub
wlib_StartAddin_Err:
    MsgBox Error$
    Resume wlib_StartAddin_Exit
End Sub
Function wlib_StFromAccessIds(id As Long) As String
On Error GoTo wlib_StFromAccessIds_Err
    wlib_StFromAccessIds = Application.AppLoadString(id)
wlib_StFromAccessIds_Exit:
    Exit Function
wlib_StFromAccessIds_Err:
    wlib_StFromAccessIds = ""
    Resume wlib_StFromAccessIds_Exit
End Function
Function wlib_StFromIds(id As Long) As String
On Error GoTo wlib_StFromIds_Err
    If id < 0 Then
        wlib_StFromIds = wlib_StFromAccessIds(Abs(id))
    Else
        With wlib_rgaii(wlib_caii - 1)
            wlib_StFromIds = wlib_StFromRsIds(id, .rsStrings, .stStringsField)
        End With
    End If
wlib_StFromIds_Exit:
    Exit Function
wlib_StFromIds_Err:
    MsgBox Error$
    wlib_StFromIds = ""
    Resume wlib_StFromIds_Exit
End Function
Function wlib_StFromIdsWithInsert(id As Long, ByVal stInsert As String) As String
On Error GoTo wlib_StFromIdsWithInsert_Err
    If id < 0 Then
        wlib_StFromIdsWithInsert = wlib_StFromRsIdsWithInsert(id, Nothing, "", stInsert)
    Else
        With wlib_rgaii(wlib_caii - 1)
            wlib_StFromIdsWithInsert = wlib_StFromRsIdsWithInsert(id, .rsStrings, .stStringsField, stInsert)
        End With
    End If
wlib_StFromIdsWithInsert_Exit:
    Exit Function
wlib_StFromIdsWithInsert_Err:
    MsgBox Error$
    Resume wlib_StFromIdsWithInsert_Exit
End Function
Function wlib_StFromIdsWithShrinkableInsert(id As Long, ByVal stInsert As String, cbResult As Long) As String
On Error GoTo wlib_StFromIdsWithShrinkableInsert_Err
    Dim cbToken As Long
    cbToken = wlib_GetByteOfString(wlib_StFromIds(id)) - 1
    stInsert = Left$(stInsert, wlib_GetNumOfChar(stInsert, cbResult - cbToken))
    With wlib_rgaii(wlib_caii - 1)
        wlib_StFromIdsWithShrinkableInsert = wlib_StFromRsIdsWithInsert(id, .rsStrings, .stStringsField, stInsert)
    End With
wlib_StFromIdsWithShrinkableInsert_Exit:
    Exit Function
wlib_StFromIdsWithShrinkableInsert_Err:
    MsgBox Error$
    Resume wlib_StFromIdsWithShrinkableInsert_Exit
End Function
Function wlib_StGetToken(stLn As String, stDelim As String, Optional chQuote As Variant) As String
    Dim iOpenQuote As Integer
    Dim iDelim As Integer
    Dim iCloseQuote As Integer
    Dim stToken As String
    If IsMissing(chQuote) Then chQuote = """"
    If Len(chQuote) Then iOpenQuote = InStr(1, stLn, chQuote)
    iDelim = InStr(1, stLn, stDelim)
    If (iOpenQuote > 0) And (iOpenQuote < iDelim) Then
      iCloseQuote = InStr(iOpenQuote + 1, stLn, chQuote)
      iDelim = InStr(iCloseQuote + 1, stLn, stDelim)
    End If
    If (iDelim <> 0) Then
      stToken = Mid$(stLn, 1, iDelim - 1)
      stLn = Mid$(stLn, iDelim + Len(stDelim))
    Else
      stToken = Mid$(stLn, 1)
      stLn = ""
    End If
    If (Len(stToken) > 1) Then
        If ((Left$(stToken, 1) = chQuote) And (Right$(stToken, 1) = chQuote)) Then
            stToken = Mid$(stToken, 2, Len(stToken) - 2)
        End If
    End If
    wlib_StGetToken = stToken
End Function
Function wlib_FShowHelpCard(lCard As Long, Optional ByVal iCardType As Variant) As Long
    Const HELP_CONTEXT = 1
    Const HELP_FORCEFILE = 9
    Dim stAccHelpFile As String
    Dim stHelpExt As String
    If IsMissing(iCardType) Then iCardType = 1
    Select Case (iCardType)
        Case 1
            stHelpExt = ">Ref"
        Case 2
            stHelpExt = ">LgCard"
        Case 3
            stHelpExt = ">SerCard"
    End Select
    stAccHelpFile = SysCmd(acSysCmdAccessDir) & "acmain80.hlp" & stHelpExt
    wlib_FShowHelpCard = (wlib_WizHelp(stAccHelpFile, HELP_CONTEXT, lCard) <> 0)
End Function
Function wlib_StGetLocaleInfo(LCTYPE As Long) As String
    Const cbMax = 255
    Dim LCID As Long
    Dim stBuff As String * 255
    LCID = wlib_GetUserDefLCID()
    If (wlib_GetLocaleInfo(LCID, LCTYPE, ByVal stBuff, cbMax) > 0) Then
        wlib_StGetLocaleInfo = wlib_StFromSz(stBuff)
    End If
End Function
Sub wlib_ParseFullPath(stPath As String, stDrive As String, stDir As String, stFName As String, stExt As String)
    Dim stDrive2 As String * 3, stDir2 As String * 256, stFName2 As String * 256, stExt2 As String * 256
    wlib_SplitPath ByVal stPath, stDrive2, stDir2, stFName2, stExt2
    stDrive = wlib_StFromSz(stDrive2)
    stDir = wlib_StFromSz(stDir2)
    stFName = wlib_StFromSz(stFName2)
    stExt = wlib_StFromSz(stExt2)
End Sub
Function wlib_FValidObjectName(stName As String) As Integer
    Dim ich As Integer
    Dim ch As String
    Dim fRet As Integer
    Dim cch As Integer
    Dim iAscCh As Integer
    Const cchOBJECTNAMEMAX = 64
    If Len(stName) = 0 Then
        fRet = False
    ElseIf Len(stName) > cchOBJECTNAMEMAX Then
        fRet = False
    Else
        fRet = True
        For ich = 1 To Len(stName)
            ch = Mid$(stName, ich, 1)
            If ich = 1 Then
                If ch = " " Or ch = "=" Then
                    fRet = False
                End If
            End If
            If (InStr("!.[]`", ch) > 0) Then
                fRet = False
            End If
            iAscCh = Asc(ch)
            If (iAscCh >= 0 And iAscCh < 32) Then fRet = False
            If (iAscCh < 0) Then
                cch = cch + 2
            Else
                cch = cch + 1
            End If
            If (Not fRet) Then Exit For
        Next ich
    End If
    If cch > cchOBJECTNAMEMAX Then
        fRet = False
    End If
    wlib_FValidObjectName = fRet
End Function
Function wlib_CGetFldInfo(db As Database, stSrc As String, iFlags As Integer, rgFldInfo() As WLIB_FLDINFO) As Integer
    Const INFO_STNAME = 1
    Const INFO_ITYPE = 2
    Const INFO_LSIZE = 4
    Const INFO_STBASETBL = 8
    Const INFO_STBASEFLD = 16
    Const TYPE_TBL = 1
    Const TYPE_QRYOBJ = 2
    Const TYPE_QRYSQL = 3
    Dim cFlds As Integer
    Dim iFld As Integer
    Dim qd As QueryDef
    Dim flds As Fields
    Dim iSrcType As Integer
    Dim f As Field
On Error Resume Next
    iSrcType = TYPE_TBL
    Set flds = db.TableDefs(stSrc).Fields
    cFlds = flds.Count
    If cFlds Then GoTo wlib_cGetFldInfo_GetInfo:
    iSrcType = TYPE_QRYOBJ
    Set flds = db.QueryDefs(stSrc).Fields
    cFlds = flds.Count
    If cFlds Then GoTo wlib_cGetFldInfo_GetInfo:
    iSrcType = TYPE_QRYSQL
    Set qd = db.CreateQueryDef("", stSrc)
    Set flds = qd.Fields
    cFlds = flds.Count
    If cFlds Then GoTo wlib_cGetFldInfo_GetInfo:
    wlib_CGetFldInfo = 0
    Exit Function
wlib_cGetFldInfo_GetInfo:
    ReDim rgFldInfo(1 To cFlds)
    For iFld = 1 To cFlds
        Set f = flds(iFld - 1)
        If INFO_STNAME And iFlags Then rgFldInfo(iFld).stName = f.Name
        If INFO_STBASETBL And iFlags Then
            If iSrcType = TYPE_TBL Then
                rgFldInfo(iFld).stBaseTbl = stSrc
            Else
                If Not IsNull(f.SourceTable) Then
                    rgFldInfo(iFld).stBaseTbl = f.SourceTable
                End If
            End If
        End If
        If INFO_STBASEFLD And iFlags Then
            If iSrcType = TYPE_TBL Then
                If Len(rgFldInfo(iFld).stName) Then
                    rgFldInfo(iFld).stBaseFld = rgFldInfo(iFld).stName
                Else
                    rgFldInfo(iFld).stBaseFld = f.Name
                End If
            Else
                If Not IsNull(f.SourceField) Then
                    rgFldInfo(iFld).stBaseFld = f.SourceField
                End If
            End If
        End If
        If INFO_ITYPE And iFlags Then
            rgFldInfo(iFld).iType = f.Type
            rgFldInfo(iFld).lAttributes = f.Attributes
        End If
        If INFO_LSIZE And iFlags Then rgFldInfo(iFld).lSize = f.Size
wlib_cGetFldInfo_SkipFld:
    Next iFld
    wlib_CGetFldInfo = cFlds
End Function
Function wlib_StFromWlibIds(id As Long) As String
On Error Resume Next
    Dim db As Database
    Dim rs As Recordset
    Set db = CodeDb()
    Set rs = db.OpenRecordset("wlib_tblStrings", dbOpenTable)
    rs.Index = "PrimaryKey"
    wlib_StFromWlibIds = wlib_StFromRsIds(id, rs, "Message")
    rs.close
    db.close
End Function
Function wlib_StFromSz(szTmp As String) As String
    Dim ich As Integer
    ich = InStr(1, szTmp, vbNullChar, vbBinaryCompare)
    If ich Then
        wlib_StFromSz = Left$(szTmp, ich - 1)
    Else
        wlib_StFromSz = szTmp
    End If
End Function
Function wlib_StFromRsIds(id As Long, rs As Recordset, stCol As String) As String
On Error GoTo wlib_StFromRsIds_Err
    
    If id < 0 Then
        wlib_StFromRsIds = wlib_StFromAccessIds(Abs(id))
    Else
        rs.Seek "=", id
        wlib_StFromRsIds = Nz(rs(stCol).Value, "")
    End If

wlib_StFromRsIds_Exit:
    Exit Function
wlib_StFromRsIds_Err:
    MsgBox Error$
    Resume wlib_StFromRsIds_Exit
End Function
Function wlib_StFromRsIdsWithInsert(id As Long, rs As Recordset, stCol As String, ByVal stInsert As String) As String
On Error GoTo wlib_StFromRsIdsWithInsert_Err
    Dim st As String
    Dim stToken As String
    Dim cReplaces As Integer
    Dim stReplaceWhat As String
    Dim iLCID As Long
    Dim i As Integer
    Dim iPos As Integer
    If id < 0 Then
        st = wlib_StFromAccessIds(Abs(id))
    Else
        rs.Seek "=", id
        st = Nz(rs(stCol).Value, "")
    End If
    iLCID = wlib_GetLCID()
    Select Case iLCID
        Case &H411, &H404, &H412, &H804
            cReplaces = 0
            stReplaceWhat = "|"
            If Len(st) > 0 And InStr(st, stReplaceWhat) > 0 Then
                For i = 1 To Len(st)
                    iPos = InStr(i, st, stReplaceWhat)
                    If Not IsNumeric(Mid(st, iPos + 1, 1)) Then
                        stToken = wlib_StGetToken(stInsert, "|")
                        st = Left$(st, iPos - 1) & stToken & Right$(st, Len(st) - iPos)
                        Exit For
                    End If
                    i = iPos
                Next i
                cReplaces = cReplaces + 1
                stReplaceWhat = "|" & cReplaces
                While InStr(st, stReplaceWhat)
                    stToken = wlib_StGetToken(stInsert, "|")
                    wlib_ReplaceStr st, stReplaceWhat, stToken
                    cReplaces = cReplaces + 1
                    stReplaceWhat = "|" & cReplaces
                Wend
            End If
        Case Else
            If Len(st) > 0 Then
            stReplaceWhat = "|"
                 While InStr(st, stReplaceWhat)
                    If stInsert <> "|" Then
                        stToken = wlib_StGetToken(stInsert, "|")
                    Else
                        stToken = stInsert
                    End If
                    wlib_ReplaceStr st, stReplaceWhat, stToken
                    cReplaces = cReplaces + 1
                    stReplaceWhat = "|" & cReplaces
                Wend
            End If
    End Select
    wlib_StFromRsIdsWithInsert = st
wlib_StFromRsIdsWithInsert_Exit:
    Exit Function
wlib_StFromRsIdsWithInsert_Err:
    MsgBox Error$
    Resume wlib_StFromRsIdsWithInsert_Exit
End Function
Sub wlib_ReplaceStr(stSource As String, stWhat As String, stWith As String)
    Dim i As Integer
    i = InStr(stSource, stWhat)
    If i > 0 Then
        stSource = Left$(stSource, i - 1) & stWith & Right$(stSource, Len(stSource) - Len(stWhat) - i + 1)
    End If
End Sub
Public Function wlib_FTblIsQry(stTblName As String) As Boolean
    wlib_FTblIsQry = (wlib_ObjTypOfSzRS(stTblName) = 2)
End Function
Sub wlib_CalcUniquenessOfRel(rel As Relation, fFromUnique As Integer, fToUnique As Integer)
    Dim stFromFldList As String
    Dim stToFldList As String
    Dim iFld As Integer
    stFromFldList = ""
    stToFldList = ""
    For iFld = 0 To rel.Fields.Count - 1
        stFromFldList = stFromFldList & rel.Fields(iFld).Name & Chr$(0)
        stToFldList = stToFldList & rel.Fields(iFld).ForeignName & Chr$(0)
    Next iFld
    stFromFldList = stFromFldList & Chr$(0)
    stToFldList = stToFldList & Chr$(0)
    fFromUnique = (wlib_FUniqueIndexTableFieldEx(rel.Table, stFromFldList) <> 0)
    fToUnique = (wlib_FUniqueIndexTableFieldEx(rel.ForeignTable, stToFldList) <> 0)
End Sub
Function wlib_ErrGetMdtPath(fVerifyExists As Integer, stMdtPath As String) As Long
On Error GoTo wlib_ErrGetMdtPath_Err
    Const cchMax = 2048
    Dim stBackend As String
    Dim szBuf As String * cchMax
    Dim szCurBackend As String * 255
    Dim hkeyRoot As Long
    Dim cKeys As Long
    Dim cDBs As Long
    Dim dwType As Long
    Dim iRegEntry As Integer
    Dim errRet As Long
    Dim stDrive As String, stDir As String, stFName As String, stExt As String
    If (0 <> wlib_OpenAccessRegKey("Wizards", hkeyRoot)) Then
        errRet = 31996
        GoTo wlib_ErrGetMdtPath_Exit
    End If
    If (0 <> wlib_ErrGetRegKeyInfo(hkeyRoot, "Data Files", cKeys, cDBs)) Then
        cDBs = 0
    End If
    If (cDBs = 0) Then
        stBackend = wlib_StPromptForMdtPath()
        If (stBackend <> "") Then
            stBackend = Trim$(stBackend) & Chr$(0)
            wlib_ErrWriteRegKey hkeyRoot, "Data Files", ""
            errRet = wlib_ErrWriteRegVal(hkeyRoot, "Data Files", wlib_StFromWlibIds(3), ByVal stBackend, 1&)
            If (errRet <> 0) Then
                GoTo wlib_ErrGetMdtPath_Exit
            End If
        End If
        stBackend = wlib_StFromSz(stBackend)
    Else
        wlib_stBackendList = ""
        For iRegEntry = 0 To cDBs - 1
            If (0 = wlib_ErrGetRegValName(hkeyRoot, "Data Files", iRegEntry, szBuf, Len(szBuf), dwType)) Then
                If (0 = wlib_ErrGetRegVal(hkeyRoot, "Data Files", szBuf, ByVal szCurBackend, Len(szCurBackend))) Then
                    If (cDBs = 1) Then
                        stBackend = wlib_StFromSz(szCurBackend)
                    Else
                        wlib_stBackendList = wlib_stBackendList & ";" & wlib_StFromSz(szCurBackend)
                        wlib_stBackendList = wlib_stBackendList & ";" & wlib_StFromSz(szBuf)
                    End If
                End If
            End If
        Next iRegEntry
        wlib_stBackendList = Mid$(wlib_stBackendList, 2)
        If (cDBs > 1) Then
            If wlib_FHourglass() Then DoCmd.Hourglass False
            DoCmd.OpenForm "wlib_frmSelectBackend", , , , , acDialog
            If wlib_FHourglass() Then DoCmd.Hourglass True
            If wlib_stBackendList = "" Then
                errRet = 31998
                GoTo wlib_ErrGetMdtPath_Exit
            Else
                stBackend = wlib_stBackendList
            End If
        End If
    End If
    wlib_RegCloseKey hkeyRoot
    hkeyRoot = 0
    wlib_ParseFullPath stBackend, stDrive, stDir, stFName, stExt
    If (Len(stDrive) = 0 And Len(stDir) = 0) Then
        stBackend = SysCmd(acSysCmdAccessDir) & stBackend
    End If
    If (fVerifyExists) Then
        FileLen stBackend
    End If
wlib_ErrGetMdtPath_Exit:
On Error Resume Next
    stMdtPath = stBackend
    wlib_ErrGetMdtPath = errRet
    Exit Function
wlib_ErrGetMdtPath_Err:
    If (hkeyRoot <> 0) Then
        wlib_RegCloseKey hkeyRoot
    End If
    errRet = Err
    Resume wlib_ErrGetMdtPath_Exit
End Function
Private Function wlib_StPromptForMdtPath()
    Dim gfni As WLIB_OFFICEGETFILENAMEINFO
    Dim lErr As Long
    Dim stMdtFile As String
    gfni.hwndOwner = Application.hWndAccessApp
    gfni.szAppName = wlib_rgaii(0).stName
    gfni.szDlgTitle = wlib_StFromWlibIds(4)
    gfni.szOpenTitle = ""
    gfni.szFile = ""
    gfni.szInitialDir = ""
    gfni.szFilter = wlib_StFromWlibIds(5)
    gfni.nFilterIndex = 0
    gfni.lView = 0
    gfni.flags = &H2
    lErr = wlib_OfficeGetFileName(gfni, True)
    If (lErr = 0) Then
        stMdtFile = gfni.szFile
    Else
        stMdtFile = ""
    End If
    wlib_StPromptForMdtPath = stMdtFile
End Function
Function wlib_FIsSysObj(objtype As Integer, stName As String, lAttribs As Long) As Integer
    If (Left$(stName, 4) = "USys") Then
        wlib_FIsSysObj = True
    Else
        wlib_FIsSysObj = (((lAttribs And dbSystemObject) <> 0) And (objtype = acTable))
    End If
End Function
Sub wlib_FormError(iDataError As Integer, iResponse As Integer)
    If iDataError = 2169 Then
        iResponse = DATA_ERRCONTINUE
    Else
        iResponse = DATA_ERRDISPLAY
    End If
End Sub
Function wlib_FEnglishMeasurements() As Integer
    wlib_FEnglishMeasurements = (Val(wlib_StGetLocaleInfo(&HD)) = 1)
End Function
Function wlib_FValidControlName(stName As String) As Integer
    Const cchMax = 64
    If Len(stName) = 0 Then
        wlib_FValidControlName = False
    ElseIf Len(stName) > cchMax Then
        wlib_FValidControlName = False
    ElseIf Left$(stName, 1) = " " Or Left$(stName, 1) = "=" Then
        wlib_FValidControlName = False
    ElseIf InStr(stName, "[") Or InStr(stName, "]") Then
        wlib_FValidControlName = False
    Else
        wlib_FValidControlName = True
    End If
End Function
Function wlib_OfficeGetFileName(gfni As WLIB_OFFICEGETFILENAMEINFO, ByVal fOpen As Integer) As Long
    Dim lRet As Long
    If (Len(Trim$(gfni.szAppName)) = 0) Then
        gfni.szAppName = wlib_rgaii(0).stName & Chr$(0)
    Else
        gfni.szAppName = RTrim$(gfni.szAppName) & Chr$(0)
    End If
    gfni.szDlgTitle = RTrim$(gfni.szDlgTitle) & Chr$(0)
    gfni.szOpenTitle = RTrim$(gfni.szOpenTitle) & Chr$(0)
    gfni.szFile = RTrim$(gfni.szFile) & Chr$(0)
    gfni.szInitialDir = RTrim$(gfni.szInitialDir) & Chr$(0)
    gfni.szFilter = RTrim$(gfni.szFilter) & Chr$(0)
    SysCmd acSysCmdClearHelpTopic
    lRet = MSAU_OfficeGetFileName(gfni, fOpen)
    gfni.szAppName = RTrim$(wlib_StFromSz(gfni.szAppName))
    gfni.szDlgTitle = RTrim$(wlib_StFromSz(gfni.szDlgTitle))
    gfni.szOpenTitle = RTrim$(wlib_StFromSz(gfni.szOpenTitle))
    gfni.szFile = RTrim$(wlib_StFromSz(gfni.szFile))
    gfni.szInitialDir = RTrim$(wlib_StFromSz(gfni.szInitialDir))
    gfni.szFilter = RTrim$(wlib_StFromSz(gfni.szFilter))
    wlib_OfficeGetFileName = lRet
End Function
Function wlib_FHourglass() As Integer
    wlib_FHourglass = cHourglassRefs > 0
End Function
Sub wlib_Hourglass(fHourglassOn As Integer)
    If (fHourglassOn) Then
        cHourglassRefs = cHourglassRefs + 1
        If (cHourglassRefs = 1) Then
            DoCmd.Hourglass True
        End If
    Else
        cHourglassRefs = cHourglassRefs - 1
        If (cHourglassRefs = 0) Then
            DoCmd.Hourglass False
        End If
    End If
End Sub
Function wlib_Max(ByVal c1 As Integer, ByVal c2 As Integer) As Integer
    If (c1 > c2) Then
        wlib_Max = c1
    Else
        wlib_Max = c2
    End If
End Function
Function wlib_StUniqueControlName(stDoc As String, iDocType As Integer, stInitName As String) As String
On Error GoTo wlib_StUniqueControlName_Err
    Dim stCtl As String
    Dim i As Integer
    Dim frmrpt As Object
    Dim unused As String
    Select Case iDocType
        Case acForm
            Set frmrpt = Forms(stDoc)
        Case acReport
            Set frmrpt = Reports(stDoc)
    End Select
    stCtl = stInitName
    Do
        unused = (frmrpt(stCtl).Name)
        i = i + 1
        stCtl = stInitName & i
    Loop
wlib_StUniqueControlName_Exit:
    wlib_StUniqueControlName = stCtl
    Exit Function
wlib_StUniqueControlName_Err:
    Resume wlib_StUniqueControlName_Exit
End Function
Function wlib_StUniqueDocName(stInitialName As String, iDocType As Integer) As String
    Dim stDocName As String
    Dim stPrefix As String
    Dim i As Integer
    wlib_OpenCurrentDB
    If wlib_ErrNameOK(wlib_dbCur, iDocType, stInitialName) = 0 Then _
            GoTo wlib_StUniqueDocName_DefaultName
    If IsNumeric(Right$(stInitialName, 1)) Then
        i = CInt(Right$(stInitialName, 1))
        stPrefix = Left$(stInitialName, Len(stInitialName) - 1)
    Else
        i = 0
        stPrefix = stInitialName
    End If
    stDocName = stInitialName
    Do Until wlib_ErrNameOK(wlib_dbCur, iDocType, stDocName) = -1
        i = i + 1
        stDocName = stPrefix & i
        If Len(stDocName) > 64 Then GoTo wlib_StUniqueDocName_DefaultName
    Loop
    wlib_StUniqueDocName = stDocName
wlib_StUniqueDocName_Exit:
    wlib_CloseCurrentDB
    Exit Function
wlib_StUniqueDocName_DefaultName:
    wlib_StUniqueDocName = wlib_StUniqueDocName(wlib_StObjFromIObj(iDocType) & 1, iDocType)
    GoTo wlib_StUniqueDocName_Exit
End Function
Function wlib_OpenAccessRegKey(stAccessSubKey As String, hkey As Long) As Long
    Dim stProfile As String
    Dim stSubKey As String
    Dim stProfilePath As String * 255
    Dim hkeyRoot As Long
    Dim lErr As Long
    hkey = 0
    stSubKey = "SOFTWARE\Microsoft\Office\8.0\Access"
    stProfile = Nz(SysCmd(acSysCmdProfile), "")
    If (stProfile <> "") Then
        lErr = wlib_RegOpenKeyEx(&H80000002, "SOFTWARE\Microsoft\Office\8.0\Access", 0&, &HF003F, hkeyRoot)
        If lErr <> 0 Then Exit Function
        lErr = wlib_ErrGetRegVal(hkeyRoot, "Profiles", stProfile, ByVal stProfilePath, 255)
        wlib_RegCloseKey hkeyRoot
        If lErr <> 0 Then Exit Function
        stSubKey = wlib_StFromSz(stProfilePath)
    End If
    If (stAccessSubKey <> "") Then
        stSubKey = stSubKey & "\" & stAccessSubKey
    End If
    lErr = wlib_RegOpenKeyEx(&H80000002, stSubKey, 0&, &HF003F, hkey)
    If (lErr) Then
        lErr = wlib_RegOpenKeyEx(&H80000002, stSubKey, 0&, &H2001F, hkey)
    End If
    wlib_OpenAccessRegKey = lErr
End Function
Function wlib_StObjFromIObj(iObjectType As Integer, Optional fDisplayString As Boolean) As String
    Dim iLCID  As Long
    If fDisplayString Then
        wlib_StObjFromIObj = wlib_StFromAccessIds(20000 + iObjectType)
    Else
        wlib_StObjFromIObj = wlib_StFromAccessIds(11508 + iObjectType)
    End If
End Function
Function wlib_StOfHscrIscc(hscr As Long, iscc As Long) As String
    Dim stBuf As String
    stBuf = String$(255, Chr$(0))
    If (wlib_FGetStringHscrIscc(hscr, iscc, stBuf, 255)) Then
        stBuf = wlib_StFromSz(stBuf)
    Else
        stBuf = ""
    End If
    wlib_StOfHscrIscc = stBuf
End Function
Function wlib_StLocalPictFromEnglishPict(stUsPict As String) As String
    Dim stBuf As String * 1024
    Dim stRet As String
    stRet = stUsPict
    If (stUsPict <> "") Then
        If (wlib_FEnglishPictToLocal(stUsPict, stBuf, 1024)) Then
            stRet = wlib_StFromSz(stBuf)
        End If
    End If
    wlib_StLocalPictFromEnglishPict = stRet
End Function
Public Function wlib_StDocCntOfIDocType(iDocType As Integer) As String
    Select Case iDocType
        Case acTable, acQuery
            wlib_StDocCntOfIDocType = "Tables"
        Case acForm
            wlib_StDocCntOfIDocType = "Forms"
        Case acReport
            wlib_StDocCntOfIDocType = "Reports"
        Case acMacro
            wlib_StDocCntOfIDocType = "Scripts"
        Case acModule
            wlib_StDocCntOfIDocType = "Modules"
    End Select
End Function
Function wlib_StDirOfFullPath(stPath As String) As String
    Dim stDrive As String, stDir As String, stFName As String, stExt As String
    wlib_ParseFullPath stPath, stDrive, stDir, stFName, stExt
    wlib_StDirOfFullPath = stDrive & stDir
End Function

'---
Attribute VB_Name = "wlib_Util2"
Option Compare Database
Option Explicit
Declare Function wlib_HscrOpenEx Lib "msaccess.exe" Alias "#18" (ByVal lpszScript As String, ByVal lpszLabel As Any, ByVal smode As Long, pgrfExtra As Long, psmv As Long) As Long
Declare Sub wlib_RewindHscr Lib "msaccess.exe" Alias "#19" (ByVal hscr As Long)
Declare Sub wlib_CloseHscr Lib "msaccess.exe" Alias "#20" (ByVal hscr As Long)
Declare Sub wlib_AbortHscr Lib "msaccess.exe" Alias "#21" (ByVal hscr As Long)
Declare Function wlib_FNextHscr Lib "msaccess.exe" Alias "#22" (ByVal hscr As Long, ByVal fSkipBlank As Long, pfEndOfScript As Long) As Long
Declare Function wlib_FGetStringHscrIscc Lib "msaccess.exe" Alias "#23" (ByVal hscr As Long, ByVal iscc As Long, ByVal lpsz As String, ByVal cchMax As Long) As Long
Declare Function wlib_FSaveStringHscrIscc Lib "msaccess.exe" Alias "#24" (ByVal hscr As Long, ByVal iscc As Long, ByVal lpsz As String) As Long
Declare Function wlib_FSaveActidHscr Lib "msaccess.exe" Alias "#25" (ByVal hscr As Long, ByVal actid As Long) As Long
Declare Function wlib_LGetMacroVersion Lib "msaccess.exe" Alias "#26" (ByVal hscr As Long) As Long
Declare Function wlib_FSetMacroVersion Lib "msaccess.exe" Alias "#27" (ByVal hscr As Long, ByVal lVer As Long) As Long
Declare Function wlib_IsrowOfHscr Lib "msaccess.exe" Alias "#28" (ByVal hscr As Long) As Long
Declare Function wlib_ActidOfHscr Lib "msaccess.exe" Alias "#29" (ByVal hscr As Long) As Long
Declare Function wlib_CargsOfActid Lib "msaccess.exe" Alias "#30" (ByVal actid As Long) As Long
Declare Sub wlib_FillLszFromActid Lib "msaccess.exe" Alias "#32" (ByVal lpsz As String, ByVal CCHBUF As Long, ByVal actid As Long)
Declare Function wlib_IdsArgNameOfActidIarg Lib "msaccess.exe" Alias "#33" (ByVal actid As Long, ByVal iArg As Long) As Long
Declare Function wlib_IdsComboFillOfActidIarg Lib "msaccess.exe" Alias "#34" (ByVal actid As Long, ByVal iArg As Long) As Long
Declare Function wlib_ComboTypOfActidIarg Lib "msaccess.exe" Alias "#35" (ByVal actid As Long, ByVal iArg As Long) As Long
Declare Function wlib_IRunCommandIdFromDMIArgs Lib "msaccess.exe" Alias "#54" (ByVal wVer As Long, ByVal mb As Long, ByVal iMN As Long, ByVal iC As Long, ByVal iSC As Long) As Long
Declare Function wlib_FGlobalProcExists Lib "msaccess.exe" Alias "#37" (ByVal lpszProcName As String) As Long
Declare Function wlib_FOpenPictureFile Lib "msaccess.exe" Alias "#46" (ByVal szPicture As String, ByVal cchMax As Long, cchActual As Long, fCanceled As Long) As Long
Declare Function wlib_FXlateExpr Lib "msaccess.exe" Alias "#48" (ByVal lpszSrc As String, ByVal lpszDest As String, cchActual As Long, ByVal cchMax As Long, ByVal xpm As Long, ByVal flags As Long) As Long
Declare Function wlib_FIdsDBCSType Lib "msaccess.exe" Alias "#52" (ByVal lpszSrc As String, idsDat As Integer) As Boolean
Declare Function wlib_GetTcDIB Lib "msaccess.exe" Alias "#60" (ByVal idBmp As Long, ByVal fLarge As Long, rgbBuf() As Byte) As Long
Declare Function wlib_EnableWindow Lib "USER32" Alias "EnableWindow" (ByVal Hwnd As Long, ByVal fEnable As Long) As Integer
Dim fMeterStarted As Integer
Public Function wlib_CGetExecutableMacros(db As Database, rgstExeMacros() As String) As Integer
    Const CSTMACADD = 10
    Dim rgstSortedMacros() As String
    Dim cMacroSheets As Integer
    Dim iMacroSheet As Integer
    Dim hscr As Long
    Dim iMac As Integer
    Dim iMax As Integer
    Dim grfExtra As Long
    Dim lMacVersion As Long
    Dim fEndOfScript As Long
    Dim stMacroName As String
    Dim stLabel As String
    iMac = 1
    cMacroSheets = wlib_GetObjList(db, acMacro, rgstSortedMacros, &HFFFFF)
    For iMacroSheet = 1 To cMacroSheets
        stMacroName = rgstSortedMacros(iMacroSheet)
        If (iMac >= iMax) Then
            iMax = iMax + CSTMACADD
            ReDim Preserve rgstExeMacros(1 To iMax)
        End If
        rgstExeMacros(iMac) = stMacroName
        iMac = iMac + 1
        hscr = wlib_HscrOpenEx(stMacroName, 0&, 0&, grfExtra, lMacVersion)
        If (hscr > 0) Then
            While (wlib_FNextHscr(hscr, True, fEndOfScript))
                stLabel = wlib_StOfHscrIscc(hscr, 0&)
                If (stLabel <> "") Then
                    If (iMac >= iMax) Then
                        iMax = iMax + CSTMACADD
                        ReDim Preserve rgstExeMacros(1 To iMax)
                    End If
                    rgstExeMacros(iMac) = stMacroName & "." & stLabel
                    iMac = iMac + 1
                End If
            Wend
            wlib_CloseHscr hscr
        End If
    Next iMacroSheet
    wlib_CGetExecutableMacros = iMac - 1
End Function
Public Function wlib_FGetPictureFileName(stFilename As String)
    Dim szBuf As String * 1024
    Dim cchActual As Long
    Dim fCanceled As Long
    Dim fRet As Long
    If (wlib_FOpenPictureFile(szBuf, 255, cchActual, fCanceled)) Then
        If (fCanceled) Then
            wlib_FGetPictureFileName = True
            stFilename = ""
        Else
            stFilename = wlib_StFromSz(szBuf)
        End If
        fRet = True
    Else
        fRet = False
    End If
    wlib_FGetPictureFileName = fRet
End Function
Sub wlib_InitMeter(stText As String, cIncrements As Integer)
    fMeterStarted = True
    SysCmd acSysCmdInitMeter, stText, cIncrements
End Sub
Sub wlib_UpdateMeter(iValue As Integer)
    SysCmd acSysCmdUpdateMeter, iValue
End Sub
Sub wlib_RemoveMeter()
    If fMeterStarted Then
        SysCmd acSysCmdRemoveMeter
        fMeterStarted = False
        If wlib_caii > 0 Then
            SysCmd acSysCmdSetStatus, wlib_rgaii(wlib_caii - 1).stName
        End If
    End If
End Sub
Function wlib_StFileOfFullPath(stPath As String, Optional fFileNameOnly As Variant) As String
    Dim stDrive As String, stDir As String, stFName As String, stExt As String
    Dim stRetVal As String
    Dim fAddExtension As Integer
    wlib_ParseFullPath stPath, stDrive, stDir, stFName, stExt
    If (IsMissing(fFileNameOnly)) Then
        fAddExtension = True
    Else
        fAddExtension = Not fFileNameOnly
    End If
    stRetVal = stFName
    If (fAddExtension) Then
        stRetVal = stRetVal & stExt
    End If
    wlib_StFileOfFullPath = stRetVal
End Function
Function wlib_StTempFileName() As String
    Dim szTempPath As String * 144
    Dim szFileName As String * 144
    Dim uUnique As Long
    If (wlib_GetTempPath(144, szTempPath) > 0) Then
        uUnique = wlib_GetTempFileName(szTempPath, "wiz", 0, szFileName)
        wlib_StTempFileName = wlib_StFromSz(szFileName)
    Else
        wlib_StTempFileName = ""
    End If
End Function
Sub wlib_DoubleQuote(stText As String)
    Dim stNew As String
    Dim ichStart As Integer
    Dim ichQuote As Integer
    ichStart = 1
    Do While ichStart <= Len(stText)
        ichQuote = InStr(ichStart, stText, """")
        If ichQuote = 0 Then
            stNew = stNew & Right$(stText, Len(stText) - ichStart + 1)
            Exit Do
        Else
            If ichQuote > ichStart Then
                stNew = stNew & Mid$(stText, ichStart, ichQuote - ichStart)
            End If
            stNew = stNew & """"""
            ichStart = ichQuote + 1
        End If
    Loop
    stText = stNew
End Sub
Public Function wlib_FHasReadPermissions(doc As Document) As Integer
    Dim wks As Workspace
    Dim iGroup As Integer
    doc.UserName = CurrentUser()
    If ((doc.Permissions And DB_SEC_MAC_READDEF) = DB_SEC_MAC_READDEF) Then
        wlib_FHasReadPermissions = True
        Exit Function
    End If
    Set wks = DBEngine.Workspaces(0)
    With wks.Users(CurrentUser())
        For iGroup = 0 To .Groups.Count - 1
            doc.UserName = .Groups(iGroup).Name
            If ((doc.Permissions And DB_SEC_MAC_READDEF) = DB_SEC_MAC_READDEF) Then
                wlib_FHasReadPermissions = True
                Exit Function
            End If
        Next iGroup
    End With
    wlib_FHasReadPermissions = False
End Function
Function wlib_LDmiVerOfHscr(hscr As Long) As Long
    Dim st As String
    st = wlib_StOfHscrIscc(hscr, 3& + 6)
    Select Case Val(st)
        Case acMenuVer70, 30
            wlib_LDmiVerOfHscr = acMenuVer70
        Case acMenuVer20
            wlib_LDmiVerOfHscr = acMenuVer20
        Case Else
            wlib_LDmiVerOfHscr = 10
    End Select
End Function
'---
Attribute VB_Name = "tw_TableWizard"
Option Compare Database
Option Explicit
Type TW_FLDINFO
    iFldIndex As Integer
    lFldID As Long
    stFldName As String
    fPK As Integer
    iDataType As Integer
    iSize As Integer
    stCaption As String
    lLookupTableID As Long
    lFlags As Long
End Type
Type TW_CREATETABLEINFO
    lTableID As Long
    stTblName As String
    stDescription As String
    rgfldi() As TW_FLDINFO
    cfldi As Integer
    lFlags As Long
End Type
Type TW_RELTABLEINFO
    stTableName As String
    iRelType As Integer
    stFieldName As String
    fAddKeyToNew As Integer
    fAddKeyToExisting As Integer
End Type
Type TW_RELINFO
    db As Database
    stTable As String
    stForeignTable As String
    cFields As Integer
    rgstField() As String
    rgstForeignField() As String
    lAttributes As Long
    fSetLookupProps As Integer
    iDisplayControl As Integer
    stRowSourceType As String
    stRowSource As String
    iBoundCol As Integer
    cCols As Integer
    fColHeads As Integer
    stColWidths As String
    cListRows As Integer
    nListWidth As Integer
    fLimitToList As Integer
End Type
Global tw_dbCode As Database
Global tw_rsStrings As Recordset
Global tw_dbData As Database
Global tw_stBuilderRetVal As String
Global tw_stCurFldName As String
Global tw_fCancel As Boolean
Global tw_stBackend As String
Global tw_cFld As Integer
Global tw_rgfldi() As TW_FLDINFO
Global tw_cRelTbl As Integer
Global tw_rgrelti() As TW_RELTABLEINFO
Global tw_stNotRelated As String
Global tw_stRelated As String
Type TW_UIINFO
    fFldAdded As Integer
    fTableNameAdded As Integer
    stTableName As String
    fUserDefinedPK As Integer
    iPK As Integer
    iPKDataType As Integer
    fRelsSeen As Integer
    fRelsDirty As Integer
    fRelsVerified As Integer
    iView As Integer
    fLargeCard As Integer
End Type
Global tw_uii As TW_UIINFO
Global tw_fFillFuncInited As Integer
Dim fOpenedCurrentDB As Integer
Sub tw_AddIndex(td As TableDef, cFields As Integer, rgstFields() As String, stName As String)
On Error Resume Next
    Dim idx As Index
    Dim iField As Integer
    If Len(stName) = 0 Then stName = wlib_StFromRsIds(60, tw_rsStrings, "Message")
    stName = tw_StUniqueIndexName(td, stName)
    Set idx = td.CreateIndex(stName)
    For iField = 0 To cFields - 1
        idx.Fields.Append idx.CreateField(rgstFields(iField))
    Next iField
    idx.Primary = False
    idx.Unique = False
    td.Indexes.Append idx
End Sub
Private Sub AppendProp(fd As Field, stPropName As String, iPropType As Integer, PropVal As Variant)
On Error GoTo AppendProp_Err
    fd.Properties(stPropName).Value = PropVal
AppendProp_Exit:
    Exit Sub
AppendProp_Err:
    If Err = 3270 Then
        fd.Properties.Append fd.CreateProperty(stPropName, iPropType, PropVal, True)
        Resume Next
    Else
        wlib_HandleError Err, Error$
        Resume AppendProp_Exit
    End If
End Sub
Private Sub AttachError(errAttach As Long)
    Select Case errAttach
        Case 32000
            wlib_IMsgBox 27, "", vbOKOnly Or vbInformation
        Case 31997
            wlib_IMsgBox 26, "", vbOKOnly Or vbInformation
        Case Else
            wlib_IMsgBox 26, "", vbOKOnly Or vbInformation
    End Select
End Sub
Function tw_FIndexExists(td As TableDef, cFields As Integer, rgstFields() As String) As Integer
    Dim idx As Index
    Dim iidxfld As Integer
    Dim fIndexed As Integer
    td.Indexes.Refresh
    For Each idx In td.Indexes
        fIndexed = True
        If idx.Fields.Count = cFields Then
            For iidxfld = 0 To idx.Fields.Count - 1
                fIndexed = fIndexed And (idx.Fields(iidxfld).Name = rgstFields(iidxfld))
                If fIndexed = False Then Exit For
            Next iidxfld
            If fIndexed = True Then
                tw_FIndexExists = True
                Exit Function
            End If
        End If
    Next idx
    tw_FIndexExists = False
End Function
Private Sub Init(idsName As Integer, fAddInStarted As Integer)
    wlib_OpenCurrentDB
    fOpenedCurrentDB = True
    Set tw_dbCode = CodeDb()
    Set tw_rsStrings = tw_dbCode.OpenRecordset("tw_tblStrings", dbOpenTable, dbDenyRead)
    tw_rsStrings.Index = "PrimaryKey"
    If idsName <> -1 Then
        wlib_StartAddIn idsName, tw_rsStrings, "Message"
        fAddInStarted = True
    End If
End Sub
Function tw_StUniqueIndexName(td As TableDef, stIndexName As String) As String
On Error Resume Next
    Dim i As Integer
    Dim st As String
    Dim stCurrentName As String
    st = td.Indexes(stIndexName).Name
    If Err = 0 Then
        Do
            stCurrentName = Left$(stIndexName, 64 - Len(i)) & i
            st = td.Indexes(stCurrentName).Name
            i = i + 1
        Loop Until Err <> 0
        tw_StUniqueIndexName = stCurrentName
    Else
        tw_StUniqueIndexName = stIndexName
    End If
End Function
Private Function StUniqueRelName(db As Database) As String
    Dim iCur As Integer
    Dim stCur As String
    Dim st As String
    db.Relations.Refresh
On Error Resume Next
    stCur = "Reference"
    st = db.Relations(stCur).Name
    While (Err = 0)
        iCur = iCur + 1
        stCur = "Reference" & iCur
        st = db.Relations(stCur).Name
    Wend
    StUniqueRelName = stCur
End Function
Sub tw_CleanRels()
    Dim i As Integer
    For i = 0 To tw_cRelTbl - 1
        tw_rgrelti(i).stTableName = ""
        tw_rgrelti(i).iRelType = 0
        tw_rgrelti(i).stFieldName = ""
        tw_rgrelti(i).fAddKeyToNew = False
        tw_rgrelti(i).fAddKeyToExisting = False
    Next i
    tw_uii.fRelsDirty = False
End Sub
Function tw_Entry()
On Error GoTo tw_Entry_Err
    Dim fAddInStarted As Integer
    Dim errAttach As Long
    Init 57, fAddInStarted
    errAttach = tw_ErrAttachMdtTables(tw_dbCode, "", tw_stBackend)
    If errAttach <> 0 Then
        AttachError errAttach
    Else
        Set tw_dbData = OpenDatabase(tw_stBackend, False)
        tw_fCancel = False
        DoCmd.OpenForm "tw_frmTblWiz", , , , , acDialog
    End If
tw_Entry_Exit:
On Error Resume Next
    Uninit fAddInStarted
    tw_dbData.close
    Exit Function
tw_Entry_Err:
    wlib_HandleError Err, Error$
    Resume tw_Entry_Exit
End Function
Function tw_ErrCreateRel(reli As TW_RELINFO) As Integer
On Error GoTo tw_ErrCreateRel_Err
    If tw_FCreateRelEngine(reli) = 0 Then
        tw_ErrCreateRel = 0
    Else
        tw_ErrCreateRel = -1
    End If
tw_ErrCreateRel_Exit:
    Exit Function
tw_ErrCreateRel_Err:
    tw_ErrCreateRel = Err
    Resume tw_ErrCreateRel_Exit
End Function
Function tw_ErrCreateTable(cti As TW_CREATETABLEINFO) As Integer
On Error GoTo tw_ErrCreateTable_Err
    Dim ifldi As Integer
    tw_cFld = cti.cfldi
    ReDim tw_rgfldi(0 To cti.cfldi - 1)
    For ifldi = 0 To tw_cFld - 1
        tw_rgfldi(ifldi) = cti.rgfldi(ifldi)
    Next ifldi
    If tw_FCreateTableEngine(cti.stTblName, 0, False) = 0 Then
        tw_ErrCreateTable = 0
    Else
        tw_ErrCreateTable = -1
    End If
tw_ErrCreateTable_Exit:
On Error Resume Next
    Exit Function
tw_ErrCreateTable_Err:
    tw_ErrCreateTable = Err
    Resume tw_ErrCreateTable_Exit
End Function
Function tw_ErrInitEngine(stMdtPath As String) As Integer
On Error GoTo tw_ErrInitEngine_Err
    Init -1, 0
    Set tw_dbData = OpenDatabase(stMdtPath, False)
    tw_ErrInitEngine = 0
tw_ErrInitEngine_Exit:
    Exit Function
tw_ErrInitEngine_Err:
    tw_ErrInitEngine = Err
    Resume tw_ErrInitEngine_Exit
End Function
Function tw_ErrUnInitEngine() As Integer
On Error GoTo tw_ErrUnInitEngine_Err
    Uninit 0
    tw_dbData.close
    tw_ErrUnInitEngine = 0
tw_ErrUnInitEngine_Exit:
    Exit Function
tw_ErrUnInitEngine_Err:
    tw_ErrUnInitEngine = Err
    Resume tw_ErrUnInitEngine_Exit
End Function
Function tw_FCreateRelEngine(reli As TW_RELINFO)
On Error GoTo tw_FCreateRelEngine_Err
    Dim tdPrimary As TableDef
    Dim tdForeign As TableDef
    Dim fErr As Integer
    Dim stTmp As String
    Dim fld As Field
    Dim rel As Relation
    Dim iFld As Integer
    Dim cFields As Integer
    Set tdPrimary = reli.db.TableDefs(reli.stTable)
    Set tdForeign = reli.db.TableDefs(reli.stForeignTable)
    For iFld = 0 To reli.cFields - 1
On Error Resume Next
        stTmp = tdForeign.Fields(reli.rgstForeignField(iFld)).Name
        fErr = (Err <> 0)
On Error GoTo tw_FCreateRelEngine_Err
        If fErr Then
            If tdPrimary(reli.rgstField(iFld)).Type = dbText Then
                Set fld = tdForeign.CreateField(reli.rgstForeignField(iFld), tdPrimary(reli.rgstField(iFld)).Type, tdPrimary(reli.rgstField(iFld)).Size)
            Else
                Set fld = tdForeign.CreateField(reli.rgstForeignField(iFld), tdPrimary(reli.rgstField(iFld)).Type)
            End If
            fld.OrdinalPosition = tdForeign.Fields.Count + 1
            tdForeign.Fields.Append fld
        End If
    Next iFld
    If Not tw_FIndexExists(tdPrimary, reli.cFields, reli.rgstField()) Then tw_AddIndex tdPrimary, reli.cFields, reli.rgstField(), reli.rgstField(0)
    If Not tw_FIndexExists(tdForeign, reli.cFields, reli.rgstForeignField()) Then tw_AddIndex tdForeign, reli.cFields, reli.rgstForeignField(), reli.rgstForeignField(0)
    Set rel = reli.db.CreateRelation(StUniqueRelName(reli.db), reli.stTable, reli.stForeignTable, reli.lAttributes)
    For iFld = 0 To reli.cFields - 1
        Set fld = rel.CreateField(reli.rgstField(iFld))
        fld.ForeignName = reli.rgstForeignField(iFld)
        rel.Fields.Append fld
    Next iFld
    reli.db.Relations.Append rel
    If (reli.fSetLookupProps) Then
        SetLookupProps reli, tdForeign
    End If
    tw_FCreateRelEngine = 0
tw_FCreateRelEngine_Exit:
    Exit Function
tw_FCreateRelEngine_Err:
    tw_FCreateRelEngine = Err
    Resume tw_FCreateRelEngine_Exit
End Function
Private Sub SetLookupProps(reli As TW_RELINFO, td As TableDef)
    Dim fld As Field
    Set fld = td.Fields(reli.rgstForeignField(0))
    fld.Properties.Append fld.CreateProperty("DisplayControl", dbInteger, reli.iDisplayControl)
    fld.Properties.Append fld.CreateProperty("RowSourceType", dbText, reli.stRowSourceType)
    fld.Properties.Append fld.CreateProperty("RowSource", dbMemo, reli.stRowSource)
    fld.Properties.Append fld.CreateProperty("BoundColumn", dbInteger, reli.iBoundCol)
    fld.Properties.Append fld.CreateProperty("ColumnCount", dbInteger, reli.cCols)
    fld.Properties.Append fld.CreateProperty("ColumnHeads", dbBoolean, reli.fColHeads)
    fld.Properties.Append fld.CreateProperty("ColumnWidths", dbText, reli.stColWidths)
    fld.Properties.Append fld.CreateProperty("ListRows", dbInteger, reli.cListRows)
    fld.Properties.Append fld.CreateProperty("ListWidth", dbText, reli.nListWidth)
    fld.Properties.Append fld.CreateProperty("LimitToList", dbBoolean, reli.fLimitToList)
End Sub
Function tw_FCreateTableEngine(stName As String, iPKDataType As Integer, fTableWizard As Integer) As Integer
On Error GoTo tw_FCreateTableEngine_Err
    Dim i As Integer
    Dim fPKAdded As Integer
    Dim rsFieldInfo As Recordset
    Dim td As TableDef
    Dim fd As Field
    Dim idx As Index
    Dim prop As Property
    Dim stPropName As String
    Dim iPropType As Integer
    Dim fInTrans As Integer
    Dim fHideHourglass As Integer
    Dim rsInputMask As Recordset
    Dim iCountryCode As Integer
    Dim stInputMask As String
    Dim rsFormat As Recordset
    Dim stTmp As String
    Dim rgstFields(0) As String
    If tw_ErrVerifyTableName(stName, True) <> -1 Then
        tw_FCreateTableEngine = 1
        Exit Function
    End If
    wlib_Hourglass True
    fHideHourglass = True
    fInTrans = True
    BeginTrans
        Set td = wlib_dbCur.CreateTableDef()
        If fTableWizard Then SysCmd acSysCmdSetStatus, wlib_StFromRsIds(50, tw_rsStrings, "Message")
        For i = 0 To tw_cFld - 1
            If tw_rgfldi(i).iDataType = dbText Then
                Set fd = td.CreateField(tw_rgfldi(i).stFldName, tw_rgfldi(i).iDataType, tw_rgfldi(i).iSize)
            Else
                Set fd = td.CreateField(tw_rgfldi(i).stFldName, tw_rgfldi(i).iDataType)
            End If
            fd.OrdinalPosition = i + 1
            If tw_rgfldi(i).fPK And Not (fPKAdded) Then
                Set idx = td.CreateIndex(wlib_StFromRsIds(55, tw_rsStrings, "Message"))
                idx.Fields.Append idx.CreateField(fd.Name)
                idx.Primary = True
                idx.Unique = True
                Select Case iPKDataType
                    Case 0, 1
                        fd.Type = dbLong
                        fd.Attributes = fd.Attributes Or dbAutoIncrField
                    Case 2
                        fd.Type = dbLong
                    Case 3
                        fd.Type = dbText
                End Select
                fPKAdded = True
                td.Indexes.Append idx
                fd.OrdinalPosition = 0
            End If
            td.Fields.Append fd
        Next i
        If Not fPKAdded Then
            stTmp = wlib_StFromRsIds(20, tw_rsStrings, "Message")
            wlib_ReplaceStr stTmp, "|", (stName)
            Set fd = td.CreateField(stTmp, dbLong)
            fd.Attributes = fd.Attributes Or dbAutoIncrField
            fd.OrdinalPosition = 0
            td.Fields.Append fd
            Set idx = td.CreateIndex(wlib_StFromRsIds(55, tw_rsStrings, "Message"))
            idx.Fields.Append idx.CreateField(fd.Name)
            idx.Primary = True
            idx.Unique = True
            td.Indexes.Append idx
        End If
        td.Name = stName
        wlib_dbCur.TableDefs.Append td
        Set rsFieldInfo = tw_dbData.OpenRecordset("tw_qryFieldInfo", dbOpenDynaset)
        For i = 0 To tw_cFld - 1
            rsFieldInfo.FindFirst "[FieldID] = " & Format$(tw_rgfldi(i).lFldID)
            If rsFieldInfo.NoMatch Then
                stName = ""
                tw_FCreateTableEngine = 2
                GoTo tw_FCreateTableEngine_Exit
            Else
                Set fd = wlib_dbCur.TableDefs(stName).Fields(tw_rgfldi(i).stFldName)
                If Nz(rsFieldInfo![Caption], "") <> "" Then
                    If tw_rgfldi(i).stCaption <> "{CHANGED}" Then AppendProp fd, "Caption", dbMemo, rsFieldInfo![Caption]
                End If
                If Nz(rsFieldInfo![Format], "") <> "" Then
                    If (tw_rgfldi(i).iDataType = dbDate) Or (tw_rgfldi(i).iDataType = dbBoolean) Then
                        If rsFormat Is Nothing Then Set rsFormat = tw_dbCode.OpenRecordset("tblFormat", dbOpenDynaset)
                        rsFormat.FindFirst "[LocFormat] = '" & rsFieldInfo![Format] & "'"
                        If rsFormat.NoMatch Then
                            AppendProp fd, "Format", dbText, rsFieldInfo![Format]
                        Else
                            AppendProp fd, "Format", dbText, rsFormat!USFormat
                        End If
                    Else
                        AppendProp fd, "Format", dbText, rsFieldInfo![Format]
                    End If
                End If
                If Nz(rsFieldInfo![Description], "") <> "" Then AppendProp fd, "Description", dbText, rsFieldInfo![Description]
                If Nz(rsFieldInfo![DecimalPlaces], "") <> "" Then AppendProp fd, "DecimalPlaces", dbByte, rsFieldInfo![DecimalPlaces]
                If Nz(rsFieldInfo![DefaultValue], "") <> "" Then AppendProp fd, "DefaultValue", dbMemo, rsFieldInfo![DefaultValue]
                If Nz(rsFieldInfo![ValidationRule], "") <> "" Then AppendProp fd, "ValidationRule", dbMemo, rsFieldInfo![ValidationRule]
                If Nz(rsFieldInfo![ValidationText], "") <> "" Then AppendProp fd, "ValidationText", dbText, rsFieldInfo![ValidationText]
                If Nz(rsFieldInfo![InputMaskID], 0) <> 0 Then
                    If rsFieldInfo![InputMaskID] = 9 Then
                        stInputMask = Nz(rsFieldInfo!InputMask, "")
                    Else
                        If rsInputMask Is Nothing Then
                            Set rsInputMask = tw_dbData.OpenRecordset("tblInputMasks", dbOpenDynaset)
                            iCountryCode = wlib_GetProfileInt("Intl", "iCountry", 0)
                        End If
                        rsInputMask.FindFirst "[InputMaskID] = " & rsFieldInfo![InputMaskID] & " AND [CountryCode] = " & Format$(iCountryCode)
                        If rsInputMask.NoMatch And iCountryCode <> 0 Then
                            rsInputMask.FindFirst "[InputMaskID] = " & rsFieldInfo![InputMaskID] & " AND [CountryCode] = 0"
                        End If
                        If Not rsInputMask.NoMatch Then
                            stInputMask = Nz(rsInputMask!Mask, "")
                        End If
                    End If
                    If Len(stInputMask) Then
                        If fd.Type = dbDate Then stInputMask = stInputMask & ";0"
                        AppendProp fd, "InputMask", dbText, stInputMask
                    End If
                End If
                If Nz(rsFieldInfo![Required], 0) <> 0 Then AppendProp fd, "Required", dbBoolean, rsFieldInfo![Required]
                If Nz(rsFieldInfo![AllowZeroLength], 0) <> 0 Then AppendProp fd, "AllowZeroLength", dbBoolean, rsFieldInfo![AllowZeroLength]
                If Nz(rsFieldInfo![Indexed], 0) <> 0 Then
                    rgstFields(0) = fd.Name
                    If Not tw_FIndexExists(td, 1, rgstFields()) Then
                        tw_AddIndex td, 1, rgstFields(), rgstFields(0)
                    End If
                End If
            End If
        Next i
    CommitTrans
    fInTrans = False
    rsFieldInfo.close
    If Not (rsInputMask Is Nothing) Then rsInputMask.close
    If Not (rsFormat Is Nothing) Then rsFormat.close
    tw_FCreateTableEngine = 0
tw_FCreateTableEngine_Exit:
On Error Resume Next
    If fTableWizard Then SysCmd acSysCmdClearStatus
    If (fHideHourglass) Then wlib_Hourglass False
    Exit Function
tw_FCreateTableEngine_Err:
    tw_FCreateTableEngine = 3
    If fInTrans Then
        Rollback
        fInTrans = False
    End If
    Resume tw_FCreateTableEngine_Exit
End Function
Function tw_FieldEntry(stObjName As String, stCtlName As String, stCurVal As String) As String
On Error GoTo tw_FieldEntry_Err
    Dim fAddInStarted As Integer
    Dim errAttach As Long
    Init 59, fAddInStarted
    errAttach = tw_ErrAttachMdtTables(tw_dbCode, "", tw_stBackend)
    If errAttach <> 0 Then
        AttachError errAttach
    Else
        DoCmd.OpenForm "tw_frmFieldBuilder", acNormal, , , , acDialog
    End If
tw_FieldEntry_Exit:
On Error Resume Next
    Uninit fAddInStarted
    tw_FieldEntry = tw_stBuilderRetVal
    Exit Function
tw_FieldEntry_Err:
    wlib_HandleError Err, Error$
    tw_stBuilderRetVal = Chr$(0)
    Resume tw_FieldEntry_Exit
End Function
Function tw_ErrVerifyTableName(stName As String, fSilent As Integer) As Long
On Error GoTo tw_ErrVerifyTableName_Err
    Dim errReturned As Long
    wlib_dbCur.TableDefs.Refresh
    errReturned = wlib_ErrNameOK(wlib_dbCur, acTable, stName)
    Select Case errReturned
        Case 1, 3
            If Not fSilent Then wlib_IMsgBox 40, "", vbOKOnly Or vbInformation
            tw_ErrVerifyTableName = errReturned
        Case 2
            If Not fSilent Then
                If (wlib_IMsgBox(22, stName, vbYesNo Or vbExclamation) = vbYes) Then
On Error Resume Next
                    wlib_dbCur.TableDefs.delete (stName)
                    wlib_dbCur.QueryDefs.delete (stName)
                    Application.RefreshDatabaseWindow
On Error GoTo tw_ErrVerifyTableName_Err
                    tw_ErrVerifyTableName = -1
                Else
                    tw_ErrVerifyTableName = 2
                End If
            End If
        Case 0
            If Not fSilent Then wlib_IMsgBox 25, "", vbOKOnly Or vbInformation
            tw_ErrVerifyTableName = 0
        Case Else
            tw_ErrVerifyTableName = -1
    End Select
tw_ErrVerifyTableName_Exit:
    Exit Function
tw_ErrVerifyTableName_Err:
    tw_ErrVerifyTableName = False
    Resume tw_ErrVerifyTableName_Exit
End Function
Private Sub Uninit(fAddInStarted As Integer)
On Error Resume Next
    tw_rsStrings.close
    tw_dbCode.close
    If fOpenedCurrentDB Then wlib_CloseCurrentDB
    If fAddInStarted Then wlib_EndAddIn
End Sub
Function tw_FldFill(fld As Control, handle As Long, lRow As Long, icol As Long, Code As Integer) As Variant
On Error GoTo tw_FieldFill_Err
    If tw_fCancel Then
        tw_FldFill = -1&
        GoTo tw_FieldFill_Exit
    End If
    Select Case Code
        Case acLBInitialize
            If Not tw_fFillFuncInited Then
                tw_cFld = 0
                Erase tw_rgfldi
                tw_fFillFuncInited = True
            End If
            tw_FldFill = -1&
        Case acLBOpen
            tw_FldFill = -1&
        Case acLBGetRowCount
            tw_FldFill = tw_cFld
        Case acLBGetColumnCount
            tw_FldFill = 5
        Case acLBGetColumnWidth
            tw_FldFill = -1&
        Case acLBGetValue
            Select Case icol
                Case 0
                    tw_FldFill = tw_rgfldi(lRow).iFldIndex
                Case 1
                    tw_FldFill = tw_rgfldi(lRow).lFldID
                Case 2
                    tw_FldFill = tw_rgfldi(lRow).stFldName
                Case 3
                    tw_FldFill = tw_rgfldi(lRow).fPK
                Case 4
                    tw_FldFill = tw_rgfldi(lRow).iDataType
            End Select
        Case acLBGetFormat
            tw_FldFill = -1&
    End Select
tw_FieldFill_Exit:
    Exit Function
tw_FieldFill_Err:
    wlib_HandleError Err, Error$
    Resume tw_FieldFill_Exit
End Function
Function tw_ErrAttachMdtTables(dbAttachTo As Database, stPrefix As String, stBackend As String) As Integer
On Error GoTo tw_ErrAttachMdtTables_Err
    Dim fSilent As Integer
    Dim fInTrans As Integer
    Dim fHideHourglass As Integer
    Dim dbCode As Database
    Dim stConnect As String
    Dim rsMdtTables As Recordset
    Dim stTblName As String
    Dim lErr As Long
    If (stBackend = "") Then
        wlib_ErrGetMdtPath True, stBackend
        If (lErr <> 0 Or stBackend = "") Then
            Error lErr
        End If
    Else
        fSilent = True
    End If
    If stBackend = CurrentDb.Name Then
        Error 31997
    End If
    stConnect = ";DATABASE=" & stBackend
    wlib_Hourglass True
    fHideHourglass = True
    Set dbCode = CodeDb()
    Set rsMdtTables = dbCode.OpenRecordset("wlib_tblMdtTables", dbOpenTable)
    BeginTrans
    fInTrans = True
    If (Not fSilent) Then wlib_InitMeter wlib_StFromWlibIds(2), 100
    Do While (Not (rsMdtTables.EOF))
        On Error Resume Next
        stTblName = dbAttachTo.TableDefs(stPrefix & rsMdtTables![TableName]).Name
        lErr = Err
        On Error GoTo tw_ErrAttachMdtTables_Err
        If (lErr = 0) Then
            If (dbAttachTo.TableDefs(stTblName).Connect <> stConnect) Then
                dbAttachTo.TableDefs(stTblName).Connect = stConnect
                dbAttachTo.TableDefs(stTblName).RefreshLink
            Else
                Exit Do
            End If
        End If
        If (Not fSilent) Then wlib_UpdateMeter (rsMdtTables.PercentPosition)
        rsMdtTables.MoveNext
    Loop
    If (Not fSilent) Then wlib_RemoveMeter
    CommitTrans
    rsMdtTables.close
    dbCode.close
    tw_ErrAttachMdtTables = 0
tw_ErrAttachMdtTables_Exit:
On Error Resume Next
    If (fHideHourglass) Then wlib_Hourglass False
    Exit Function
tw_ErrAttachMdtTables_Err:
    If (fInTrans) Then
        Rollback
        dbCode.TableDefs.Refresh
    End If
    If (Not fSilent) Then wlib_RemoveMeter
    tw_ErrAttachMdtTables = Err
    Resume tw_ErrAttachMdtTables_Exit
End Function
'---
Attribute VB_Name = "pub_modMain"
Option Compare Database
Option Explicit
Type PUB_DOCTYPE
    id As Integer
    stName As String
    stOutputType As String
End Type
Type PUB_SPEC
    id As Integer
    stName As String
End Type
Type PUB_OBJECT
    iDocType As Integer
    stFilename As String
    stHTMLTemplate As String
    fPointToHTM As Boolean
End Type
Type PUB_FRIENDLY_NAMES
    cNames As Integer
    stFriendlyName() As String
End Type
Type LIST_INFO
    rgIdx As Integer
    fSelected As Boolean
End Type
Type PUB_WIZINFO
    fInitSelObj As Boolean
    fUseOldSpec As Boolean
    stSpecName As String
    fSaveSpec As Boolean
    fCreateHomePage As Boolean
    stHomePageName As String
    stDefaultTemplate As String
    fCustomizeTemplate As Boolean
    fCustomizeFilename As Boolean
    fCustomizeOutputFmt As Boolean
    stDSN As String
    stUsername As String
    stPassword As String
    stServerURL As String
    stSessionTimeout As String
    stDirectory As String
    iOutputFormat As Integer
    iWebPost As Integer
    fUseWebPost As Boolean
    stWebPostFN As String
    cSpec As Integer
    rgstspec() As PUB_SPEC
    rgpubobj() As PUB_OBJECT
    pfn As PUB_FRIENDLY_NAMES
    fChangePageOne As Boolean
    fCancelWiz As Boolean
End Type
Global pub_fFinished As Boolean
Global pub_pwi As PUB_WIZINFO
Global pub_rgpdt() As PUB_DOCTYPE
Global pub_cpdt As Integer
Global pub_rsStrings As Recordset
Global pub_dbCode As Database
Global pub_gfni As WLIB_OFFICEGETFILENAMEINFO
Global pub_stObjNames() As String
Sub pub_FillSpecName(psp() As PUB_SPEC)
On Error GoTo pub_FillSpecName_Err
    Dim stSpecs As String
    Dim prp As Property
    Dim c As Integer
    c = 0
    For Each prp In wlib_dbCur.Properties
        If prp.Name = "pubwiz_SpecName" Then
            stSpecs = prp.Value
            Do Until Len(stSpecs) = 0
                ReDim Preserve psp(1 To (c + 1))
                psp(c + 1).id = c + 1
                psp(c + 1).stName = wlib_StGetToken(stSpecs, ";")
                c = c + 1
            Loop
            Exit For
        End If
    Next prp
    pub_pwi.cSpec = c
pub_FillSpecName_Exit:
    Exit Sub
pub_FillSpecName_Err:
    pub_pwi.cSpec = 0
    Resume pub_FillSpecName_Exit
End Sub
Private Sub pub_ClearWizInfo()
    With pub_pwi
        .fInitSelObj = False
        .fUseOldSpec = False
        .stSpecName = ""
        .fSaveSpec = False
        .fCreateHomePage = False
        .stHomePageName = ""
        .fCustomizeTemplate = False
        .fCustomizeFilename = False
        .fCustomizeOutputFmt = False
        .iOutputFormat = 1
        .iWebPost = 1
        .fUseWebPost = False
        .stWebPostFN = ""
        .stDirectory = CurDir()
        .stDSN = Application.GetOption("Data Source Name")
        .stUsername = Application.GetOption("User Name")
        .stPassword = Application.GetOption("Password")
        .stDefaultTemplate = Application.GetOption("HTML Template")
        .stServerURL = Application.GetOption("Active Server Pages URL")
        .stSessionTimeout = Application.GetOption("Active Server Pages Session Timeout")
        Erase .rgpubobj
        .cSpec = 0
        Erase .rgstspec
        .pfn.cNames = 0
        Erase .pfn.stFriendlyName
        .fChangePageOne = True
        .fCancelWiz = False
    End With
    pub_fFinished = False
End Sub
Public Function pub_FInitSelObj() As Boolean
    If Not selobj_FInitAsSubform(selobj_sop) Then
        wlib_IMsgBox 32, "", vbCritical
        pub_FInitSelObj = False
    Else
        ReDim pub_pwi.rgpubobj(selobj_rgcobj(7) - 1)
        pub_FInitSelObj = True
    End If
End Function
Sub pub_GetPublishSpec()
    Dim i As Integer
    Dim stTest As String
    Dim stSpecPropName As String
    Dim fSelected As Boolean
    stSpecPropName = wlib_StFromIds(33) & pub_pwi.stSpecName
    With wlib_dbCur
        For i = 0 To selobj_rgcobj(7) - 1
            stTest = ""
            On Error Resume Next
            stTest = (.Containers(wlib_StDocCntOfIDocType(selobj_rgobj(i).iType)).Documents(selobj_rgobj(i).stName).Properties(stSpecPropName))
            fSelected = ((Err.Number = 0) And (Len(stTest) > 0))
            selobj_rgobj(i).fSelected = fSelected
            selobj_sop.fChangedSelObj = fSelected Or selobj_sop.fChangedSelObj
            If fSelected Then
                pub_pwi.rgpubobj(i).stFilename = wlib_StGetToken(stTest, ";")
            End If
            On Error GoTo 0
        Next i
        stTest = .Properties(stSpecPropName)
     End With
    With pub_pwi
        .stHomePageName = wlib_StGetToken(stTest, ";")
        .fCreateHomePage = ((Len(.stHomePageName) > 0))
        .stWebPostFN = wlib_StGetToken(stTest, ";")
        .fUseWebPost = ((Len(.stWebPostFN) > 0))
        .iWebPost = (Not .fUseWebPost) + 2
        .stDSN = wlib_StGetToken(stTest, ";")
        .stUsername = wlib_StGetToken(stTest, ";")
        .stPassword = wlib_StGetToken(stTest, ";")
        .stDirectory = wlib_StGetToken(stTest, ";")
        .stDefaultTemplate = wlib_StGetToken(stTest, ";")
        .iOutputFormat = wlib_StGetToken(stTest, ";")
        .stServerURL = wlib_StGetToken(stTest, ";")
        .stSessionTimeout = wlib_StGetToken(stTest, ";")
    End With
    pub_ApplyTemplate
End Sub
Public Function pub_StartWiz()
On Error GoTo pub_StartWiz_Err
    Dim i As Integer
    Dim stExt As String
    Dim stOutput As String
    Dim stDSN As String
    Dim stUser As String
    Dim stPwd As String
    Dim stServer As String
    Dim stTimeout As String
    Dim stTemplate As String
    Dim stTemplateToUse As String
    Dim iOutputFormatToUse As Integer
    Dim stDir As String
    Dim stHtml As String
    Dim dte As Date
    stDSN = Application.GetOption("Data Source Name")
    stUser = Application.GetOption("User Name")
    stPwd = Application.GetOption("Password")
    stServer = Application.GetOption("Active Server Pages URL")
    stTimeout = Application.GetOption("Active Server Pages Session Timeout")
    pub_ClearWizInfo
    wlib_OpenCurrentDB
    Set pub_dbCode = CodeDb
    Set pub_rsStrings = pub_dbCode.OpenRecordset("pub_tblStrings", dbOpenTable)
    pub_rsStrings.Index = "ID"
    wlib_StartAddIn 1, pub_rsStrings, "String"
    pub_SetGlobals
    DoCmd.OpenForm "pub_frmMain", , , , , acDialog
    If pub_fFinished Then
        Application.SetOption "Data Source Name", pub_pwi.stDSN
        Application.SetOption "User Name", pub_pwi.stUsername
        Application.SetOption "Password", pub_pwi.stPassword
        Application.SetOption "Active Server Pages URL", pub_pwi.stServerURL
        Application.SetOption "Active Server Pages Session Timeout", pub_pwi.stSessionTimeout
        stHtml = wlib_StFromIds(38)
        For i = 0 To selobj_rgcobj(7) - 1
            If selobj_rgobj(i).fSelected Then
                pub_pwi.rgpubobj(i).stFilename = pub_StDefaultOutputName(i)
            End If
        Next i
        i = 0
        If Len(pub_pwi.stDirectory) > 0 Then
            stDir = pub_pwi.stDirectory & "\"
        Else
            stDir = ""
        End If
        Do While i < selobj_rgcobj(7)
            With pub_pwi.rgpubobj(i)
                If selobj_rgobj(i).fSelected Then
                    If selobj_rgobj(i).iType = acReport Then
                        iOutputFormatToUse = 1
                    Else
                        iOutputFormatToUse = IIf((.iDocType = -1), pub_pwi.iOutputFormat, .iDocType)
                    End If
                    stOutput = pub_rgpdt(iOutputFormatToUse).stOutputType
                    stExt = pub_StExtFromFormat(stOutput)
                    If (.stHTMLTemplate = wlib_StFromIds(43)) Then
                        stTemplateToUse = pub_pwi.stDefaultTemplate
                    Else
                        stTemplateToUse = .stHTMLTemplate
                    End If
                    If Len(Dir$(stTemplateToUse)) = 0 Then
                        stTemplateToUse = ""
                    End If
                    If wlib_FileExists(stDir & .stFilename & stHtml) Then
                        dte = FileDateTime(stDir & .stFilename & stHtml)
                    Else
                        dte = 0
                    End If
                    DoCmd.OutputTo selobj_rgobj(i).iType, selobj_rgobj(i).stName, stOutput, stDir & .stFilename & stExt, False, stTemplateToUse
                    If wlib_FileExists(stDir & .stFilename & stHtml) Then
                        .fPointToHTM = (dte <> FileDateTime(stDir & .stFilename & stHtml))
                    End If
                    dte = 0
                End If
            End With
            i = i + 1
        Loop
        If (pub_pwi.fSaveSpec) Then
            pub_SetPublishSpec
        End If
        If (pub_pwi.fCreateHomePage) Then
            pub_CreateHomePage
            stTemplate = stDir & pub_pwi.stHomePageName
            If Right$(stTemplate, Len(stHtml)) <> stHtml Then
                stTemplate = stTemplate + stHtml
            End If
            DoCmd.OutputTo acTable, wlib_StFromIds(19), acFormatHTML, stTemplate, False, pub_pwi.stDefaultTemplate
        End If
        Select Case pub_pwi.iWebPost
            Case 2
                pub_CallWebPostWiz &H2
            Case 3
                pub_CallWebPostWiz &H4
            Case Else
        End Select
    End If
pub_StartWiz_Exit:
    On Error Resume Next
    wlib_EndAddIn
    pub_ClearGlobals
    If Len(stDSN & stUser & stPwd) > 0 Then
        Application.SetOption "Data Source Name", stDSN
        Application.SetOption "User Name", stUser
        Application.SetOption "Password", stPwd
    End If
    If Len(stServer & stTimeout) > 0 Then
        Application.SetOption "Active Server Pages URL", stServer
        Application.SetOption "Active Server Pages Session Timeout", stTimeout
    End If
    Exit Function
pub_StartWiz_Err:
    wlib_HandleError Err.Number, Err.Description
    Resume pub_StartWiz_Exit
End Function
Private Sub pub_SetGlobals()
    With selobj_sop
        .fInitSelected = False
        .stDlgCaption = wlib_StFromIds(26)
        .stObjTypeLabel = ""
        .stObjLabel = """"
        .stOptionsFxn = ""
        .stObjTypeRowSrc = wlib_StFromIds(27)
        .iObjTypeDefault = 0
        .stOtherCategory = ""
        .cobjOther = 0
        .lFlags = 1 Or 2 Or 4 Or 8
        .lHelpContextID = 0
        .stHelpFile = ""
    End With
    pub_cpdt = 3
    ReDim pub_rgpdt(1 To 3)
    pub_rgpdt(1).id = 1
    pub_rgpdt(1).stName = wlib_StFromIds(28)
    pub_rgpdt(1).stOutputType = acFormatHTML
    pub_rgpdt(2).id = 2
    pub_rgpdt(2).stName = wlib_StFromIds(29)
    pub_rgpdt(2).stOutputType = acFormatIIS
    pub_rgpdt(3).id = 3
    pub_rgpdt(3).stName = wlib_StFromIds(47)
    pub_rgpdt(3).stOutputType = acFormatASP
    ReDim pub_pwi.pfn.stFriendlyName(1)
    pub_FillSpecName pub_pwi.rgstspec
    pub_WebPostListSites
End Sub
Sub pub_GetApplicableDocType(rgbitf() As Boolean, ByRef rgpdt() As PUB_DOCTYPE, ByRef cpdt As Integer)
    If (rgbitf(2) Or rgbitf(3)) Then
        ReDim rgpdt(0 To 0)
        cpdt = 1
        rgpdt(0) = pub_rgpdt(0)
    Else
        ReDim rgpdt(0 To 1)
        cpdt = 2
        rgpdt(0) = pub_rgpdt(0)
        rgpdt(1) = pub_rgpdt(1)
    End If
End Sub
Function pub_StDefaultOutputName(iIndex As Integer) As String
    Dim stOut As String
    Dim i As Integer
    Dim cTemp As Integer
    Dim stObjName As String
    Dim stUnderscore As String
    Dim j As Integer
    Dim ch As String
    stUnderscore = wlib_StFromIds(45)
    If (Len(pub_pwi.rgpubobj(iIndex).stFilename) = 0) Then
        stObjName = pub_BadCharsToUnderScore(selobj_rgobj(iIndex).stName)
        cTemp = 1
    Else
        For j = Len(pub_pwi.rgpubobj(iIndex).stFilename) To 1 Step -1
            ch = Mid$(pub_pwi.rgpubobj(iIndex).stFilename, j, 1)
            If Not IsNumeric(ch) Then
                stObjName = Left$(pub_pwi.rgpubobj(iIndex).stFilename, j - 1)
                cTemp = CInt(Mid$(pub_pwi.rgpubobj(iIndex).stFilename, j + 1))
                Exit For
            End If
        Next j
        If Len(stObjName) = 0 Then
            stObjName = pub_BadCharsToUnderScore(selobj_rgobj(iIndex).stName)
            cTemp = 1
        End If
    End If
    stOut = stObjName & stUnderscore & CStr(cTemp)
    For i = LBound(selobj_rgobj()) To iIndex - 1
        If selobj_rgobj(i).fSelected Then
            If pub_pwi.rgpubobj(i).stFilename = stOut Then
                cTemp = cTemp + 1
                stOut = stObjName & stUnderscore & CStr(cTemp)
            End If
        End If
    Next i
    pub_StDefaultOutputName = stOut
End Function
Sub pub_WebPostListSites()
    Dim errReturn As Long
    Dim cSites As Long
    errReturn = wlib_ErrWpListSites(cSites, pub_pwi.pfn.stFriendlyName())
    If errReturn <> 0 Then
        pub_pwi.pfn.cNames = -1
    Else
        pub_pwi.pfn.cNames = cSites
    End If
End Sub
Function pub_BadCharsToUnderScore(stIn As String) As String
    Dim stBad As String
    Dim stTemp As String
    Dim i As Integer
    Dim ch As String
    Dim stOut As String
    stOut = stIn
    stBad = wlib_StFromIds(36)
    For i = 1 To Len(stBad)
        ch = Mid$(stBad, i, 1)
        stTemp = ""
        Do Until stOut = stTemp
            stTemp = stOut
            wlib_ReplaceStr stOut, ch, "_"
        Loop
    Next i
    pub_BadCharsToUnderScore = stOut
End Function
'---
Attribute VB_Name = "mlbl_modUtils"
Option Compare Database
Option Explicit
Type MLBL_INFO
    StRptName As String
    fBrowse As Integer
    iLabelId As Integer
    fUserSizes As Integer
    fMetric As Integer
    fDotMatrix As Integer
    fPortrait As Integer
    cItemsAcross As Integer
    stFontName As String
    iFontSize As Integer
    iFontWeight As Integer
    lFontColor As Long
    fItalic As Integer
    fUnderline As Integer
    dytextbox As Integer
    dxGrid As Integer
    dyGrid As Integer
    fUsrPrefsChng As Integer
    fOpenGroupBox As Integer
    ptLabelSize As WLIB_POINT
    dxdySpace As WLIB_POINT
    xLeftMargin As Integer
    xRightMargin As Integer
    yTopMargin As Integer
    ptOrigin As WLIB_POINT
End Type
Type MLBL_LINECOMP
    fIsField As Integer
    stText As String
End Type
Type MLBL_LABELLINE
    cComps As Integer
    rgmlblc(10) As MLBL_LINECOMP
    fEmptyBtn As Integer
End Type
Global mlbl_cLines As Long
Global mlbl_mlbll(0 To 8) As MLBL_LABELLINE
Global mlbl_rgfi() As FPK_FLDINFO
Global mlbl_cfi As Integer
Global mlbl_rgimlbdsSort() As Integer
Global mlbl_cmlbdsSort As Integer
Global mlbl_rsUserSizes As Recordset
Global mlbl_rsPrefs As Recordset
Global mlbl_rsMsg As Recordset
Global mlbl_dbCode As Database
Global mlbl_stRecSrc As String
Global mlbl_tRecSrc As Integer
Global mlbl_mlbi As MLBL_INFO
Global mlb_fpkd As FPK_DATA
Global mlb_fEditSize As Integer
Global mlb_iLabelId As Integer
Global mlb_fCustMetric As Boolean
Global mlb_fCustContinuous As Boolean
Global mlbl_fCancelEnterSize As Boolean
Global mlbl_fWizCancel As Boolean
Global mlbl_fLabelEmpty As Boolean
Global mlbl_fEnglish As Boolean
Global mlbl_fShowCard As Boolean
Function mlbl_CustomLabelSize() As Integer
On Error GoTo mlbl_CustomLabelSize_Err
    If Not FOpenTables() Then GoTo mlbl_CustomLabelSize_Exit
    wlib_StartAddIn 235, mlbl_rsMsg, "Message"
    DoCmd.OpenForm "mlbl_frmNewLabelSize", acNormal, , , , acDialog
mlbl_CustomLabelSize_Exit:
On Error Resume Next
    wlib_EndAddIn
    mlbl_CloseTables
    Exit Function
mlbl_CustomLabelSize_Err:
    wlib_HandleError Err.Number, Err.Description
    Resume mlbl_CustomLabelSize_Exit
End Function
Function mlbl_Entry(stSource As String) As Integer
On Error GoTo mlbl_Entry_Err
    Dim fAIStarted As Boolean
    Dim fOpenCurrentDB As Boolean
    If Not FOpenTables() Then GoTo mlbl_Entry_Exit
    wlib_StartAddIn 204, mlbl_rsMsg, "Message"
    fAIStarted = True
    wlib_OpenCurrentDB
    fOpenCurrentDB = True
    mlbl_stRecSrc = stSource
    DoCmd.OpenForm "mlbl_frmMain", , , , , acDialog
    mlbl_Entry = True
mlbl_Entry_Exit:
On Error Resume Next
    If fOpenCurrentDB Then wlib_CloseCurrentDB
    If fAIStarted Then wlib_EndAddIn
    mlbl_CloseTables
    Exit Function
mlbl_Entry_Err:
    If Err <> 2501 Then
        wlib_HandleError Err.Number, Err.Description
    End If
    Resume mlbl_Entry_Exit
End Function
Sub mlbl_CloseTables()
On Error Resume Next
    mlbl_rsMsg.close
    mlbl_rsUserSizes.close
    mlbl_rsPrefs.close
    mlbl_dbCode.close
End Sub
Private Function FOpenTables() As Integer
On Error GoTo FOpenTables_Err
    Set mlbl_dbCode = CodeDb()
    Set mlbl_rsMsg = mlbl_dbCode.OpenRecordset("mlbl_tblStrings", dbOpenTable)
    mlbl_rsMsg.Index = "PrimaryKey"
    Set mlbl_rsPrefs = mlbl_dbCode.OpenRecordset("mlbl_tblMailingLabelPreferences", dbOpenDynaset)
    Set mlbl_rsUserSizes = mlbl_dbCode.OpenRecordset("mlbl_tblUserSizes", dbOpenTable)
    mlbl_rsUserSizes.Index = "PrimaryKey"
    FOpenTables = True
FOpenTables_Exit:
    Exit Function
FOpenTables_Err:
    MsgBox Error$
    FOpenTables = False
    mlbl_CloseTables
    Resume FOpenTables_Exit
End Function
Function mlbl_FReadLabelSize(ByVal id As Long, fUserSizes As Integer) As Integer
On Error GoTo mlbl_FReadLabelSizes_Err
    Dim rsSizes As Recordset
    If id = 0 Then
        id = mlbl_mlbi.iLabelId
    End If
    If Not fUserSizes Then
        Set rsSizes = mlbl_dbCode.OpenRecordset("mlbl_tblLabelSizes", dbOpenTable)
    Else
        Set rsSizes = mlbl_dbCode.OpenRecordset("mlbl_tblUserSizes", dbOpenTable)
    End If
    rsSizes.Index = "PrimaryKey"
    rsSizes.Seek "=", id
    If Not rsSizes.NoMatch Then
        mlbl_mlbi.ptLabelSize.x = rsSizes!dxLabel
        mlbl_mlbi.ptLabelSize.y = rsSizes!dyLabel
        mlbl_mlbi.dxdySpace.x = rsSizes!dxSpace
        mlbl_mlbi.dxdySpace.y = rsSizes!dySpace
        mlbl_mlbi.xLeftMargin = rsSizes!xLeft
        mlbl_mlbi.xRightMargin = rsSizes!xRight
        mlbl_mlbi.yTopMargin = rsSizes!yTop
        mlbl_mlbi.ptOrigin.x = rsSizes!xOrg
        mlbl_mlbi.ptOrigin.y = rsSizes!yOrg
        mlbl_mlbi.cItemsAcross = rsSizes!itemsacross
        mlbl_mlbi.fPortrait = rsSizes!fPortrait
        mlbl_FReadLabelSize = True
    End If
mlbl_FReadLabelSize_Exit:
On Error Resume Next
    rsSizes.close
    Exit Function
mlbl_FReadLabelSizes_Err:
    wlib_HandleError Err.Number, Err.Description
    Resume mlbl_FReadLabelSize_Exit
End Function
 Function mlbl_IFitToGrid(ByVal Value As Integer, ByVal grid As Integer) As Integer
    If (Value / grid - Value \ grid) < 0.01 Then
        mlbl_IFitToGrid = CInt((Value \ grid) * grid)
    Else
        mlbl_IFitToGrid = CInt((Value \ grid + 1) * grid)
    End If
End Function
'---
Attribute VB_Name = "fpk_modUI"
Option Compare Database
Option Explicit
Type FPK_FLDINFO
    stName As String
    stRecSrc As String
    iOrder As Integer
    iType As Integer
    lAttributes As Long
    lSize As Long
    stSrcTbl As String
    stSrcFld As String
    fShowRsName As Integer
    lClientInfo As Long
    stForeignName As String
    stForeignSrcTbl As String
    stForeignSrcFld As String
    stFormat As String
    iDecimalPlaces  As Integer
    stCaption As String
    iDisplayControl As Integer
End Type
Type FPK_LSTRECSRCINFO
    rgdbobj() As WLIB_DBOBJ
    rgiTbl() As Integer
    rgiQry() As Integer
    cdbobj As Integer
    cTbls As Integer
    cQrys As Integer
End Type
Type FPK_PROPS
    fShowRsList As Integer
    fShowSelList As Integer
    stRecSrcLbl As String
    stAvailFieldsLbl As String
    stSelFieldsLbl As String
    rgfiOmit() As FPK_FLDINFO
    cfiOmit As Integer
    lrgbitDatatypeOmit As Long
    cfiSelMax As Integer
    lFlags As Long
End Type
Type FPK_DATA
    dbobj As WLIB_DBOBJ
    fi As FPK_FLDINFO
    rgfiSel() As FPK_FLDINFO
    cfiSel As Integer
    ifiSelMax As Integer
End Type
Type FPK_GLOBALS
    fpkp As FPK_PROPS
    lrsi As FPK_LSTRECSRCINFO
    dbobj As WLIB_DBOBJ
    fi As FPK_FLDINFO
    rgfiAvail() As FPK_FLDINFO
    cfiAvail As Integer
    ifiAvailMax As Integer
    rgfiSel() As FPK_FLDINFO
    cfiSel As Integer
    ifiSelMax As Integer
End Type
Global fpk_glob As FPK_GLOBALS
Type FPK_TQBDATA
    dbobj As WLIB_DBOBJ
    iTQBOption As Integer
End Type
Global fpk_tqbglob As FPK_TQBDATA
Global fpk_rscol As New Collection
Function fpk_ErrInit()
End Function
Function fpk_ErrUninit()
    fpk_glob.cfiAvail = 0
    fpk_glob.ifiAvailMax = 0
    Erase fpk_glob.rgfiAvail
    fpk_glob.cfiAvail = 0
    fpk_glob.ifiSelMax = 0
    Erase fpk_glob.rgfiSel
    fpk_glob.cfiSel = 0
    fpk_glob.lrsi.cdbobj = 0
    fpk_glob.lrsi.cTbls = 0
    fpk_glob.lrsi.cQrys = 0
    Erase fpk_glob.lrsi.rgdbobj
End Function
Function fpk_FInitLrsi(lRsTypeOmit As Long, rgrsiOmit() As WLIB_DBOBJ, cRsiOmit As Integer, fSortByName As Integer) As Integer
    fpk_FInitLrsi = False
    If (FGetRecSrcs(lRsTypeOmit, rgrsiOmit(), cRsiOmit, fSortByName, fpk_glob.lrsi)) Then
        If (fpk_glob.lrsi.cTbls + fpk_glob.lrsi.cQrys > 0) Then
            fpk_FInitLrsi = True
        End If
    End If
End Function
Function fpk_FGetFldsOfRecSrc(rsi As WLIB_DBOBJ, rgfiOmit() As FPK_FLDINFO, cfiOmit As Integer, lrgbitDatatypeOmit As Long, rgfi() As FPK_FLDINFO, cFi As Integer, ifiMax As Integer) As Integer
On Error GoTo fpk_FGetFldsOfRecSrc_Err
    Dim iFld As Integer
    Dim td As TableDef
    Dim qd As QueryDef
    Dim fHideHourglass As Integer
    If (Not GetOption("Show System Objects")) Then lrgbitDatatypeOmit = lrgbitDatatypeOmit Or &H10000000
    wlib_OpenCurrentDB
    cFi = 0
    Select Case rsi.iObjType
        Case acTable
            Set td = wlib_dbCur.TableDefs(rsi.stName)
            If (td.Fields.Count > 10) Then
                wlib_Hourglass True
                fHideHourglass = True
            End If
            For iFld = 0 To td.Fields.Count - 1
                AddFieldIfMatch td.Fields(iFld), rsi.stName, iFld, rgfiOmit(), cfiOmit, lrgbitDatatypeOmit, rgfi(), cFi, ifiMax
            Next iFld
        Case acQuery
            Set qd = wlib_dbCur.QueryDefs(rsi.stName)
            wlib_Hourglass True
            fHideHourglass = True
            For iFld = 0 To qd.Fields.Count - 1
                AddFieldIfMatch qd.Fields(iFld), rsi.stName, iFld, rgfiOmit(), cfiOmit, lrgbitDatatypeOmit, rgfi(), cFi, ifiMax
            Next iFld
        Case Else
            Set qd = wlib_dbCur.CreateQueryDef("")
            qd.SQL = rsi.stName
            wlib_Hourglass True
            fHideHourglass = True
            For iFld = 0 To qd.Fields.Count - 1
                AddFieldIfMatch qd.Fields(iFld), rsi.stName, iFld, rgfiOmit(), cfiOmit, lrgbitDatatypeOmit, rgfi(), cFi, ifiMax
            Next iFld
            qd.close
    End Select
    fpk_FGetFldsOfRecSrc = True
fpk_FGetFldsOfRecSrc_Exit:
On Error Resume Next
    If (fHideHourglass) Then wlib_Hourglass False
    wlib_CloseCurrentDB
    Exit Function
fpk_FGetFldsOfRecSrc_Err:
    cFi = 0
    fpk_FGetFldsOfRecSrc = False
    Resume fpk_FGetFldsOfRecSrc_Exit
End Function
Sub fpk_GetData(fpkd As FPK_DATA)
    Dim iFi As Integer
    fpkd.dbobj = fpk_glob.dbobj
    fpkd.fi = fpk_glob.fi
    fpkd.cfiSel = fpk_glob.cfiSel
    fpkd.ifiSelMax = fpk_glob.ifiSelMax
    If (fpk_glob.ifiSelMax > 0) Then
        ReDim Preserve fpkd.rgfiSel(0 To fpk_glob.ifiSelMax - 1)
    End If
    For iFi = 0 To fpk_glob.cfiSel - 1
        fpkd.rgfiSel(iFi) = fpk_glob.rgfiSel(iFi)
    Next iFi
End Sub
Sub fpk_SetProps(fpkp As FPK_PROPS)
    fpk_glob.fpkp = fpkp
End Sub
Sub fpk_SetData(fpkd As FPK_DATA)
    Dim i As Integer
    Dim fRecSrcValidated As Integer
    If ((fpkd.dbobj.iObjType >= acForm And fpkd.dbobj.iObjType <= acModule) Or fpkd.dbobj.stName = "") Then
        fpkd.dbobj.stName = ""
        fpkd.dbobj.iObjType = 0
    End If
    fpk_glob.dbobj = fpkd.dbobj
    fpk_glob.fi = fpkd.fi
    fpk_glob.cfiSel = fpkd.cfiSel
    fpk_glob.ifiSelMax = fpkd.ifiSelMax
    If (fpkd.ifiSelMax > 0) Then
        ReDim Preserve fpk_glob.rgfiSel(0 To fpkd.ifiSelMax - 1)
    End If
    For i = 0 To fpkd.cfiSel - 1
        fpk_glob.rgfiSel(i) = fpkd.rgfiSel(i)
    Next i
    If (fpk_glob.fpkp.fShowRsList) Then
        fRecSrcValidated = False
        If (fpk_glob.dbobj.stName <> "" And _
            (fpkd.dbobj.iObjType = acTable Or fpkd.dbobj.iObjType = acQuery)) Then
            For i = 0 To fpk_glob.lrsi.cTbls + fpk_glob.lrsi.cQrys - 1
                If (fpk_glob.lrsi.rgdbobj(i).stName = fpk_glob.dbobj.stName) Then
                    If (fpk_glob.lrsi.rgdbobj(i).iObjType = fpk_glob.dbobj.iObjType) Then
                        fRecSrcValidated = True
                        Exit For
                    End If
                End If
            Next i
        End If
    Else
        fRecSrcValidated = True
    End If
    If (Not fRecSrcValidated) Then
        fpk_glob.dbobj = fpk_glob.lrsi.rgdbobj(0)
    End If
    If (Not fpk_FGetFldsOfRecSrc(fpk_glob.dbobj, fpk_glob.rgfiSel(), fpk_glob.cfiSel, fpk_glob.fpkp.lrgbitDatatypeOmit, fpk_glob.rgfiAvail(), fpk_glob.cfiAvail, fpk_glob.ifiAvailMax)) Then
        Error 30000
    End If
End Sub
Sub fpk_GetTQBData(tqbd As FPK_TQBDATA)
    tqbd = fpk_tqbglob
End Sub
Sub fpk_SetTQBData(tqbd As FPK_TQBDATA)
    fpk_tqbglob = tqbd
End Sub
Sub fpk_RemoveFiOfRecSrc(fpkd As FPK_DATA, stRecSrc As String)
    Dim iFi As Integer
    Dim ifiMove As Integer
    iFi = 0
    While (iFi < fpkd.cfiSel)
        If (fpkd.rgfiSel(iFi).stRecSrc = stRecSrc) Then
            For ifiMove = iFi + 1 To fpkd.cfiSel - 1
                fpkd.rgfiSel(ifiMove - 1) = fpkd.rgfiSel(ifiMove)
            Next ifiMove
            fpkd.cfiSel = fpkd.cfiSel - 1
        Else
            iFi = iFi + 1
        End If
    Wend
End Sub
Private Sub AddFieldIfMatch(fld As Field, stRecSrc As String, iOrder As Integer, rgfiOmit() As FPK_FLDINFO, cfiOmit As Integer, lrgbitDatatypeOmit As Long, rgfi() As FPK_FLDINFO, cFi As Integer, ifiMax As Integer)
    Dim fi As FPK_FLDINFO
    Dim iFi As Integer
    Dim bitType As Long
    For iFi = 0 To cfiOmit - 1
        If (stRecSrc = rgfiOmit(iFi).stRecSrc) Then
            If (fld.SourceTable = rgfiOmit(iFi).stSrcTbl) Then
                If (fld.Name = rgfiOmit(iFi).stName) Then
                    Exit Sub
                End If
            End If
        End If
    Next iFi
    For iFi = 0 To fpk_glob.fpkp.cfiOmit - 1
        If (stRecSrc = fpk_glob.fpkp.rgfiOmit(iFi).stRecSrc) Then
            If (fld.SourceTable = fpk_glob.fpkp.rgfiOmit(iFi).stSrcTbl) Then
                If (fld.Name = fpk_glob.fpkp.rgfiOmit(iFi).stName) Then
                    Exit Sub
                End If
            End If
        End If
    Next iFi
    bitType = 2 ^ fld.Type
    If ((lrgbitDatatypeOmit And bitType) <> 0) Then
        If (fld.Type = dbMemo) And (fld.Attributes And dbHyperlinkField) And ((lrgbitDatatypeOmit And &H100000) <> 0) Then
        Else
            Exit Sub
        End If
    End If
    If ((fld.Attributes And dbSystemField) <> 0) Then
        If (lrgbitDatatypeOmit And &H10000000) Then
            Exit Sub
        End If
    End If
    fi.stName = fld.Name
    fi.iOrder = iOrder
    fi.stRecSrc = stRecSrc
    fi.iType = fld.Type
    fi.lAttributes = fld.Attributes
    fi.lSize = fld.Size
    fi.stSrcTbl = fld.SourceTable
    fi.stSrcFld = fld.SourceField
    fi.stFormat = ""
    fi.iDecimalPlaces = 255
    fi.stCaption = ""
    If (fi.iType = dbLongBinary) Then
        fi.iDisplayControl = acBoundObjectFrame
    Else
        fi.iDisplayControl = acTextBox
    End If
    If ((fpk_glob.fpkp.lFlags And &H1&) = 0) Then
On Error Resume Next
        fi.stFormat = fld.Properties("Format")
        fi.iDecimalPlaces = fld.Properties("DecimalPlaces")
        fi.stCaption = fld.Properties("Caption")
        fi.iDisplayControl = fld.Properties("DisplayControl")
On Error GoTo 0
    End If
    cFi = cFi + 1
    If (cFi >= ifiMax) Then
        ReDim Preserve rgfi(0 To ifiMax + 5)
        ifiMax = ifiMax + 5
    End If
    rgfi(cFi - 1) = fi
End Sub
Public Function FPK_FGetJPMProps(rgfi() As FPK_FLDINFO) As Boolean
On Error Resume Next
    Dim fld As Field
    Dim i As Integer
    Dim j As Integer
    For i = 0 To UBound(rgfi())
        On Error Resume Next
        fpk_rscol.Add wlib_dbCur.TableDefs(rgfi(i).stRecSrc), rgfi(i).stRecSrc
        If Err.Number = 3265 Then
            On Error Resume Next
            fpk_rscol.Add wlib_dbCur.QueryDefs(rgfi(i).stRecSrc), rgfi(i).stRecSrc
            If Err.Number = 3265 Then
                On Error Resume Next
                fpk_rscol.Add wlib_dbCur.CreateQueryDef("", rgfi(i).stRecSrc)
                FPK_FGetJPMProps = False
                For j = 1 To fpk_rscol.Count
                    fpk_rscol.Remove j
                Next j
                Exit Function
            End If
        End If
        On Error Resume Next
        Set fld = fpk_rscol(rgfi(i).stRecSrc).Fields(rgfi(i).stName)
        On Error Resume Next
        rgfi(i).stFormat = fld.Properties("Format")
        rgfi(i).iDecimalPlaces = fld.Properties("DecimalPlaces")
        rgfi(i).stCaption = fld.Properties("Caption")
        rgfi(i).iDisplayControl = fld.Properties("DisplayControl")
        On Error GoTo 0
    Next i
    FPK_FGetJPMProps = True
    For j = 1 To fpk_rscol.Count
        fpk_rscol.Remove j
    Next j
End Function
Private Function FGetRecSrcs(lRsTypeOmit As Long, rgDbObjOmit() As WLIB_DBOBJ, cdbobjOmit As Integer, fSortByName As Integer, lrsi As FPK_LSTRECSRCINFO)
On Error GoTo FGetRecSrcs_Err
    Dim cObj As Integer
    Dim lErr As Long
    Dim iTbl As Integer
    Dim iQry As Integer
    Dim idbobj As Integer
    Dim idbobjOmit As Integer
    lrsi.cdbobj = 0
    lrsi.cTbls = 0
    lrsi.cQrys = 0
    If (Not GetOption("Show System Objects")) Then lRsTypeOmit = lRsTypeOmit Or &H10000000
    If (Not GetOption("Show Hidden Objects")) Then lRsTypeOmit = lRsTypeOmit Or &H20000000
    wlib_OpenCurrentDB
    cObj = wlib_dbCur.TableDefs.Count + wlib_dbCur.QueryDefs.Count
    If (cObj = 0) Then GoTo FGetRecSrcs_Exit
    ReDim lrsi.rgdbobj(0 To wlib_dbCur.TableDefs.Count + wlib_dbCur.QueryDefs.Count - 1)
    lErr = wlib_ErrGetDbobjList(Workspaces(0), wlib_dbCur, acTable, Not lRsTypeOmit, lrsi.rgdbobj, 0, lrsi.cTbls)
    If (lErr <> 0) Then
        wlib_CloseCurrentDB
        Error Err
    End If
    lErr = wlib_ErrGetDbobjList(Workspaces(0), wlib_dbCur, acQuery, Not lRsTypeOmit, lrsi.rgdbobj, lrsi.cTbls, lrsi.cQrys)
    If (lErr <> 0) Then
        wlib_CloseCurrentDB
        Error Err
    End If
    lrsi.cdbobj = lrsi.cTbls + lrsi.cQrys
    For idbobjOmit = 0 To cdbobjOmit - 1
        For idbobj = 0 To lrsi.cdbobj - 1
            If (lrsi.rgdbobj(idbobj).iObjType = rgDbObjOmit(idbobjOmit).iObjType) Then
                If (lrsi.rgdbobj(idbobj).stName = rgDbObjOmit(idbobjOmit).stName) Then
                    If (idbobj < lrsi.cdbobj - 1) Then
                        lrsi.rgdbobj(idbobj) = lrsi.rgdbobj(lrsi.cdbobj - 1)
                    End If
                    lrsi.cdbobj = lrsi.cdbobj - 1
                    If (rgDbObjOmit(idbobjOmit).iObjType = acTable) Then
                        lrsi.cTbls = lrsi.cTbls - 1
                    Else
                        lrsi.cQrys = lrsi.cQrys - 1
                    End If
                    GoTo NextIdbobjOmit
                End If
            End If
        Next idbobj
NextIdbobjOmit:
    Next idbobjOmit
    If (lrsi.cdbobj > 0) Then
        ReDim Preserve lrsi.rgdbobj(0 To lrsi.cdbobj - 1)
        lErr = wlib_ErrSortDbobjArray(lrsi.rgdbobj, fSortByName)
        If (lErr <> 0) Then Error lErr
    Else
        Erase lrsi.rgdbobj
    End If
    If (lrsi.cTbls > 0) Then ReDim Preserve lrsi.rgiTbl(0 To lrsi.cTbls - 1)
    If (lrsi.cQrys > 0) Then ReDim Preserve lrsi.rgiQry(0 To lrsi.cQrys - 1)
    iTbl = 0
    iQry = 0
    For idbobj = 0 To lrsi.cdbobj - 1
        If (lrsi.rgdbobj(idbobj).iObjType = acTable) Then
            lrsi.rgiTbl(iTbl) = idbobj
            iTbl = iTbl + 1
        Else
            lrsi.rgiQry(iQry) = idbobj
            iQry = iQry + 1
        End If
    Next idbobj
    FGetRecSrcs = True
FGetRecSrcs_Exit:
On Error Resume Next
    wlib_CloseCurrentDB
    Exit Function
FGetRecSrcs_Err:
    wlib_HandleError Err, Error$
    FGetRecSrcs = False
    Resume FGetRecSrcs_Exit
End Function

'---
Attribute VB_Name = "pub_modUtils"
Option Compare Database
Option Explicit
Function pub_FLiveObjectsInList() As Boolean
    Dim i As Integer
    Dim iFormat As Integer
    pub_ApplyOutputFormat
    For i = 0 To selobj_rgcobj(7) - 1
        If selobj_rgobj(i).fSelected Then
            iFormat = pub_pwi.rgpubobj(i).iDocType
            If ((iFormat > pub_rgpdt(1).id) Or ((iFormat = -1) And (pub_pwi.iOutputFormat <> pub_rgpdt(1).id))) Then
                pub_FLiveObjectsInList = True
                Exit Function
            End If
        End If
    Next i
    pub_FLiveObjectsInList = False
End Function
Function pub_FNonReportsInList() As Boolean
    Dim i As Integer
    For i = 0 To selobj_rgcobj(7) - 1
        If selobj_rgobj(i).fSelected Then
            If selobj_rgobj(i).iType <> acReport Then
                pub_FNonReportsInList = True
                Exit Function
            End If
        End If
    Next i
End Function
Private Function pub_StSlashReplace(ByVal st As String)
    Dim strTemp As String
    Do Until strTemp = st
        strTemp = st
        wlib_ReplaceStr st, "\", "/"
    Loop
    pub_StSlashReplace = st
End Function
Function pub_stGetDocType(idx As Integer)
    Dim i As Integer
    For i = 1 To pub_cpdt
        If (pub_rgpdt(i).id = idx) Then
            pub_stGetDocType = pub_rgpdt(i).stName
            Exit Function
        End If
    Next i
    pub_stGetDocType = ""
End Function
Function pub_iGetDocType(st As String)
    Dim i As Integer
    For i = 1 To pub_cpdt
        If (pub_rgpdt(i).stName = st) Then
            pub_iGetDocType = pub_rgpdt(i).id
            Exit Function
        End If
    Next i
    pub_iGetDocType = -1
End Function
Function pub_FSetProperty(obj As Object, stProp As String, _
 lType As Long, vValue As Variant) As Long
On Error Resume Next
    Dim prp As Property
    obj.Properties(stProp) = vValue
    If Err.Number = 3270 Then
        On Error Resume Next
        Set prp = obj.CreateProperty(stProp, lType, vValue)
        obj.Properties.Append prp
    End If
    pub_FSetProperty = (Err = 0)
End Function
Sub pub_SetPublishSpec()
    Dim i As Integer
    Dim obj As Object
    Dim fReturn As Long
    Dim fSetDbProps As Boolean
    Dim wrk As Workspace
    Dim fFinished As Boolean
    Dim stSpecPropName As String
    Dim stPropValue As String
    Dim fSpecExists As Boolean
    Dim stSpec As String
    fSpecExists = False
    stSpec = pub_BadCharsToUnderScore(pub_pwi.stSpecName)
    For i = 1 To pub_pwi.cSpec
        If stSpec = pub_pwi.rgstspec(i).stName Then
            fSpecExists = True
            Exit For
        End If
    Next i
    fSetDbProps = False
    Set wrk = DBEngine.Workspaces(0)
    wrk.BeginTrans
    If Not (fSpecExists) Then
        If pub_pwi.cSpec > 0 Then
            stPropValue = wlib_dbCur.Properties("pubwiz_SpecName") & ";"
        End If
        stPropValue = stPropValue & stSpec
        fReturn = pub_FSetProperty(wlib_dbCur, "pubwiz_SpecName", dbText, stPropValue)
        If Not (fReturn) Then
            wlib_IMsgBox 35, "", vbExclamation
            GoTo pub_SetPublishSpec_Exit
        End If
    End If
    stSpecPropName = wlib_StFromIds(33) & pub_pwi.stSpecName
    With pub_pwi
        If Not (.fCreateHomePage) Then .stHomePageName = ""
        If Not (.fUseWebPost) Then .stWebPostFN = ""
        stPropValue = .stHomePageName & ";" & .stWebPostFN & ";" & .stDSN & ";" & .stUsername & ";"
        stPropValue = stPropValue & .stPassword & ";" & .stDirectory & ";" & .stDefaultTemplate & ";"
        stPropValue = stPropValue & .iOutputFormat & ";" & .stServerURL & ";" & .stSessionTimeout
        fReturn = pub_FSetProperty(wlib_dbCur, stSpecPropName, dbText, stPropValue)
        fSetDbProps = True
    End With
    With wlib_dbCur
        For i = 0 To selobj_rgcobj(7) - 1
            If selobj_rgobj(i).fSelected Then
                Set obj = .Containers(wlib_StDocCntOfIDocType(selobj_rgobj(i).iType)).Documents(selobj_rgobj(i).stName)
                stPropValue = pub_pwi.rgpubobj(i).stFilename & ";" & pub_pwi.rgpubobj(i).iDocType & ";" & pub_pwi.rgpubobj(i).stHTMLTemplate
                fReturn = pub_FSetProperty(obj, stSpecPropName, dbText, stPropValue)
                If Not (fReturn) Then
                    If (wlib_IMsgBox(25, selobj_rgobj(i).stName, vbCritical Or vbYesNo) = vbNo) Then
                        GoTo pub_SetPublishSpec_Exit
                    End If
                End If
                Set obj = Nothing
            Else
                Set obj = .Containers(wlib_StDocCntOfIDocType(selobj_rgobj(i).iType)).Documents(selobj_rgobj(i).stName)
                On Error Resume Next
                obj.Properties(stSpecPropName) = ""
                obj.Properties.delete stSpecPropName
                On Error GoTo 0
            End If
        Next i
    End With
    fFinished = True
pub_SetPublishSpec_Exit:
    If fFinished Then
        wrk.CommitTrans
    Else
        wrk.Rollback
    End If
End Sub
Public Function pub_FCanClose() As Boolean
    Dim i As Integer
    pub_FCanClose = False
    With pub_pwi
        If (pub_CSelected() = 0) Then
            wlib_IMsgBox 2, "", vbExclamation
            Exit Function
        ElseIf (.fSaveSpec And .stSpecName = "") Then
            wlib_IMsgBox 3, "", vbExclamation
            Exit Function
        End If
        pub_ApplyOutputFormat
        pub_ApplyTemplate
    End With
    pub_FCanClose = True
End Function
Function pub_CSelected() As Integer
    Dim i As Integer
    Dim c As Integer
    For i = 0 To selobj_rgcobj(7) - 1
        c = c - (selobj_rgobj(i).fSelected)
    Next i
    pub_CSelected = c
End Function
Public Function pub_StExtFromFormat(stFormat As String)
    Dim ich As Integer
    Dim ch As String
    Dim stExt As String
    ich = InStr(stFormat, ".")
    ch = Mid$(stFormat, ich, 1)
    Do
        stExt = stExt + ch
        ich = ich + 1
        ch = Mid$(stFormat, ich, 1)
    Loop Until ((ch = ";") Or (ch = ")"))
    pub_StExtFromFormat = stExt
End Function
Public Sub pub_CreateHomePage()
    Dim rs As Recordset
    Dim obj As Object
    Dim i As Integer
    Dim stExt As String
    Dim stOutput As String
    Dim iOutputFormatToUse As Integer
    Dim stHtml As String
    Dim stAsp As String
    Dim stIdc As String
    Dim stHtx As String
    stHtml = wlib_StFromIds(38)
    stAsp = wlib_StFromIds(48)
    stIdc = wlib_StFromIds(40)
    stHtx = wlib_StFromIds(39)
    Set rs = pub_dbCode.OpenRecordset("SELECT * FROM [" & wlib_StFromIds(19) & "]", dbOpenDynaset)
    On Error Resume Next
    rs.MoveFirst
    Do While Not rs.EOF
        rs.delete
        rs.MoveNext
    Loop
    On Error GoTo 0
    For i = 0 To selobj_rgcobj(7) - 1
        With pub_pwi.rgpubobj(i)
            If selobj_rgobj(i).fSelected Then
                If selobj_rgobj(i).iType = acReport Then
                    iOutputFormatToUse = 1
                Else
                    iOutputFormatToUse = IIf((.iDocType = -1), pub_pwi.iOutputFormat, .iDocType)
                End If
                Set obj = wlib_dbCur.Containers(wlib_StDocCntOfIDocType(selobj_rgobj(i).iType)).Documents(selobj_rgobj(i).stName)
                stOutput = pub_rgpdt(iOutputFormatToUse).stOutputType
                stExt = pub_StExtFromFormat(stOutput)
                Select Case stExt
                    Case stHtx
                        If .fPointToHTM Then
                            stExt = stHtml
                        Else
                            stExt = stIdc
                        End If
                    Case wlib_StFromIds(48)
                        If .fPointToHTM Then
                            stExt = stHtml
                        Else
                            stExt = stAsp
                        End If
                    Case Else
                End Select
                rs.AddNew
                    rs![Object] = selobj_rgobj(i).stName & "#" & .stFilename & stExt & "##"
                    rs![ObjectType] = wlib_StObjFromIObj(selobj_rgobj(i).iType)
                    rs![LastModified] = obj.LastUpdated
                    On Error Resume Next
                    rs![Description] = obj.Properties("Description")
                    On Error GoTo 0
                rs.Update
            End If
        End With
    Next i
End Sub
Sub pub_CallWebPostWiz(lFlags As Long)
    Dim wpo As Object
    Dim lHWnd As Long
    Dim stLocalPaths As String
    Dim stSiteName As String
    Dim stURL As String
    Dim cbSiteName As Long
    Dim cbURL As Long
    Dim lReturn As Long
    Set wpo = CreateObject("WPObj.Application")
    lHWnd = Application.hWndAccessApp
    stLocalPaths = pub_pwi.stDirectory
    stSiteName = pub_pwi.stWebPostFN
    stURL = vbNullString
    cbSiteName = Len(stSiteName)
    cbURL = Len(stURL)
    wpo.WpPostFile lHWnd, stLocalPaths, cbSiteName, stSiteName, cbURL, stURL, lFlags, lReturn
End Sub
Public Sub pub_ApplyTemplate()
    Dim i As Integer
    Dim stTest As String
    Dim stTemp As String
    Dim stSpecPropName As String
    With pub_pwi
        For i = 0 To selobj_rgcobj(7) - 1
            If selobj_rgobj(i).fSelected Then
                If .rgpubobj(i).stHTMLTemplate = "" Then
                    stSpecPropName = wlib_StFromIds(33) & pub_pwi.stSpecName
                    On Error Resume Next
                    stTest = wlib_dbCur.Containers(wlib_StDocCntOfIDocType(selobj_rgobj(i).iType)).Documents(selobj_rgobj(i).stName).Properties(stSpecPropName)
                    If ((.fUseOldSpec) And (Err = 0)) Then
                        stTemp = wlib_StGetToken(stTest, ";")
                        stTemp = wlib_StGetToken(stTest, ";")
                        .rgpubobj(i).stHTMLTemplate = stTest
                    Else
                        .rgpubobj(i).stHTMLTemplate = wlib_StFromIds(43)
                    End If
                    On Error GoTo 0
                End If
            End If
        Next i
    End With
End Sub
Public Sub pub_ApplyOutputFormat()
    Dim i As Integer
    Dim stTest As String
    Dim stTemp As String
    Dim stSpecPropName As String
    With pub_pwi
        For i = 0 To selobj_rgcobj(7) - 1
            If selobj_rgobj(i).fSelected Then
                If .rgpubobj(i).iDocType = 0 Then
                    On Error Resume Next
                    stSpecPropName = wlib_StFromIds(33) & pub_pwi.stSpecName
                    stTest = wlib_dbCur.Containers(wlib_StDocCntOfIDocType(selobj_rgobj(i).iType)).Documents(selobj_rgobj(i).stName).Properties(stSpecPropName)
                    If ((.fUseOldSpec) And (Err = 0)) Then
                        stTemp = wlib_StGetToken(stTest, ";")
                        .rgpubobj(i).iDocType = wlib_StGetToken(stTest, ";")
                    Else
                        .rgpubobj(i).iDocType = -1
                    End If
                    On Error GoTo 0
                End If
            End If
        Next i
    End With
End Sub
Public Sub pub_ClearGlobals()
On Error Resume Next
    pub_dbCode.close
    wlib_CloseCurrentDB
    Set pub_dbCode = Nothing
    pub_rsStrings.close
    Set pub_rsStrings = Nothing
    Erase selobj_rgobj
    Erase selobj_rgcobj
    Erase selobj_rgiOffset
    With selobj_sop
        .fInitSelected = False
        .stDlgCaption = ""
        .stObjTypeLabel = ""
        .stObjLabel = ""
        .stOptionsFxn = ""
        .stObjTypeRowSrc = ""
        .iObjTypeDefault = 0
        .stOtherCategory = ""
        .cobjOther = 0
        .lFlags = ""
        .lHelpContextID = 0
        .stHelpFile = ""
    End With
End Sub

'---
Attribute VB_Name = "selobj_modGlobals"
Option Compare Database
Option Explicit
Type SELOBJ_OBJECT
    stName As String
    iType As Integer
    fSelected As Integer
End Type
Type SELOBJ_PROPS
    fInitSelected As Integer
    fChangedSelObj As Boolean
    stDlgCaption As String
    stObjTypeLabel As String
    stObjLabel As String
    stOptionsFxn As String
    stObjTypeRowSrc As String
    iObjTypeDefault As Integer
    stOtherCategory As String
    rgobjOther() As SELOBJ_OBJECT
    cobjOther As Integer
    lFlags As Long
    lHelpContextID As Long
    stHelpFile As String
End Type
Const STSHOWSYSTEMOBJECTS = "Show System Objects"
Global selobj_rgobj() As SELOBJ_OBJECT
Global selobj_rgcobj(0 To 7) As Integer
Global selobj_rgiOffset(0 To 7) As Integer
Global selobj_fCancel As Integer
Global selobj_sop As SELOBJ_PROPS
Function selobj_FSelectObjects(db As Database, sop As SELOBJ_PROPS) As Integer
    ReDim rgstTmp(1) As String
    Dim i As Integer
    Dim c As Integer
    Dim iObj As Integer
    Dim objtype As Integer
    selobj_rgcobj(7) = 0
    selobj_rgiOffset(7) = 0
    selobj_sop = sop
    For objtype = acTable To acModule
        If ((sop.lFlags And (2 ^ objtype)) <> 0) Then
            selobj_rgcobj(objtype) = wlib_GetObjList(db, objtype, rgstTmp(), &HFFFFF)
            selobj_rgcobj(7) = selobj_rgcobj(7) + selobj_rgcobj(objtype)
            If (selobj_rgcobj(7) > 0) Then
                ReDim Preserve selobj_rgobj(0 To selobj_rgcobj(7) - 1)
            End If
            selobj_rgiOffset(objtype) = iObj
            For i = 1 To selobj_rgcobj(objtype)
                selobj_rgobj(iObj).stName = rgstTmp(i)
                selobj_rgobj(iObj).iType = objtype
                selobj_rgobj(iObj).fSelected = sop.fInitSelected
                iObj = iObj + 1
            Next i
        Else
            selobj_rgcobj(objtype) = 0
            selobj_rgiOffset(objtype) = -1
        End If
    Next objtype
    If (sop.lFlags And 64) Then
        ReDim Preserve selobj_rgobj(0 To selobj_rgcobj(7) + sop.cobjOther - 1)
        selobj_rgiOffset(6) = iObj
        For i = 0 To sop.cobjOther - 1
            selobj_rgobj(iObj + i).stName = sop.rgobjOther(i).stName
            selobj_rgobj(iObj + i).iType = sop.rgobjOther(i).iType
            selobj_rgobj(iObj).fSelected = sop.fInitSelected
        Next i
        selobj_rgcobj(6) = sop.cobjOther
        selobj_rgcobj(7) = selobj_rgcobj(7) + sop.cobjOther
    End If
    DoCmd.OpenForm "selobj_dlgSelectObjects", , , , , acDialog
    selobj_FSelectObjects = Not selobj_fCancel
End Function
Function selobj_FInitAsSubform(sop As SELOBJ_PROPS) As Boolean
    ReDim rgstTmp(1) As String
    Dim i As Integer
    Dim c As Integer
    Dim iObj As Integer
    Dim objtype As Integer
    selobj_rgcobj(7) = 0
    selobj_rgiOffset(7) = 0
    selobj_sop = sop
    wlib_OpenCurrentDB
    For objtype = acTable To acModule
        If ((sop.lFlags And (2 ^ objtype)) <> 0) Then
            selobj_rgcobj(objtype) = wlib_GetObjList(wlib_dbCur, objtype, rgstTmp(), &HFFFFF)
            selobj_rgcobj(7) = selobj_rgcobj(7) + selobj_rgcobj(objtype)
            If (selobj_rgcobj(7) > 0) Then
                ReDim Preserve selobj_rgobj(0 To selobj_rgcobj(7) - 1)
            End If
            selobj_rgiOffset(objtype) = iObj
            For i = 1 To selobj_rgcobj(objtype)
                selobj_rgobj(iObj).stName = rgstTmp(i)
                selobj_rgobj(iObj).iType = objtype
                iObj = iObj + 1
            Next i
        Else
            selobj_rgcobj(objtype) = 0
            selobj_rgiOffset(objtype) = -1
        End If
    Next objtype
    If (sop.lFlags And 64) Then
        ReDim Preserve selobj_rgobj(0 To selobj_rgcobj(7) + sop.cobjOther - 1)
        selobj_rgiOffset(6) = iObj
        For i = 0 To sop.cobjOther - 1
            selobj_rgobj(iObj + i).stName = sop.rgobjOther(i).stName
            selobj_rgobj(iObj + i).iType = sop.rgobjOther(i).iType
            selobj_rgobj(iObj).fSelected = sop.fInitSelected
        Next i
        selobj_rgcobj(6) = sop.cobjOther
        selobj_rgcobj(7) = selobj_rgcobj(7) + sop.cobjOther
    End If
    selobj_FInitAsSubform = (selobj_rgcobj(7) > 0)
    wlib_CloseCurrentDB
End Function
'---
Attribute VB_Name = "sbm_mod"
Option Compare Database
Option Explicit
Type SBM_MENU_ITEM
    lSwitchboardID As Long
    lItemNumber As Long
    stItemText As String
    lCommand As Long
    stArgument As String
End Type
Public Sub sbm_CreateSwitchboard(stCaption As String, stTitle As String, stImgFile As String, stOnOpenCode As String, fDelaySave As Integer)
    Dim frmSb As Form
    Dim stTblName As String
    Dim stFormName As String
    Dim rsCode As Recordset
    Dim stCode As String
    stTblName = wlib_StFromIds(10004)
    stFormName = wlib_StFromIds(10003)
    DoCmd.TransferDatabase acImport, "Microsoft Access", (apwz_dbCode.Name), acTable, "sbm_tblSbItems_Template", stTblName
    Set frmSb = FrmCreateSwitchboardForm(stCaption, stTitle, stImgFile)
    Set rsCode = apwz_dbCode.OpenRecordset("sbm_tblCode", dbOpenTable)
    rsCode.Index = "PrimaryKey"
    rsCode.Seek "=", 1
    stCode = rsCode![Code]
    If (stOnOpenCode = "") Then
        rsCode.Seek "=", 4
        stOnOpenCode = rsCode![Code]
    End If
    rsCode.close
    wlib_ReplaceStr stCode, "|ONOPENCODE", stOnOpenCode
    frmSb.Module.InsertText stCode & vbCrLf
    If (fDelaySave) Then
        SysCmd 503, frmSb.Hwnd, stFormName
        frmSb.Visible = False
    Else
        DoCmd.Save , stFormName
        DoCmd.close acForm, stFormName
    End If
End Sub
Private Function FrmCreateSwitchboardForm(stCaption As String, stTitle As String, stImgFile As String) As Form
    Dim rs As Recordset
    Dim Ctl As Control
    Dim frm As Form
    Set frm = CreateForm
    If (stCaption <> "") Then frm.Caption = stCaption
    frm.RecordSource = wlib_StFromIds(10004)
    frm.AutoCenter = True
    frm.NavigationButtons = 0
    frm.RecordSelectors = 0
    frm.ScrollBars = 0
    frm.Width = 7740
    frm.Section(0).BackColor = -2147483633
    frm.AllowEdits = False
    frm.AllowDeletions = False
    frm.AllowAdditions = False
    frm.AllowFilters = False
    frm.ShortcutMenu = False
    frm.ViewsAllowed = 0
    Set rs = apwz_dbCode.OpenRecordset("sbm_qrySbFrmControls")
    While (Not (rs.EOF))
        Set Ctl = CreateControl(frm.Name, rs![ControlType], 0, Nz(rs![Parent], ""), , rs![Left], rs![top], rs![Width], rs![Height])
        Ctl.Name = rs![ControlName]
        If (Left$(Ctl.Name, 6) = "Option") Then
            Ctl.OnClick = "=HandleButtonClick(" & Right$(Ctl.Name, 1) & ")"
        End If
On Error Resume Next
        Ctl.Visible = rs![Visible]
        Ctl.BackColor = rs![BackColor]
        Ctl.BackStyle = rs![BackStyle]
        Ctl.BorderColor = rs![BorderColor]
        Ctl.BorderStyle = rs![BorderStyle]
        Ctl.SpecialEffect = rs![SpecialEffect]
        Ctl.FontName = rs![FontName]
        Ctl.FontSize = rs![FontSize]
        Ctl.ForeColor = rs![ForeColor]
On Error GoTo 0
        rs.MoveNext
    Wend
    rs.close
On Error Resume Next
    If (stImgFile <> "") Then frm![Picture].Picture = stImgFile
On Error GoTo 0
    DoCmd.SelectObject acForm, frm.Name, False
    frm![Picture].SizeMode = 1
    frm![Picture].InSelection = True
    DoCmd.DoMenuItem 3, 4, 8, 0, acMenuVer70
    frm![Picture].InSelection = False
    frm![VerticalShadowBox].InSelection = True
    DoCmd.DoMenuItem 3, 4, 9, 0, acMenuVer70
    frm![VerticalShadowBox].InSelection = False
    If (stTitle <> "") Then
        frm!Label1.Caption = stTitle
        frm!Label2.Caption = stTitle
    End If
    Set FrmCreateSwitchboardForm = frm
End Function
Function sbm_Entry()
On Error GoTo sbm_Entry_Err
    Dim rs As Recordset
    Dim stSbFrmName As String
    Dim fAddInStarted As Integer
    Dim fCloseCurrentDb As Integer
    Dim stTemp As String
    Set apwz_dbCode = CodeDb()
    Set apwz_rsStrings = apwz_dbCode.OpenRecordset("apwz_tblStrings", dbOpenTable)
    apwz_rsStrings.Index = "PrimaryKey"
    wlib_StartAddIn 10000, apwz_rsStrings, "String"
    fAddInStarted = True
    wlib_OpenCurrentDB
    fCloseCurrentDb = True
    If (Not wlib_dbCur.Updatable) Then
        wlib_IMsgBox 10011, "", vbOKOnly Or vbInformation
        GoTo sbm_Entry_Exit
    End If
    Select Case (IValidTableExists())
        Case 0
            On Error Resume Next
            stTemp = wlib_dbCur.Properties("MDE")
            If (Err = 0) And (stTemp = "T") Then
                On Error GoTo sbm_Entry_Err
                wlib_IMsgBox 10021, "", vbOKOnly Or vbInformation
                GoTo sbm_Entry_Exit
            End If
            On Error GoTo sbm_Entry_Err
            If (wlib_IMsgBox(10005, "", vbYesNo Or vbExclamation) = vbYes) Then
                stSbFrmName = wlib_StFromIds(10003)
                If (wlib_ErrNameOK(wlib_dbCur, acForm, stSbFrmName) = 2) Then
                    wlib_IMsgBox 10008, stSbFrmName, vbOKOnly Or vbInformation
                    GoTo sbm_Entry_Exit
                End If
                sbm_CreateSwitchboard wlib_StFromIds(10003), wlib_StFileOfFullPath(CurrentDb.Name, True), "", "", False
                wlib_dbCur.TableDefs.Refresh
                Set rs = wlib_dbCur.OpenRecordset(wlib_StFromIds(10004))
                rs.AddNew
                rs![SwitchboardID] = 1
                rs![ItemText] = wlib_StFromIds(5013)
                rs![Argument] = wlib_StFromIds(5016)
                rs.Update
                rs.close
            Else
                GoTo sbm_Entry_Exit
            End If
        Case 1
            wlib_IMsgBox 10022, "", vbOKOnly Or vbInformation
            GoTo sbm_Entry_Exit
        Case 2
        Case Else
    End Select
    AttachToSbTbl
    DoCmd.OpenForm "sbm_frmEditSb", , , , , acDialog
sbm_Entry_Exit:
On Error Resume Next
    If (fCloseCurrentDb) Then wlib_CloseCurrentDB
    If (fAddInStarted) Then wlib_EndAddIn
    apwz_dbCode.close
    Exit Function
sbm_Entry_Err:
    wlib_HandleError Err, Error$
    Resume sbm_Entry_Exit
End Function
Private Function IValidTableExists() As Integer
On Error GoTo IValidTableExists_Err
    Dim td As TableDef
    Dim stTblName As String
    Dim ireturn As Integer
    Dim FTblExists As Integer
    stTblName = wlib_StFromIds(10004)
    Select Case (wlib_ErrNameOK(wlib_dbCur, acTable, stTblName))
        Case 2
            FTblExists = True
            Set td = wlib_dbCur.TableDefs(stTblName)
            If (td.Fields("SwitchboardID").Type <> dbLong) Then Error 31500
            If (td.Fields("ItemNumber").Type <> dbInteger) Then Error 31500
            If (td.Fields("ItemText").Type <> dbText) Then Error 31500
            If (td.Fields("Command").Type <> dbInteger) Then Error 31500
            If (td.Fields("Argument").Type <> dbText) Then Error 31500
            ireturn = 2
        Case 1
            ireturn = 1
        Case Else
            ireturn = 0
    End Select
IValidTableExists_Exit:
    IValidTableExists = ireturn
    Exit Function
IValidTableExists_Err:
    If (FTblExists) Then
        Error 31500
    Else
        Error Err
    End If
    Resume IValidTableExists_Exit
End Function
Private Sub AttachToSbTbl()
    Const STATTACHEDTBLNAME = "~tblSbItems_Attached"
    Dim td As TableDef
    Dim fCreateLink As Integer
On Error Resume Next
    Set td = apwz_dbCode.TableDefs(STATTACHEDTBLNAME)
    fCreateLink = (Err <> 0)
On Error GoTo 0
    If (fCreateLink) Then
        Set td = apwz_dbCode.CreateTableDef(STATTACHEDTBLNAME)
        td.Connect = ";DATABASE=" & wlib_dbCur.Name
        td.Attributes = 0
        td.SourceTableName = wlib_StFromIds(10004)
        apwz_dbCode.TableDefs.Append td
    Else
        td.Connect = ";DATABASE=" & wlib_dbCur.Name
        td.RefreshLink
    End If
End Sub
'---
Attribute VB_Name = "styl_modStyles"
Option Compare Database
Option Explicit
Const CLIP_CONTROLONLY = 0
Const CLIP_ALL = 1
Global styl_dbCode As Database
Global styl_cDbCodeRefs As Integer
Global styl_dbData As Database
Global styl_rsTblMULock As Recordset
Global styl_cDbDataRefs As Integer
Global styl_rsSectionStyles As Recordset
Global styl_rsControlStyles As Recordset
Global styl_lHelpContextID As Long
Global styl_stHelpFile As String
Global styl_fAppWizard As Integer
Dim styl_iCurCSControlType As Integer
Dim styl_iCurCSSection As Integer
Type STYL_FILLSTYLE
    stName As String
    lStyleID As Long
    fAllowDelete As Boolean
End Type
Global styl_fAutoFormatCartoon As Integer
Global styl_stListCaption As String
Global styl_stTopLevelFormName As String
Global styl_stBitmapPath As String
Global styl_cart_rsControlStyles As Recordset
Global styl_cart_rsSectionStyles As Recordset
Global styl_cart_rsRptStyles As Recordset
Global styl_iStyleType As Integer
Global styl_lCartStyleID As Long
Type STYL_CONTROLSIZINGINFO
    stFontName As String
    iFontSize As Integer
    iFontWeight As Integer
    fFontItalic As Integer
    fFontUnderline As Integer
    stCaption As String
    cch As Integer
    iBorderStyle As Integer
    iBorderWidth As Integer
    iSpecialEffect As Integer
    cchUseMaxWidth As Integer
    dxLine As Long
    dyLine As Long
    dxBorder As Long
    dyBorder As Long
End Type
Global styl_xPixelPerInch As Integer
Global styl_yPixelPerInch As Integer
Global styl_xTwipsPerPixel As Integer
Global styl_yTwipsPerPixel As Integer
Function styl_ErrInitEngine(stMdtFile As String, Optional SingleUser As Variant) As Long
On Error GoTo styl_ErrInitEngine_Err
    Dim fOpenedCodeDb As Integer
    If (styl_cDbCodeRefs = 0) Then Set styl_dbCode = CodeDb()
    styl_cDbCodeRefs = styl_cDbCodeRefs + 1
    fOpenedCodeDb = True
    If IsMissing(SingleUser) Then SingleUser = False
    If SingleUser = True Then
        Set styl_rsTblMULock = styl_dbCode.OpenRecordset("styl_tblMULock", dbOpenTable, dbDenyRead)
    Else
        Set styl_rsTblMULock = styl_dbCode.OpenRecordset("styl_tblMULock", dbOpenTable)
    End If
    styl_iCurCSControlType = -9999
    styl_iCurCSSection = -9999
    OpenDataDB stMdtFile
    styl_ErrInitEngine = 0
styl_ErrInitEngine_Exit:
    Exit Function
styl_ErrInitEngine_Err:
    If fOpenedCodeDb Then
        styl_cDbCodeRefs = styl_cDbCodeRefs - 1
        If styl_cDbCodeRefs = 0 Then styl_dbCode.close
        fOpenedCodeDb = False
    End If
    styl_ErrInitEngine = Err
    Resume styl_ErrInitEngine_Exit
End Function
Function styl_ErrUninitEngine() As Long
On Error GoTo styl_ErrUnInitEngine_Err
    styl_cDbCodeRefs = styl_cDbCodeRefs - 1
    If (styl_cDbCodeRefs = 0) Then
On Error Resume Next
        styl_rsControlStyles.close
        styl_rsSectionStyles.close
On Error GoTo styl_ErrUnInitEngine_Err
        styl_rsTblMULock.close
        styl_dbCode.close
    End If
    CloseDataDB
styl_ErrUnInitEngine_Exit:
    Exit Function
styl_ErrUnInitEngine_Err:
    styl_ErrUninitEngine = Err
    Resume styl_ErrUnInitEngine_Exit
End Function
Function styl_ErrSelectStyle(lStyleID As Long) As Long
On Error GoTo styl_ErrSelectStyle_Err
    If lStyleID = 0 Then
        Set styl_rsSectionStyles = styl_dbData.OpenRecordset("styl_qrySectionProperties", dbOpenDynaset)
        Set styl_rsControlStyles = styl_dbData.OpenRecordset("styl_qryControlProperties", dbOpenDynaset)
    Else
        Dim qd As QueryDef
        Set qd = styl_dbData.QueryDefs("styl_qrySectionPropertiesParam")
        qd.Parameters(0) = lStyleID
        Set styl_rsSectionStyles = qd.OpenRecordset(dbOpenDynaset)
        Set qd = styl_dbData.QueryDefs("styl_qryControlPropertiesParam")
        qd.Parameters(0) = lStyleID
        Set styl_rsControlStyles = qd.OpenRecordset(dbOpenDynaset)
        If styl_rsSectionStyles.EOF Then
            styl_ErrSelectStyle = 5005
            GoTo styl_ErrSelectStyle_Exit
        End If
    End If
    styl_ErrSelectStyle = 0
styl_ErrSelectStyle_Exit:
    Exit Function
styl_ErrSelectStyle_Err:
    styl_ErrSelectStyle = Err
    Resume styl_ErrSelectStyle_Exit
End Function
Function styl_LDefaultStyle(iObjectType As Integer, Optional fVerify As Variant) As Long
On Error GoTo styl_LDefaultStyle_Err
    Dim lID As Long
    Dim hkey As Long
    Dim rs As Recordset
    Dim qd As QueryDef
    styl_LDefaultStyle = 0
    If IsMissing(fVerify) Then fVerify = True
    If wlib_OpenAccessRegKey("Wizards", hkey) = 0 Then
        Select Case iObjectType
            Case acForm
                If wlib_ErrGetRegVal(hkey, "Preferences\AutoFormat", "FormAutoFormat", lID, ByVal 4) = 0 Then
                    styl_LDefaultStyle = lID
                Else
                    styl_LDefaultStyle = 64
                End If
            Case acReport
                If wlib_ErrGetRegVal(hkey, "Preferences\AutoFormat", "ReportAutoFormat", lID, ByVal 4) = 0 Then
                    styl_LDefaultStyle = lID
                Else
                    styl_LDefaultStyle = 70
                End If
        End Select
        If fVerify Then
            Set qd = styl_dbData.QueryDefs!styl_qryParamByObjectType
            qd.Parameters(0) = iObjectType
            Set rs = qd.OpenRecordset()
            rs.FindFirst "[StyleID] = " & styl_LDefaultStyle
            If rs.NoMatch Then
                rs.MoveFirst
                styl_LDefaultStyle = rs!StyleID
            End If
        End If
    End If
styl_LDefaultStyle_Exit:
On Error Resume Next
    If hkey Then wlib_RegCloseKey hkey
    rs.close
    Exit Function
styl_LDefaultStyle_Err:
    styl_LDefaultStyle = 0
    Resume styl_LDefaultStyle_Exit
End Function
Sub styl_SetDefaultStyle(iObjectType As Integer, lStyleID As Long)
On Error Resume Next
    Dim hkey As Long
    If wlib_OpenAccessRegKey("Wizards", hkey) = 0 Then
        wlib_ErrWriteRegKey hkey, "Preferences\AutoFormat", ""
        Select Case iObjectType
            Case acForm
                wlib_ErrWriteRegVal hkey, "Preferences\AutoFormat", "FormAutoFormat", lStyleID, ByVal 4
            Case acReport
                wlib_ErrWriteRegVal hkey, "Preferences\AutoFormat", "ReportAutoFormat", lStyleID, ByVal 4
        End Select
        wlib_RegCloseKey hkey
    End If
End Sub
Function styl_ErrApplyDefaultCS(frmrpt As Object) As Long
On Error GoTo styl_ErrApplyDefaultCS_Err
    Dim Ctl As Control
    styl_iCurCSControlType = -9999
    styl_iCurCSSection = -9999
    styl_rsControlStyles.FindFirst "[Section] = " & 0
    If (Not styl_rsControlStyles.NoMatch) Then
        While (Not styl_rsControlStyles.NoMatch)
            Set Ctl = frmrpt.DefaultControl((styl_rsControlStyles!ControlType))
            Ctl.BorderColor = styl_rsControlStyles!BorderColor
            If styl_fAppWizard Then
                If TypeOf Ctl Is SubForm Then
                    Ctl.BorderWidth = 0
                Else
                    Ctl.BorderWidth = wlib_Min(3, styl_rsControlStyles!BorderWidth)
                End If
            Else
                Ctl.BorderWidth = styl_rsControlStyles!BorderWidth
            End If
            Ctl.BorderStyle = styl_rsControlStyles!BorderStyle
            If styl_fAppWizard Then
                If TypeOf Ctl Is SubForm Then
                    Ctl.SpecialEffect = 0
                Else
                    Ctl.SpecialEffect = styl_rsControlStyles!SpecialEffect
                End If
            Else
                Ctl.SpecialEffect = styl_rsControlStyles!SpecialEffect
            End If
            Ctl.BackColor = styl_rsControlStyles!BackColor
            Ctl.BackStyle = styl_rsControlStyles!BackStyle
            Ctl.ForeColor = styl_rsControlStyles!ForeColor
            Ctl.FontName = styl_rsControlStyles!FontName
            Ctl.FontSize = styl_rsControlStyles!FontSize
            Ctl.FontWeight = styl_rsControlStyles!FontWeight
            Ctl.FontUnderline = styl_rsControlStyles!FontUnderline
            Ctl.FontItalic = styl_rsControlStyles!FontItalic
            If styl_fAppWizard Then
                If TypeOf Ctl Is Label Then
                    Ctl.TextAlign = 1
                Else
                    Ctl.TextAlign = styl_rsControlStyles!TextAlign
                End If
            Else
                Ctl.TextAlign = styl_rsControlStyles!TextAlign
            End If
NextCtlType:
            styl_rsControlStyles.FindNext "[Section] = " & 0
        Wend
    Else
        styl_ErrApplyDefaultCS = 5000
    End If
styl_ErrApplyDefaultCS_Exit:
    Exit Function
styl_ErrApplyDefaultCS_Err:
    If Err = 2455 Or Err = 438 Or Err = 2101 Or Err = 2125 Then
        Resume Next
    Else
        styl_ErrApplyDefaultCS = Err
        Resume styl_ErrApplyDefaultCS_Exit
    End If
End Function
Function styl_ErrApplyCS(Ctl As Control, iControlType As Integer, lStyleParts As Long, frmrpt As Object, Optional vControlSection As Variant) As Long
On Error GoTo styl_ErrApplyCS_Err
    Dim ss As Long
    styl_ErrApplyCS = 0
    If IsMissing(vControlSection) Then
        ss = styl_SSFromISect(frmrpt, Ctl.Section)
    Else
        ss = styl_SSFromISect(frmrpt, (vControlSection))
    End If
    If (styl_iCurCSControlType <> iControlType) Or (styl_iCurCSSection <> ss) Then
        styl_rsControlStyles.FindFirst "[ControlType] = " & (iControlType) & " And [Section] = " & ss
        styl_iCurCSControlType = iControlType
        styl_iCurCSSection = ss
    End If
    If (Not styl_rsControlStyles.NoMatch) Then
        If (lStyleParts <> 16) And (lStyleParts <> 0) Then
            styl_ErrApplyCS = ErrApplyCS(Ctl, lStyleParts, styl_rsControlStyles, False)
        End If
    Else
        styl_ErrApplyCS = 5000
    End If
styl_ErrApplyCS_Exit:
    Exit Function
styl_ErrApplyCS_Err:
    styl_ErrApplyCS = Err
    Resume styl_ErrApplyCS_Exit
End Function
Function styl_ErrApplyDS(frmrpt As Object, lStyleParts As Long) As Long
On Error GoTo styl_ErrApplyDS_Err
    styl_ErrApplyDS = ErrApplyDS(frmrpt, styl_rsSectionStyles, lStyleParts)
styl_ErrApplyDS_Exit:
    Exit Function
styl_ErrApplyDS_Err:
    styl_ErrApplyDS = Err
    Resume styl_ErrApplyDS_Exit
End Function
Function styl_ErrApplySS(frmrpt As Object, isect As Integer, lStyleParts As Long) As Long
On Error GoTo styl_ErrApplySS_Err
    styl_rsSectionStyles.FindFirst "[Section] = " & styl_SSFromISect(frmrpt, isect)
    If Not (styl_rsSectionStyles.NoMatch) Then
        If (lStyleParts <> 16) Then
            styl_ErrApplySS = ErrApplySS(frmrpt.Section(isect), styl_rsSectionStyles)
        End If
    Else
        styl_ErrApplySS = 5001
    End If
styl_ErrApplySS_Exit:
    Exit Function
styl_ErrApplySS_Err:
    styl_ErrApplySS = Err
    Resume styl_ErrApplySS_Exit
End Function
Function styl_ErrGetPlacementRectFromData(Ctl As Control, ctlLabel As Control, rcPlacement As WLIB_RECT) As Long
On Error GoTo styl_ErrGetPlacementRectFromData_Err
    Dim bmLabelPos As Integer
    Dim dxLabelOffset As Integer
    Dim dyLabelOffset As Integer
    If styl_fAppWizard Then
        If (TypeOf Ctl Is SubForm Or TypeOf Ctl Is SubReport) Then
            bmLabelPos = 7
            dxLabelOffset = 0
            dyLabelOffset = 0
        Else
            bmLabelPos = 13
            dxLabelOffset = -144
            dyLabelOffset = 0
        End If
    Else
        If styl_rsControlStyles.NoMatch Then
            bmLabelPos = 1 Or 4 Or 8
            dxLabelOffset = 0
            dyLabelOffset = 0
        Else
            bmLabelPos = Nz(styl_rsControlStyles!LabelPosBits, 1 Or 4 Or 8)
            dxLabelOffset = Nz(styl_rsControlStyles!LabelDxOffset, 0)
            dyLabelOffset = Nz(styl_rsControlStyles!LabelDyOffset, 0)
        End If
    End If
    GetPlacementRect Ctl, ctlLabel, rcPlacement, bmLabelPos, dxLabelOffset, dyLabelOffset
styl_ErrGetPlacementRectFromData_Exit:
    Exit Function
styl_ErrGetPlacementRectFromData_Err:
    styl_ErrGetPlacementRectFromData = Err
    Resume styl_ErrGetPlacementRectFromData_Exit
End Function
Function styl_ErrGetPlacementRectFromUI(Ctl As Control, ctlLabel As Control, rcPlacement As WLIB_RECT, bmLabelPos As Integer, dxLabelOffset As Integer, dyLabelOffset As Integer) As Long
On Error GoTo styl_ErrGetPlacementRectFromUI_Err
    GetPlacementRect Ctl, ctlLabel, rcPlacement, bmLabelPos, dxLabelOffset, dyLabelOffset
styl_ErrGetPlacementRectFromUI_Exit:
    Exit Function
styl_ErrGetPlacementRectFromUI_Err:
    styl_ErrGetPlacementRectFromUI = Err
    Resume styl_ErrGetPlacementRectFromUI_Exit
End Function
Function styl_ErrPlaceControlsFromData(Ctl As Control, ctlLabel As Control, rcLimit As WLIB_RECT, rcPlacement As WLIB_RECT, frmrpt As Object, iControlType As Integer, isect As Integer) As Long
On Error GoTo styl_ErrPlaceControlsFromData_Err
    Dim bmLabelPos As Integer
    Dim dxLabelOffset As Integer
    Dim dyLabelOffset As Integer
    Dim ss As Integer
    ss = styl_SSFromISect(frmrpt, isect)
    If (styl_iCurCSControlType <> iControlType) Or (styl_iCurCSSection <> ss) Then
        styl_rsControlStyles.FindFirst "[ControlType] = " & (iControlType) & " And [Section] = " & ss
        styl_iCurCSControlType = iControlType
        styl_iCurCSSection = ss
    End If
    If styl_fAppWizard Then
        If (TypeOf Ctl Is SubForm Or TypeOf Ctl Is SubReport) Then
            bmLabelPos = 7
            dxLabelOffset = 0
            dyLabelOffset = 0
       Else
            bmLabelPos = 13
            dxLabelOffset = -144
            dyLabelOffset = 0
        End If
    Else
        If styl_rsControlStyles.NoMatch Then
            bmLabelPos = 1 Or 4 Or 8
            dxLabelOffset = 0
            dyLabelOffset = 0
        Else
            bmLabelPos = Nz(styl_rsControlStyles!LabelPosBits, 1 Or 4 Or 8)
            dxLabelOffset = Nz(styl_rsControlStyles!LabelDxOffset, 0)
            dyLabelOffset = Nz(styl_rsControlStyles!LabelDyOffset, 0)
        End If
    End If
    PlaceControls Ctl, ctlLabel, rcLimit, rcPlacement, bmLabelPos, dxLabelOffset, dyLabelOffset, CLIP_CONTROLONLY
styl_ErrPlaceControlsFromData_Exit:
    Exit Function
styl_ErrPlaceControlsFromData_Err:
    styl_ErrPlaceControlsFromData = Err
    Resume styl_ErrPlaceControlsFromData_Exit
End Function
Function styl_ErrPlaceControlsFromUI(Ctl As Control, ctlLabel As Control, rcLimit As WLIB_RECT, bmLabelPos As Integer, dxLabelOffset As Integer, dyLabelOffset As Integer) As Long
On Error GoTo styl_ErrPlaceControlsFromUI_Err
    PlaceControls Ctl, ctlLabel, rcLimit, rcLimit, bmLabelPos, dxLabelOffset, dyLabelOffset, CLIP_ALL
styl_ErrPlaceControlsFromUI_Exit:
    Exit Function
styl_ErrPlaceControlsFromUI_Err:
    styl_ErrPlaceControlsFromUI = Err
    Resume styl_ErrPlaceControlsFromUI_Exit
End Function
Function styl_FSectionExists(frmrpt As Object, isect As Integer) As Integer
On Error GoTo styl_FSectionExists_Err
    styl_FSectionExists = (frmrpt.Section(isect).Height >= 0)
styl_FSectionExists_Exit:
    Exit Function
styl_FSectionExists_Err:
    styl_FSectionExists = False
    Resume styl_FSectionExists_Exit
End Function
Function styl_ILabelPosition(iControlType As Integer, isect As Integer, frmrpt As Object) As Integer
On Error GoTo styl_ILabelPosition_Err
    Dim bmLabelPos As Long
    Dim ss As Long
    ss = styl_SSFromISect(frmrpt, isect)
    If (styl_iCurCSControlType <> iControlType) Or (styl_iCurCSSection <> ss) Then
        styl_rsControlStyles.FindFirst "[ControlType] = " & (iControlType) & " And [Section] = " & ss
        styl_iCurCSControlType = iControlType
        styl_iCurCSSection = ss
    End If
    If (Not styl_rsControlStyles.NoMatch) Then
        bmLabelPos = Nz(styl_rsControlStyles!LabelPosBits, 1)
        If (bmLabelPos And 1) <> 0 And ((bmLabelPos And 2) = 0) And _
           (bmLabelPos And 4) <> 0 And (bmLabelPos And 8) <> 0 Then
            styl_ILabelPosition = 0
        ElseIf (bmLabelPos And 1) <> 0 And ((bmLabelPos And 2) = 0) And _
               ((bmLabelPos And 4) = 0) And ((bmLabelPos And 8) = 0) Then
            styl_ILabelPosition = 0
        ElseIf ((bmLabelPos And 1) = 0) And (bmLabelPos And 2) <> 0 And _
               (bmLabelPos And 4) <> 0 And (bmLabelPos And 8) <> 0 Then
            styl_ILabelPosition = 2
        Else
            styl_ILabelPosition = -1
        End If
    Else
        styl_ILabelPosition = -1
    End If
styl_ILabelPosition_Exit:
    Exit Function
styl_ILabelPosition_Err:
    styl_ILabelPosition = -1
    Resume styl_ILabelPosition_Exit
End Function
Function styl_SSFromISect(frmrpt As Object, isect As Integer) As Long
    Dim iGL As Integer
    Dim iGLCur As Integer
    Dim cGLFromDetail As Integer
    If isect <= 4 Then
        styl_SSFromISect = isect
    Else
        iGLCur = Int((isect - 4 - 1) / 2)
        cGLFromDetail = 1
        For iGL = iGLCur + 1 To 10 - 1
            If FGLExists(frmrpt, iGL) Then
                If frmrpt.GroupLevel(iGL).GroupHeader Or frmrpt.GroupLevel(iGL).GroupFooter Then
                    cGLFromDetail = cGLFromDetail + 1
                End If
            Else
                Exit For
            End If
        Next iGL
        If isect Mod 2 <> 0 Then
            styl_SSFromISect = (-2 * cGLFromDetail) + 1
        Else
            styl_SSFromISect = (-2 * cGLFromDetail)
        End If
    End If
End Function
Sub styl_RequeryRS(fSection As Integer, fControl As Integer)
On Error GoTo styl_RequeryRS_Err
    If fSection Then styl_rsSectionStyles.Requery
    If fControl Then styl_rsControlStyles.Requery
styl_RequeryRS_Exit:
    Exit Sub
styl_RequeryRS_Err:
    Error Err
    Resume styl_RequeryRS_Exit
End Sub
Private Sub ClipToRect(Ctl As Control, ctlLabel As Control, rcLimit As WLIB_RECT, bmLabelPos As Integer, dxLabelOffset As Integer, dyLabelOffset As Integer, iClipMethod As Integer)
    Dim dxLimit As Integer
    Dim dyLimit As Integer
    Dim xCtl As Integer
    Dim yCtl As Integer
    Dim xLabel As Integer
    Dim yLabel As Integer
    Dim dxPair As Integer
    Dim dyPair As Integer
    Dim pctClip As Double
    dxLimit = (rcLimit.Right - rcLimit.Left)
    dyLimit = (rcLimit.bottom - rcLimit.top)
    If dxLimit = 0 And dyLimit = 0 Then
        Exit Sub
    End If
    If (ctlLabel Is Nothing) Then
        If (Ctl.Width > dxLimit) Then
            Ctl.Width = dxLimit
        End If
        If (Ctl.Height) > dyLimit Then
            Ctl.Height = dyLimit
        End If
    Else
        GetCtlPairDimensions Ctl, ctlLabel, bmLabelPos, dxLabelOffset, dyLabelOffset, xCtl, yCtl, xLabel, yLabel, dxPair, dyPair
        If (dxPair > dxLimit) Then
            If (dxLabelOffset) > dxLimit Then Error 5003
            If iClipMethod = CLIP_ALL Then
                pctClip = (dxLimit - Abs(dxLabelOffset)) / (dxPair - Abs(dxLabelOffset))
                Ctl.Width = Ctl.Width * pctClip
                ctlLabel.Width = ctlLabel.Width * pctClip
            Else
                Ctl.Width = Ctl.Width - (dxPair - dxLimit)
            End If
        End If
        If (dyPair > dyLimit) Then
            If (dyLabelOffset) > dyLimit Then Error 5003
            If iClipMethod = CLIP_ALL Then
                pctClip = (dyLimit - Abs(dyLabelOffset)) / (dyPair - Abs(dyLabelOffset))
                Ctl.Height = Ctl.Height * pctClip
                ctlLabel.Height = ctlLabel.Height * pctClip
            Else
                Ctl.Height = Ctl.Height - (dyPair - dyLimit)
            End If
        End If
    End If
End Sub
Private Sub CloseDataDB()
    styl_cDbDataRefs = styl_cDbDataRefs - 1
    If (styl_cDbDataRefs = 0) Then styl_dbData.close
End Sub
Private Function FGLExists(frmrpt As Object, iGL As Integer) As Integer
On Error Resume Next
    Dim v As Variant
    v = frmrpt.GroupLevel(iGL).SortOrder
    FGLExists = (Err = 0)
End Function
Private Sub GetCtlPairDimensions(Ctl As Control, ctlLabel As Control, bmLabelPos As Integer, dxLabelOffset As Integer, dyLabelOffset As Integer, xCtl As Integer, yCtl As Integer, xLabel As Integer, yLabel As Integer, dxPair As Integer, dyPair As Integer)
    xCtl = 0
    yCtl = 0
    xLabel = dxLabelOffset
    yLabel = dyLabelOffset
    If (bmLabelPos And 2) = 0 Then
        xLabel = xLabel - ctlLabel.Width
    End If
    If (bmLabelPos And 1) = 0 Then
        xLabel = xLabel + Ctl.Width
    End If
    If (bmLabelPos And 8) = 0 Then
        yLabel = yLabel - ctlLabel.Height
    End If
    If (bmLabelPos And 4) = 0 Then
        yLabel = yLabel + Ctl.Height
    End If
    If xLabel < 0 Then
        xCtl = xCtl - xLabel
        xLabel = 0
    End If
    If yLabel < 0 Then
        yCtl = yCtl - yLabel
        yLabel = 0
    End If
    dxPair = wlib_Max((xCtl + Ctl.Width), (xLabel + ctlLabel.Width))
    dyPair = wlib_Max((yCtl + Ctl.Height), (yLabel + ctlLabel.Height))
End Sub
Private Sub GetPlacementRect(Ctl As Control, ctlLabel As Control, rcPlacement As WLIB_RECT, bmLabelPos As Integer, dxLabelOffset As Integer, dyLabelOffset As Integer)
    Dim dx As Integer
    Dim dy As Integer
    If Not (ctlLabel Is Nothing) Then
        GetCtlPairDimensions Ctl, ctlLabel, bmLabelPos, dxLabelOffset, dyLabelOffset, 0, 0, 0, 0, dx, dy
    Else
        If Ctl.ControlType = acPageBreak Then
            dx = 0
            dy = 0
        Else
            dx = Ctl.Width
            dy = Ctl.Height
        End If
    End If
    rcPlacement.Right = rcPlacement.Left + dx
    rcPlacement.bottom = rcPlacement.top + dy
End Sub
Private Sub OpenDataDB(stMdtFile As String)
    Dim errGetMdt As Long
    If (styl_cDbDataRefs = 0) Then
        If Len(stMdtFile) = 0 Then
            errGetMdt = wlib_ErrGetMdtPath(True, stMdtFile)
            If errGetMdt <> 0 Then Error errGetMdt
        End If
        Set styl_dbData = OpenDatabase(stMdtFile, False)
    End If
    styl_cDbDataRefs = styl_cDbDataRefs + 1
End Sub
Private Sub PlaceControls(Ctl As Control, ctlLabel As Control, rcLimit As WLIB_RECT, rcPlacement As WLIB_RECT, bmLabelPos As Integer, dxLabelOffset As Integer, dyLabelOffset As Integer, iClipMethod As Integer)
    Dim xCtl As Integer
    Dim yCtl As Integer
    Dim xLabel As Integer
    Dim yLabel As Integer
    If Not (ctlLabel Is Nothing) Then
        ClipToRect Ctl, ctlLabel, rcLimit, bmLabelPos, dxLabelOffset, dyLabelOffset, iClipMethod
        GetCtlPairDimensions Ctl, ctlLabel, bmLabelPos, dxLabelOffset, dyLabelOffset, xCtl, yCtl, xLabel, yLabel, 0, 0
        Ctl.Left = rcPlacement.Left + xCtl
        Ctl.top = rcPlacement.top + yCtl
        ctlLabel.Left = rcPlacement.Left + xLabel
        ctlLabel.top = rcPlacement.top + yLabel
    Else
        If Ctl.ControlType <> acPageBreak Then ClipToRect Ctl, Nothing, rcLimit, -1, 0, 0, iClipMethod
        Ctl.Left = rcPlacement.Left
        Ctl.top = rcPlacement.top
    End If
End Sub
Private Function ErrApplyCS(Ctl As Control, lStyleParts As Long, rs As Recordset, fCartoon As Boolean) As Long
On Error GoTo ErrApplyCS_Err
    If (lStyleParts And 4) Then
        Ctl.BorderColor = rs!BorderColor
        If styl_fAppWizard Then
            If TypeOf Ctl Is SubForm Then
                Ctl.BorderWidth = 0
            Else
                Ctl.BorderWidth = wlib_Min(3, rs!BorderWidth)
            End If
        Else
            Ctl.BorderWidth = rs!BorderWidth
        End If
        Ctl.BorderStyle = rs!BorderStyle
        If styl_fAppWizard Then
            If TypeOf Ctl Is SubForm Then
                Ctl.SpecialEffect = 0
            Else
                Ctl.SpecialEffect = rs!SpecialEffect
            End If
        Else
            Ctl.SpecialEffect = rs!SpecialEffect
        End If
    Else
        If fCartoon Then
            Ctl.BorderColor = 16777215
            Ctl.BorderWidth = 0
            Ctl.BorderStyle = 0
            Ctl.SpecialEffect = 0
        End If
    End If
    If (lStyleParts And 1) Then
        Ctl.BackColor = rs!BackColor
        Ctl.BackStyle = rs!BackStyle
        Ctl.ForeColor = rs!ForeColor
    Else
        If fCartoon Then
            Ctl.BackColor = 16777215
            Ctl.BackStyle = 0
            Ctl.ForeColor = 0
        End If
    End If
    If (lStyleParts And 2) Then
        Ctl.FontName = rs!FontName
        Ctl.FontSize = rs!FontSize
        Ctl.FontWeight = rs!FontWeight
        Ctl.FontUnderline = rs!FontUnderline
        Ctl.FontItalic = rs!FontItalic
        If styl_fAppWizard Then
            If TypeOf Ctl Is Label Then
                Ctl.TextAlign = 1
            Else
                Ctl.TextAlign = rs!TextAlign
            End If
        Else
            Ctl.TextAlign = rs!TextAlign
        End If
    Else
        If fCartoon Then
            Ctl.FontName = wlib_StFromWlibIds(7)
            Ctl.FontSize = wlib_StFromWlibIds(8)
            Ctl.FontWeight = 400
            Ctl.FontUnderline = 0
            Ctl.FontItalic = 0
            Ctl.TextAlign = 0
        End If
    End If
    ErrApplyCS = 0
ErrApplyCS_Exit:
    Exit Function
ErrApplyCS_Err:
    If Err = 2455 Or Err = 438 Or Err = 2101 Or Err = 2125 Then
        Resume Next
    Else
        ErrApplyCS = Err
        Resume ErrApplyCS_Exit
    End If
End Function
Private Function ErrApplyDS(obj As Object, rs As Recordset, lStyleParts As Long) As Long
On Error GoTo ErrApplyDS_Err
    Dim stBitmapPath As String
    Dim stPicture As String
    Dim fApplyPictureProps As Integer
    ErrApplyDS = 0
    If (Not rs.EOF) Then
        If (lStyleParts = 16) Then GoTo ErrApplyDS_Exit
        obj.Picture = ""
        obj.PictureType = rs!PictureType
        If (rs!PictureType = 1) Or (Len(Nz(rs!PictureData, "")) = 0) Then
            stPicture = Nz(rs!Picture, "")
            If Len(stPicture) > 0 Then
                If wlib_StFileOfFullPath(stPicture) = stPicture Then
                    stBitmapPath = StAccessBitmapPath() & stPicture
                Else
                    stBitmapPath = stPicture
                End If
                If Len(Dir$(stBitmapPath)) = 0 Then
                    ErrApplyDS = 5006
                    styl_stBitmapPath = stBitmapPath
                    obj.Picture = ""
                Else
                    obj.Picture = stBitmapPath
                    obj.PaletteSource = stBitmapPath
                    fApplyPictureProps = True
                End If
            End If
        Else
            obj.PictureData = rs!PictureData
            obj.PaintPalette = rs!PicturePaletteData
            fApplyPictureProps = True
        End If
        If fApplyPictureProps Then
            obj.PictureAlignment = rs!PictureAlignment
            obj.PictureTiling = rs!PictureTiling
            obj.PictureSizeMode = rs!PictureSizeMode
            obj.SizeMode = rs!PictureSizeMode
        End If
        obj.RecordDividers = rs!RecordDividers
    Else
        obj.Picture = ""
        obj.RecordDividers = True
        ErrApplyDS = 5004
    End If
ErrApplyDS_Exit:
    Exit Function
ErrApplyDS_Err:
    If Err = 2455 Or Err = 2465 Or Err = 438 Or Err = 2101 Then
        Resume Next
    Else
        ErrApplyDS = Err
        Resume ErrApplyDS_Exit
    End If
End Function
Private Function StAccessBitmapPath() As String
    Static stPath As String
    If Len(stPath) = 0 Then stPath = Application.SysCmd(acSysCmdAccessDir) & "Bitmaps\Styles\"
    StAccessBitmapPath = stPath
End Function
Function ErrApplySS(obj As Object, rs As Recordset) As Long
On Error GoTo ErrApplySS_Err
    obj.BackColor = rs!BackColor
    obj.SpecialEffect = rs!SpecialEffect
ErrApplySS_Exit:
    Exit Function
ErrApplySS_Err:
    ErrApplySS = Err
    Resume ErrApplySS_Exit
End Function
Function styl_ErrApplySSFromCartoon(Ctl As Control, lStyleParts As Long, rs As Recordset) As Long
On Error GoTo styl_ErrApplySSFromCartoon_Err
    If Not (rs.NoMatch) Then
        styl_ErrApplySSFromCartoon = ErrApplySS(Ctl, rs)
    Else
        Ctl.BackColor = 16777215
        Ctl.SpecialEffect = 0
        styl_ErrApplySSFromCartoon = 5001
    End If
styl_ErrApplySSFromCartoon_Exit:
    Exit Function
styl_ErrApplySSFromCartoon_Err:
    styl_ErrApplySSFromCartoon = Err
    Resume styl_ErrApplySSFromCartoon_Exit
End Function
Function styl_ErrApplyDSFromCartoon(Ctl As Control, lStyleParts As Long) As Long
On Error GoTo styl_ErrApplyDSFromCartoon_Err
    styl_ErrApplyDSFromCartoon = ErrApplyDS(Ctl, styl_cart_rsSectionStyles, lStyleParts)
styl_ErrApplyDSFromCartoon_Exit:
    Exit Function
styl_ErrApplyDSFromCartoon_Err:
    styl_ErrApplyDSFromCartoon = Err
    Resume styl_ErrApplyDSFromCartoon_Exit
End Function
Function styl_ErrInitCartoon(iStyleType As Integer, lStyleID As Long, stMdtFile As String, stTopLevelFormName As String, Optional fAutoFormat, Optional stListCaption, Optional lHelpContextID, Optional stHelpFile) As Integer
On Error GoTo styl_ErrInitCartoon_Err
    Dim errReturn As Integer
    styl_iStyleType = iStyleType
    styl_lCartStyleID = lStyleID
    OpenDataDB stMdtFile
    If (iStyleType = acForm) Or (iStyleType = (acForm + acReport)) Then
        Set styl_cart_rsSectionStyles = styl_dbData.OpenRecordset("styl_qryCartSectionProperties", dbOpenDynaset)
        Set styl_cart_rsControlStyles = styl_dbData.OpenRecordset("styl_qryCartControlProperties", dbOpenDynaset)
    End If
    If (iStyleType = acReport) Or (iStyleType = (acForm + acReport)) Then
        Set styl_cart_rsRptStyles = styl_dbData.OpenRecordset("styl_qryCartRptProperties", dbOpenDynaset)
    End If
    errReturn = styl_GetDisplayInfo()
    If errReturn <> 0 Then
        styl_ErrInitCartoon = errReturn
        GoTo styl_ErrInitCartoon_Exit
    End If
    If Not IsMissing(fAutoFormat) Then styl_fAutoFormatCartoon = fAutoFormat
    If Not IsMissing(stListCaption) Then styl_stListCaption = stListCaption
    If Not IsMissing(lHelpContextID) Then styl_lHelpContextID = lHelpContextID
    If Not IsMissing(stHelpFile) Then styl_stHelpFile = stHelpFile
    styl_stTopLevelFormName = stTopLevelFormName
    styl_ErrInitCartoon = 0
styl_ErrInitCartoon_Exit:
    Exit Function
styl_ErrInitCartoon_Err:
    styl_ErrInitCartoon = Err
    Resume styl_ErrInitCartoon_Exit
End Function
Function styl_ErrUninitCartoon() As Integer
On Error Resume Next
    styl_cart_rsControlStyles.close
    styl_cart_rsSectionStyles.close
    styl_cart_rsRptStyles.close
On Error GoTo styl_ErrUnInitCartoon_Err
    CloseDataDB
    styl_fAutoFormatCartoon = False
    styl_stListCaption = ""
    styl_lHelpContextID = 0
    styl_stHelpFile = ""
styl_ErrUnInitCartoon_Exit:
    Exit Function
styl_ErrUnInitCartoon_Err:
    styl_ErrUninitCartoon = Err
    Resume styl_ErrUnInitCartoon_Exit
End Function
Function styl_ErrApplyCSFromCartoon(Ctl As Control, lStyleParts As Long, rs As Recordset) As Long
On Error GoTo styl_ErrApplyCSFromCartoon_Err
    styl_ErrApplyCSFromCartoon = 0
    If (Not rs.NoMatch) Then
        styl_ErrApplyCSFromCartoon = ErrApplyCS(Ctl, lStyleParts, rs, True)
    Else
        styl_ErrApplyCSFromCartoon = ErrApplyCS(Ctl, 0, rs, True)
    End If
styl_ErrApplyCSFromCartoon_Exit:
    Exit Function
styl_ErrApplyCSFromCartoon_Err:
    styl_ErrApplyCSFromCartoon = Err
    Resume styl_ErrApplyCSFromCartoon_Exit
End Function
Public Sub styl_SetCartoonStyle(lStyleID As Long, Optional iStyleType)
On Error Resume Next
    styl_lCartStyleID = lStyleID
    If Not IsMissing(iStyleType) Then styl_iStyleType = iStyleType
End Sub
Private Sub DxDyFromBorder(iBorderStyle As Integer, iBorderWidth As Integer, iSpecialEffect As Integer, dx As Long, dy As Long)
    If (iSpecialEffect <> 0) Then
        dx = (wlib_GetSystemMetrics(5) * styl_xTwipsPerPixel)
        dy = (wlib_GetSystemMetrics(6) * styl_yTwipsPerPixel)
        If iSpecialEffect = 4 Then
            dx = dx * 2
            dy = dy * 2
        End If
    ElseIf (iBorderStyle <> 0) And (iBorderWidth <> 0) Then
        dx = (iBorderWidth * 20)
        dy = (iBorderWidth * 20)
    Else
        dx = styl_xTwipsPerPixel
        dy = styl_yTwipsPerPixel
    End If
    dx = dx + (wlib_GetSystemMetrics(5) * styl_xTwipsPerPixel)
    dy = dy + (wlib_GetSystemMetrics(6) * styl_yTwipsPerPixel)
End Sub
Sub styl_CsiFromFontAndBorder(csi As STYL_CONTROLSIZINGINFO)
On Error GoTo styl_CsiFromFontAndBorder_Err
    Dim errReturn As Integer
    Dim dx As Long
    Dim dy As Long
    Dim pt As WLIB_POINT
    errReturn = styl_GetDisplayInfo()
    If errReturn <> 0 Then GoTo styl_CsiFromFontAndBorder_Exit
    If wlib_FTwipsFromFont(csi.stFontName, csi.iFontSize, csi.iFontWeight, csi.fFontItalic, csi.fFontUnderline, csi.cch, csi.stCaption, csi.cchUseMaxWidth, dx, dy) Then
        csi.dxLine = dx
        csi.dyLine = dy
    Else
        csi.dxLine = 0
        csi.dyLine = 0
    End If
    dx = 0
    dy = 0
    DxDyFromBorder csi.iBorderStyle, csi.iBorderWidth, csi.iSpecialEffect, dx, dy
    csi.dxBorder = dx
    csi.dyBorder = dy
styl_CsiFromFontAndBorder_Exit:
    Exit Sub
styl_CsiFromFontAndBorder_Err:
    wlib_HandleError Err, Error$
    Resume styl_CsiFromFontAndBorder_Exit
End Sub
Function styl_GetDisplayInfo()
On Error GoTo styl_GetDisplayInfo_Err
    Const LOGPIXELSY = 90
    Const LOGPIXELSX = 88
    Dim hDC As Long
    hDC = wlib_GetDC(0)
    If hDC = 0 Then GoTo styl_GetDisplayInfo_Err
    styl_xPixelPerInch = wlib_GetDeviceCaps(hDC, LOGPIXELSX)
    styl_yPixelPerInch = wlib_GetDeviceCaps(hDC, LOGPIXELSY)
    If styl_xPixelPerInch = 0 Or styl_yPixelPerInch = 0 Then GoTo styl_GetDisplayInfo_Err
    styl_xTwipsPerPixel = 1440& / styl_xPixelPerInch
    styl_yTwipsPerPixel = 1440& / styl_yPixelPerInch
    styl_GetDisplayInfo = 0
styl_GetDisplayInfo_Exit:
On Error Resume Next
    If hDC Then
        hDC = wlib_ReleaseDC(0, hDC)
        hDC = 0
    End If
    Exit Function
styl_GetDisplayInfo_Err:
    styl_GetDisplayInfo = 6002
    Resume styl_GetDisplayInfo_Exit
End Function

'---
Attribute VB_Name = "LBWiz_General"
Option Compare Database
Option Explicit
Global LBWiz_dbCode As Database
Global LBWiz_rsTblMsg As Recordset
Global LBWiz_rsTblArt As Recordset
Global LBWiz_iObjType As Integer
Global LBWiz_iObjMode As Integer
Global LBWiz_fLbl As Integer
Global LBWiz_frmUser As Form
Global LBWiz_rptUser As Report
Global LBWiz_stUserTable As String
Global LBWiz_ctlUser As Control
Global LBWiz_ctlLblUser As Control
Global LBWiz_fInitLrsi As Integer
Global LBWiz_hUsrObj As Long
Global LBWiz_fCancel As Integer
Global LBWiz_stLUProps As String
Global LBWiz_iPgInitMask As Integer
Global LBWiz_fCurDBOpened As Integer
Global LBWiz_fFPKErrInit As Integer
Global LBWiz_fLinkerInit As Integer
Global LBWiz_iCurPg As Integer
Dim LBWiz_fStartAddin As Integer
Type LBWIZ_FLDORDERSTRUCT
    fi As FPK_FLDINFO
    iOrder As Integer
End Type
Type LBWIZ_AUTOLUSTRUCT
    fAutoLUAvail As Integer
    fAutoLU As Integer
End Type
Type LBWiz_PropertiesStruct
    stSrcType As String
    iSrcType As Integer
    iCtlType As Integer
    stCtlTypeTxt As String
    TQBData As FPK_TQBDATA
    jpb As FPK_IJOINPARAMBLOCK
    jpbForm As FPK_IJOINPARAMBLOCK
    cFrmFlds As Integer
    stRwSrcStr As String
    stRecSrc As String
    iBndCol As Integer
    stColWidths As String
    rgColWidths(20) As Integer
    stLbl As String
    lCtlWidth As Long
    stSrcFld As String
    iBnd As Integer
    iCtlLeft As Integer
    fCueCards As Integer
    fiFindCol As FPK_FLDINFO
    alu As LBWIZ_AUTOLUSTRUCT
    fiBndCol As FPK_FLDINFO
    stOriginalFieldName As String
End Type
Global LBWiz_Props As LBWiz_PropertiesStruct
Global LBWiz_fValidPg
Function LBWiz_fSameFldInfo(fiA As FPK_FLDINFO, fiB As FPK_FLDINFO) As Integer
    If fiA.stName = fiB.stName Then
        If fiA.stRecSrc = fiB.stRecSrc Then
            If fiA.stSrcTbl = fiB.stSrcTbl Then
                If fiA.stSrcFld = fiB.stSrcFld Then
                    LBWiz_fSameFldInfo = True
                End If
            End If
        End If
    End If
End Function
Function LBWiz_fPgInitialized(iPg As Integer) As Integer
    LBWiz_fPgInitialized = (LBWiz_iPgInitMask And (2 ^ (iPg - 1))) <> 0
End Function
Sub LBWiz_SetPgInit(iPg As Integer, fInit As Integer)
    Dim iPgMask As Integer
    iPgMask = 2 ^ (iPg - 1)
    If LBWiz_iPgInitMask And iPgMask Then
        If Not (fInit) Then LBWiz_iPgInitMask = LBWiz_iPgInitMask - iPgMask
    Else
        If fInit Then LBWiz_iPgInitMask = LBWiz_iPgInitMask + iPgMask
    End If
End Sub
Sub LBWiz_RemoveFldInfoToArray(iPos As Integer, fiRemove As FPK_FLDINFO, rgfi() As FPK_FLDINFO)
    Dim cFi As Integer
    Dim iFld As Integer
    cFi = UBound(rgfi)
    fiRemove = rgfi(iPos)
    For iFld = iPos To cFi - 1
        rgfi(iFld) = rgfi(iFld + 1)
    Next iFld
    ReDim Preserve rgfi(0 To cFi - 1)
End Sub
Sub LBWiz_AddFldInfoToArray(iPos As Integer, fiInsert As FPK_FLDINFO, rgfi() As FPK_FLDINFO)
    Dim cFi As Integer
    Dim iFld As Integer
    cFi = UBound(rgfi)
    For iFld = cFi To (iPos + 1) Step -1
        rgfi(iFld) = rgfi(iFld - 1)
    Next iFld
    rgfi(iPos) = fiInsert
End Sub
Function Cmb_Entry(stCtlName As String, stLblName As String) As Variant
On Error GoTo Cmb_Entry_Err
    LBWiz_Props.iCtlType = 500
    LBWiz_LaunchWizard stCtlName, stLblName
Cmb_Entry_Exit:
    CloseObjects
    Exit Function
Cmb_Entry_Err:
    wlib_HandleError Err, Error$
    Resume Cmb_Entry_Exit
End Function
Sub LBWiz_LaunchWizard(stCtlName As String, stLblName As String)
    Set LBWiz_dbCode = CodeDb()
    wlib_OpenCurrentDB
    LBWiz_fCurDBOpened = True
    Set LBWiz_rsTblMsg = LBWiz_dbCode.OpenRecordset("LBWiz_tblMessages", dbOpenTable)
    LBWiz_rsTblMsg.Index = "PrimaryKey"
    wlib_StartAddIn (0 + LBWiz_Props.iCtlType), LBWiz_rsTblMsg, "Message"
    LBWiz_fStartAddin = True
    On Error GoTo LBWiz_LaunchWizard_Err
    Set LBWiz_rsTblArt = LBWiz_dbCode.OpenRecordset("LBWiz_tblArt", dbOpenTable, dbDenyWrite)
    On Error GoTo 0
    LBWiz_iObjType = Application.CurrentObjectType
    LBWiz_fLbl = (Len(stLblName) > 0)
    Select Case LBWiz_iObjType
        Case acForm
            Set LBWiz_frmUser = Screen.ActiveForm
            LBWiz_hUsrObj = LBWiz_frmUser.Hwnd
            LBWiz_Props.stRecSrc = Nz((LBWiz_frmUser.RecordSource), "")
            Set LBWiz_ctlUser = LBWiz_frmUser(stCtlName)
            If LBWiz_fLbl Then Set LBWiz_ctlLblUser = LBWiz_frmUser(stLblName)
            LBWiz_Props.stOriginalFieldName = ""
        Case acReport
            Set LBWiz_rptUser = Screen.ActiveReport
            LBWiz_hUsrObj = LBWiz_rptUser.Hwnd
            LBWiz_Props.stRecSrc = Nz((LBWiz_rptUser.RecordSource), "")
            Set LBWiz_ctlUser = LBWiz_rptUser(stCtlName)
            If LBWiz_fLbl Then Set LBWiz_ctlLblUser = LBWiz_rptUser(stLblName)
            LBWiz_Props.stOriginalFieldName = ""
        Case acTable
            LBWiz_hUsrObj = 0
            LBWiz_Props.stRecSrc = ""
            LBWiz_Props.stLbl = stCtlName
            LBWiz_Props.stOriginalFieldName = stCtlName
        Case Else
            Exit Sub
    End Select
    If LBWiz_Props.iCtlType = 700 Then
        LBWiz_Props.stSrcType = "Table/Query"
    Else
        LBWiz_Props.stSrcType = Nz(LBWiz_ctlUser.RowSourceType, "Table/Query")
    End If
    LBWiz_Props.stCtlTypeTxt = wlib_StFromIds(3 + LBWiz_Props.iCtlType)
    DoCmd.OpenForm "LBWiz_frmMain", , , , , acDialog
LBWiz_LaunchWizard_Exit:
    CloseObjects
    If LBWiz_fStartAddin Then
        wlib_EndAddIn
        LBWiz_fStartAddin = False
    End If
    Exit Sub
LBWiz_LaunchWizard_Err:
    wlib_HandleError 0, wlib_StFromIdsWithInsert(13, wlib_StFromIds(0 + LBWiz_Props.iCtlType))
    Resume LBWiz_LaunchWizard_Exit
End Sub
Function Lst_Entry(stCtlName As String, stLblName As String) As Variant
On Error GoTo Lst_Entry_Err
    LBWiz_Props.iCtlType = 0
    LBWiz_LaunchWizard stCtlName, stLblName
Lst_Entry_Exit:
    CloseObjects
    Exit Function
Lst_Entry_Err:
    wlib_HandleError Err, Error$
    Resume Lst_Entry_Exit
End Function
Private Sub CloseObjects()
On Error Resume Next
    LBWiz_rsTblMsg.close
    LBWiz_rsTblArt.close
    LBWiz_dbCode.close
    If LBWiz_fCurDBOpened Then
        wlib_CloseCurrentDB
        LBWiz_fCurDBOpened = False
    End If
    If LBWiz_fFPKErrInit Then
        fpk_ErrUninit
        LBWiz_fFPKErrInit = False
    End If
    If LBWiz_fLinkerInit Then
        fl_ErrUninitEngine
        LBWiz_fLinkerInit = False
    End If
    DoCmd.SetWarnings True
End Sub
Sub LBWiz_SetArt(frm As Form, ByVal iPage As Integer)
    Dim iArtNum As Integer
    iArtNum = LBWiz_Props.iCtlType + (iPage * 1000)
    Select Case iPage
        Case 1
            Select Case LBWiz_Props.iCtlType
                Case 0
                    iArtNum = 1000
                Case 500
                    iArtNum = 1500
                Case 700
                    iArtNum = 1500
            End Select
        Case 2
            Select Case LBWiz_Props.iCtlType
                Case 0
                    iArtNum = 2000
                Case 500
                    iArtNum = 2500
                Case 700
                    iArtNum = 2500
            End Select
        Case 3
                    Select Case LBWiz_Props.iCtlType
                Case 0
                    iArtNum = 3000
                Case 500
                    iArtNum = 3500
                Case 700
                    iArtNum = 3500
            End Select
        Case 4
            iArtNum = 0
        Case 5
            Select Case LBWiz_Props.iCtlType
                Case 0
                    iArtNum = 5000
                Case 500
                    iArtNum = 5500
                Case 700
                    iArtNum = 3500
            End Select
        Case 6
            Select Case LBWiz_Props.iCtlType
                Case 0
                    iArtNum = 6000
                Case 500
                    iArtNum = 6500
                Case 700
                    iArtNum = 6500
            End Select
        Case 7
            iArtNum = 7000
        Case Else
    End Select
    If iArtNum Then frm("ArtPg" & iPage).PictureData = LBWiz_rsTblArt("Art" & iArtNum)
End Sub
Function wzTDLookupBuilder(stTblName As String, stCtlName As String, stCall As String) As Variant
On Error GoTo wzTDLookupBuilder_Err
    Static stPrevCall As String
    Select Case stCall
        Case "0"
        Case "1", "2"
            stPrevCall = stCall
            If (stCall = "1") Then
                LBWiz_iObjMode = acDesign
            Else
                LBWiz_iObjMode = acDesign
            End If
            LBWiz_Props.iCtlType = 700
            LBWiz_stLUProps = ""
            LBWiz_stUserTable = stTblName
            LBWiz_LaunchWizard stCtlName, ""
            wzTDLookupBuilder = LBWiz_stLUProps
        Case "3"
            If (LBWiz_Props.jpb.fpkd.dbobj.iObjType = acTable) And (LBWiz_Props.iSrcType = 1) Then
                DoCmd.OpenForm "LBWiz_frmRelStatus", , , , , acDialog, (stPrevCall = "2")
            End If
    End Select
wzTDLookupBuilder_Exit:
    CloseObjects
    Exit Function
wzTDLookupBuilder_Err:
    wlib_HandleError Err, Error$
    Resume wzTDLookupBuilder_Exit
End Function
Function LBWiz_IObjTypeFromStRecSrc(stName As String) As Integer
On Error Resume Next
    Dim fTest As Boolean
    fTest = (wlib_dbCur.TableDefs(stName).Name = stName)
    If fTest Then
        LBWiz_IObjTypeFromStRecSrc = acTable
    Else
        fTest = (wlib_dbCur.QueryDefs(stName).Name = stName)
        If fTest Then
            LBWiz_IObjTypeFromStRecSrc = acQuery
        Else
            LBWiz_IObjTypeFromStRecSrc = -1
        End If
    End If
End Function
'---
Attribute VB_Name = "frwz_modEngine"
Option Compare Database
Option Explicit
Type FRWZ_SUBDOC_INFO
    stSourceObject As String
    stLinkChildFields As String
    stLinkMasterFields As String
End Type
Type FRWZ_CONTROL_INFO
    iControlType As Integer
    stControlName As String
    stControlSource As String
    dx As Long
    dy As Long
    fNoLabel As Boolean
    iSummaryInfo As Integer
    iLabelPos As Integer
    iDataType As Integer
    stCaption As String
    stFormat As String
    lAttributes As Long
    iDecimalPlaces As Integer
    rgprop() As FRST_PROPERTY
    cProps As Integer
End Type
Type FRWZ_STRIPE
    cControls As Integer
    dxSimTotal As Long
    dxSimCtls As Long
End Type
Type FRWZ_BLOCK
    iSection As Integer
    fVertical As Boolean
    fWrap As Boolean
    fAttachedLabels As Boolean
    fLabelsInHeader As Boolean
    dxCtlSepTks As Integer
    dyCtlSepTks As Integer
    dxIndentTks As Integer
    dyIndentTks As Integer
    dxMaxTks As Integer
    dyMaxTks As Integer
    iXAlign As Integer
    iYAlign As Integer
    cCtlStripeMax As Integer
    dxBoundingRectQtrTks As Integer
    rgci() As FRWZ_CONTROL_INFO
    cControls As Integer
    rgstrp() As FRWZ_STRIPE
    cStripes As Integer
End Type
Type FRWZ_GROUPLEVEL_INFO
    iGroupLevel As Integer
    stExpression As String
    fGroupHeader As Boolean
    fGroupFooter As Boolean
    fSortDesc As Boolean
    iGroupOn As Integer
    iGroupInterval As Integer
    iKeepTogether As Integer
End Type
Type FRWZ_PANE
    iDocType As Integer
    fMainPane As Boolean
    iParentPane As Integer
    iPaneContent As Integer
    iLayoutTemplate As Integer
    stDocName As String
    stCaption As String
    stRecordSource As String
    stLinkChildFields As String
    stLinkMasterFields As String
    stCode As String
    fHideDetail As Boolean
    iTargetDevice As Integer
    fFitToPage As Boolean
    cPageBreaks As Integer
    dyPageBreakTks As Integer
    rgblk() As FRWZ_BLOCK
    cBlocks As Integer
    rggl(0 To (10 - 1)) As FRWZ_GROUPLEVEL_INFO
    cGroupLevels As Integer
    rgprop() As FRST_PROPERTY
    cProps As Integer
End Type
Dim frwz_frmrptMain As Object
Dim frwz_iDocTypeMain As Integer
Dim frwz_frmrptPane As Object
Dim frwz_iDocTypePane As Integer
Dim frwz_cGrpHdrsPane As Integer
Dim frwz_cGrpFtrsPane As Integer
Dim frwz_fDocWithSubdocsPane As Boolean
Dim frwz_fSubReportPane As Boolean
Dim frwz_XTwipsPerTick As Integer
Dim frwz_YTwipsPerTick As Integer
Dim frwz_dxScreenOrPage As Integer
Dim frwz_dyScreenOrPage As Integer
Dim frwz_dxDocPane As Integer
Dim frwz_stLabelSuffix As String
Dim frwz_stGrandTotal As String
Dim frwz_stOf As String
Dim frwz_stBy As String
Dim frwz_cSectionsMax
Dim frwz_rgfSectionExists() As Boolean
Dim frwz_rgiTtbSection() As Integer
Dim frwz_fGrpHdrFldsInDetail As Boolean
Dim frwz_fShowDetailBorders As Boolean
Dim frwz_fDetLblPlacedPane As Boolean
Dim frwz_rgsdi() As FRWZ_SUBDOC_INFO
Dim frwz_cchDayOfWeekMax As Integer
Dim frwz_cchMonthMax As Integer
Dim frwz_dxLabelMaxBlk As Long
Dim frwz_dyLabelBlk As Long
Dim frwz_fLblSizeCalcedBlk As Boolean
Dim frwz_fFooterAggs As Boolean
Dim frwz_rgiAggSlots() As Integer
Dim frwz_rgfFtrTagCreated(10) As Boolean
Dim frwz_dyCtlFtr As Integer
Dim frwz_fGrandTotalLabelCreated As Boolean
Dim frwz_cLayoutFailures As Integer
Dim frwz_fDelaySave As Boolean
Function frwz_ErrCreateDoc(rgpn() As FRWZ_PANE, cPanes As Integer, lStyleID As Long, _
                           stPictureFile As String, iOpenMode As Integer, iGridX As Integer, iGridY As Integer, _
                           Optional vSubreport As Variant) As Long
On Error GoTo frwz_ErrCreateDoc_Err
    Dim iPane As Integer
    Dim errReturned As Integer
    Dim fSaveMainDoc As Boolean
    frst_InitLCID
    frwz_cLayoutFailures = 0
    Erase frwz_rgsdi
    frwz_XTwipsPerTick = 0
    frwz_YTwipsPerTick = 0
    frwz_iDocTypeMain = rgpn(0).iDocType
    fSaveMainDoc = (Len(rgpn(0).stDocName) > 0)
    If lStyleID = 0 Then lStyleID = styl_LDefaultStyle(rgpn(0).iDocType)
    errReturned = styl_ErrSelectStyle(lStyleID)
    If errReturned <> 0 Then Error errReturned
    If cPanes > 1 Then CacheSubdocCtlProps cPanes, rgpn()
    frwz_fGrpHdrFldsInDetail = ((rgpn(0).iDocType = acReport) And (rgpn(0).iLayoutTemplate = 10))
    frwz_fShowDetailBorders = ((rgpn(0).iDocType = acReport) And (rgpn(0).iLayoutTemplate = 10)) _
                              Or ((rgpn(0).iDocType = acReport) And (rgpn(0).iPaneContent = 1))
    For iPane = 0 To cPanes - 1
        CreatePane rgpn(iPane), cPanes, iGridX, iGridY, vSubreport
    Next iPane
    Set frwz_frmrptPane = frwz_frmrptMain
    If ((cPanes > 1) Or (frwz_fSubReportPane = False)) Then CreateDocHeaderAndFooter stPictureFile, rgpn(0).stCaption
    If frwz_iDocTypeMain = acReport Then
        If rgpn(0).iLayoutTemplate <> 0 Then
            If cPanes = 1 Then
                If frwz_cGrpHdrsPane > 0 Then
                    AdornDoc frwz_frmrptMain, frwz_iDocTypeMain, rgpn(0).iLayoutTemplate, frwz_cGrpHdrsPane
                Else
                    AdornDoc frwz_frmrptMain, frwz_iDocTypeMain, rgpn(0).iPaneContent, frwz_cGrpHdrsPane
                End If
            End If
        End If
    End If
    If frwz_cGrpHdrsPane > 0 Or frwz_cGrpFtrsPane > 0 Then
        If rgpn(0).fHideDetail Then frwz_frmrptMain.Section(0).Visible = False
    End If
    If rgpn(0).cPageBreaks Then CreatePageBreaks rgpn(0).cPageBreaks, rgpn(0).dyPageBreakTks
    Shutdown rgpn(0).stDocName, iOpenMode, rgpn(0).iPaneContent, fSaveMainDoc
    frwz_ErrCreateDoc = 0
frwz_ErrCreateDoc_Exit:
    Exit Function
frwz_ErrCreateDoc_Err:
    If (Err = 32000) And (cPanes = 1) Then
        On Error GoTo 0
        CleanupDoc rgpn(0)
        Shutdown rgpn(0).stDocName, iOpenMode, rgpn(0).iPaneContent, fSaveMainDoc
        frwz_ErrCreateDoc = 32000
    ElseIf (Err = 32001) Then
        DoCmd.close frwz_iDocTypeMain, frwz_frmrptMain.Name, acSaveNo
        frwz_ErrCreateDoc = 32001
    Else
        frwz_ErrCreateDoc = 31999
    End If
    Resume frwz_ErrCreateDoc_Exit
End Function
Function frwz_ErrInitEngine(stMdtFile As String, iDocType As Integer, fDelaySave As Boolean) As Long
On Error GoTo frwz_ErrInitEngine_Err
    Dim errReturned As Long
    errReturned = frst_ErrToggleDbAndRs(True)
    If errReturned <> 0 Then Error errReturned
    errReturned = styl_ErrInitEngine(stMdtFile)
    If (errReturned <> 0) Then
        frwz_ErrInitEngine = errReturned
        GoTo frwz_ErrInitEngine_Exit
    End If
    InitStrings (iDocType >= acReport)
    InitSectionLayoutOrder
    CalcDateCchs
    wlib_OpenCurrentDB
    frwz_fDelaySave = fDelaySave
    frwz_ErrInitEngine = 0
frwz_ErrInitEngine_Exit:
    Exit Function
frwz_ErrInitEngine_Err:
    frwz_ErrInitEngine = Err
    Resume frwz_ErrInitEngine_Exit
End Function
Private Sub InitSectionLayoutOrder()
    ReDim frwz_rgiTtbSection(0 To (25 - 1))
    frwz_rgiTtbSection(0) = 1
    frwz_rgiTtbSection(1) = 3
    frwz_rgiTtbSection(2) = 5
    frwz_rgiTtbSection(3) = 7
    frwz_rgiTtbSection(4) = 9
    frwz_rgiTtbSection(5) = 11
    frwz_rgiTtbSection(6) = 13
    frwz_rgiTtbSection(7) = 15
    frwz_rgiTtbSection(8) = 17
    frwz_rgiTtbSection(9) = 19
    frwz_rgiTtbSection(10) = 21
    frwz_rgiTtbSection(11) = 23
    frwz_rgiTtbSection(12) = 0
    frwz_rgiTtbSection(13) = 24
    frwz_rgiTtbSection(14) = 22
    frwz_rgiTtbSection(15) = 20
    frwz_rgiTtbSection(16) = 18
    frwz_rgiTtbSection(17) = 16
    frwz_rgiTtbSection(18) = 14
    frwz_rgiTtbSection(19) = 12
    frwz_rgiTtbSection(20) = 10
    frwz_rgiTtbSection(21) = 8
    frwz_rgiTtbSection(22) = 6
    frwz_rgiTtbSection(23) = 4
    frwz_rgiTtbSection(24) = 2
End Sub
Private Sub InitStrings(fInitTotalsStrings As Boolean)
    frwz_stLabelSuffix = wlib_StFromAccessIds(4370)
    If fInitTotalsStrings Then
        frwz_stGrandTotal = wlib_StFromRsIds(2021, frst_rsStrings, "String")
        frwz_stOf = wlib_StFromAccessIds(4709)
        frwz_stBy = wlib_StFromRsIds(2023, frst_rsStrings, "String")
        frst_PopulateAggFxnsArrays
    End If
End Sub
Function frwz_ErrUnInitEngine() As Long
On Error GoTo frwz_ErrUninitEngine_Err
    Dim errReturned As Long
    frwz_ErrUnInitEngine = styl_ErrUninitEngine()
    errReturned = frst_ErrToggleDbAndRs(False)
    If errReturned <> 0 Then Error errReturned
    frwz_fDelaySave = False
    frwz_ErrUnInitEngine = 0
frwz_ErrUninitEngine_Exit:
    wlib_CloseCurrentDB
    Exit Function
frwz_ErrUninitEngine_Err:
    frwz_ErrUnInitEngine = Err
    Resume frwz_ErrUninitEngine_Exit
End Function
Private Sub CreatePane(pn As FRWZ_PANE, cPanes As Integer, iGridX As Integer, iGridY As Integer, _
                       Optional vSubreport As Variant)
    Const C_TKSDEDUCTSUBREPT = 5
    Dim rcBlock As WLIB_RECT
    Dim iblkStartChain As Integer
    Dim iblkEndChain As Integer
    Dim iProp As Integer
    Dim dm As WLIB_PRTDEVMODE
    Dim stdm As WLIB_ST_PRTDEVMODE
    Dim errReturned As Integer
    frwz_cGrpHdrsPane = 0
    frwz_cGrpFtrsPane = 0
    frwz_fDetLblPlacedPane = False
    frwz_fDocWithSubdocsPane = False
    frwz_fFooterAggs = False
    frwz_fGrandTotalLabelCreated = False
    Erase frwz_rgfSectionExists
    Erase frwz_rgfFtrTagCreated
    Erase frwz_rgiAggSlots
    If Not (pn.iDocType = acForm Or pn.iDocType = acReport) Then
        frwz_iDocTypePane = frwz_iDocTypeMain
    Else
        frwz_iDocTypePane = pn.iDocType
    End If
    If Not IsMissing(vSubreport) Then
        frwz_fSubReportPane = vSubreport
    Else
        frwz_fSubReportPane = (frwz_iDocTypePane = acReport) And (pn.fMainPane = False)
    End If
    If Not (pn.fMainPane And pn.stDocName = "" And cPanes = 1) Then
        If Not -1 = wlib_ErrNameOK(wlib_dbCur, pn.iDocType, pn.stDocName) Then
            pn.stDocName = wlib_StUniqueDocName(pn.stDocName, pn.iDocType)
        End If
    End If
    Set frwz_frmrptPane = FrmRptNew(frwz_iDocTypePane)
    If pn.fMainPane Then Set frwz_frmrptMain = frwz_frmrptPane
    If (frwz_XTwipsPerTick = 0) Then
        If Not (iGridX >= 1 And iGridX <= 64) Or Not (iGridY >= 1 And iGridY <= 64) Then
            SetTwipsPerTick frwz_frmrptPane.GridX, frwz_frmrptPane.GridY
        Else
            SetTwipsPerTick iGridX, iGridY
            frwz_frmrptPane.GridX = iGridX
            frwz_frmrptPane.GridY = iGridY
        End If
    End If
    If pn.fMainPane Then
        If pn.iDocType = acForm Then
            frwz_dxScreenOrPage = IScreenExtent(True)
            If pn.cPageBreaks = 0 And pn.dyPageBreakTks > 0 Then
                frwz_dyScreenOrPage = pn.dyPageBreakTks * frwz_YTwipsPerTick
            Else
                frwz_dyScreenOrPage = IScreenExtent(False)
            End If
            pn.rgblk(0).dxMaxTks = frwz_dxScreenOrPage / frwz_XTwipsPerTick
            pn.rgblk(0).dyMaxTks = frwz_dyScreenOrPage / frwz_YTwipsPerTick - 2 * pn.rgblk(0).dyIndentTks
        Else
            If pn.iTargetDevice <> dm.iOrientation Then
                stdm.rgb = frwz_frmrptMain.PrtDevMode
                LSet dm = stdm
                dm.iOrientation = pn.iTargetDevice
                LSet stdm = dm
                frwz_frmrptMain.PrtDevMode = stdm.rgb
            End If
            frwz_dxScreenOrPage = frwz_frmrptPane.LogicalPageWidth
        End If
        If pn.fFitToPage Then
            frwz_dxDocPane = frwz_dxScreenOrPage
        Else
            frwz_dxDocPane = 31680
        End If
    Else
        If frwz_iDocTypeMain = acForm Then
            frwz_dxDocPane = 31680
        Else
            frwz_dxDocPane = frwz_dxScreenOrPage - (C_TKSDEDUCTSUBREPT * frwz_XTwipsPerTick)
        End If
    End If
    If pn.iLayoutTemplate = 9 Then
        PrepSubdocsLayout pn
        frwz_fDocWithSubdocsPane = True
    End If
    frwz_frmrptPane.Caption = pn.stCaption
    frwz_frmrptPane.RecordSource = pn.stRecordSource
    If frwz_iDocTypePane = acForm Then frwz_frmrptPane.DefaultView = IDefaultView(pn.fMainPane, pn.iPaneContent, cPanes)
    CreateSections pn
    frwz_frmrptPane.Width = 31680
    frwz_fDetLblPlacedPane = 0
    errReturned = styl_ErrApplyDefaultCS(frwz_frmrptPane)
    If (errReturned <> 0 And errReturned <> 5000) Then Error errReturned
    If pn.iPaneContent = 4 Then
        If pn.fMainPane Then
            LayoutFeJustifiedDoc pn
            GoTo CreatePane_PostLayout
        Else
            pn.iPaneContent = 1
        End If
    End If
    Do
        LayoutChain pn, iblkStartChain, iblkEndChain, rcBlock
        iblkStartChain = iblkEndChain + 1
    Loop Until iblkEndChain = pn.cBlocks - 1
CreatePane_PostLayout:
    CleanupDoc pn
    If Len(pn.stCode) Then frwz_frmrptPane.Module.InsertText pn.stCode & vbCrLf
    If pn.fMainPane Then
        If frwz_iDocTypePane = acForm Then
            frwz_frmrptPane.AutoCenter = True
        End If
    End If
    If pn.cProps > 0 Then
        On Error Resume Next
        For iProp = 0 To pn.cProps - 1
            With pn.rgprop(iProp)
                If .iSection = -1 Then
                    frwz_frmrptPane.Properties(.stName) = .stValue
                Else
                    frwz_frmrptPane.Section(.iSection).Properties(.stName) = .stValue
                End If
            End With
        Next iProp
        On Error GoTo 0
    End If
    styl_ErrApplyDS frwz_frmrptPane, &HFFFF
    If pn.fMainPane Then
        If cPanes > 1 Then SaveDoc frwz_iDocTypePane, frwz_frmrptPane.Name, pn.stDocName
    Else
        SaveAsAndCloseDoc frwz_iDocTypePane, frwz_frmrptPane.Name, pn.stDocName
    End If
End Sub
Private Sub CreateSections(pn As FRWZ_PANE)
    Dim iSection As Integer
    Dim errReturned As Integer
    Dim fHdrFtr As Integer
    DoCmd.SelectObject frwz_iDocTypePane, frwz_frmrptPane.Name
    fHdrFtr = styl_FSectionExists(frwz_frmrptPane, 1)
    If frwz_iDocTypePane = acForm Then
        If Not fHdrFtr Then
            DoCmd.DoMenuItem 3, 2, 11, , acMenuVer70
        End If
        frwz_cSectionsMax = 5
    Else
        If Not fHdrFtr Then
            DoCmd.DoMenuItem 7, 2, 11, , acMenuVer70
        End If
        If Not styl_FSectionExists(frwz_frmrptPane, 3) Then
            RunCommand acCmdPageHdrFtr
        End If
        frwz_cSectionsMax = 25
    End If
    ReDim frwz_rgfSectionExists(0 To (frwz_cSectionsMax - 1))
    frwz_rgfSectionExists(0) = True
    frwz_rgfSectionExists(1) = True
    frwz_rgfSectionExists(2) = True
    If frwz_iDocTypePane = acReport Then
        frwz_rgfSectionExists(3) = True
        frwz_rgfSectionExists(4) = True
    End If
    If pn.cGroupLevels Then CreateGroupLevels pn
    For iSection = 0 To frwz_cSectionsMax - 1
        If frwz_rgfSectionExists(iSection) Then
            errReturned = styl_ErrApplySS(frwz_frmrptPane, iSection, &HFFFF)
            If Not ((errReturned = 0) Or (errReturned = 5001)) Then
                Error errReturned
            End If
            frwz_frmrptPane.Section(iSection).Height = 8640
        End If
    Next iSection
End Sub
Private Sub CreateGroupLevels(pn As FRWZ_PANE)
On Error GoTo CreateGroupLevels_Err
    Const ERR_SGBOXOPEN = 2154
    Dim i As Integer
    Dim iGLIndex As Integer
    Dim fCreateFooter As Integer
    Dim cGrpHdrs As Integer
    Dim cGrpFtrs As Integer
    frwz_fFooterAggs = FSetAggSlots(pn)
    For i = 0 To pn.cGroupLevels - 1
        If pn.rggl(i).fGroupHeader Then
            cGrpHdrs = cGrpHdrs + 1
            frwz_rgfSectionExists(frwz_ISectionFromGL(i, True)) = True
        End If
        If (frwz_fFooterAggs And pn.rggl(i).fGroupHeader) Or (pn.rggl(i).fGroupFooter) Then
            fCreateFooter = True
            cGrpFtrs = cGrpFtrs + 1
            frwz_rgfSectionExists(frwz_ISectionFromGL(i, False)) = True
        Else
            fCreateFooter = False
        End If
CreateGL:
        iGLIndex = CreateGroupLevel(frwz_frmrptPane.Name, pn.rggl(i).stExpression, pn.rggl(i).fGroupHeader, _
                                    fCreateFooter)
        frwz_frmrptPane.GroupLevel(iGLIndex).SortOrder = pn.rggl(i).fSortDesc
        frwz_frmrptPane.GroupLevel(iGLIndex).GroupOn = pn.rggl(i).iGroupOn
        If pn.rggl(i).iGroupInterval = 0 Then
            frwz_frmrptPane.GroupLevel(iGLIndex).GroupInterval = 1
        Else
            frwz_frmrptPane.GroupLevel(iGLIndex).GroupInterval = pn.rggl(i).iGroupInterval
        End If
        frwz_frmrptPane.GroupLevel(iGLIndex).KeepTogether = pn.rggl(i).iKeepTogether
    Next i
    frwz_cGrpHdrsPane = cGrpHdrs
    frwz_cGrpFtrsPane = cGrpFtrs
CreateGroupLevels_Exit:
    Exit Sub
CreateGroupLevels_Err:
    If Err = ERR_SGBOXOPEN Then
        DoCmd.SelectObject acReport, frwz_frmrptPane.Name, False
        DoCmd.DoMenuItem 7, 2, 0, 0, acMenuVer70
        Resume CreateGL
    Else
        Resume CreateGroupLevels_Exit
    End If
End Sub
Private Sub LayoutChain(pn As FRWZ_PANE, iblkStartChain As Integer, iblkEndChain As Integer, rcBlock As WLIB_RECT)
    Dim fPrevDependence As Boolean
    Dim iblk As Integer
    Dim iStripe As Integer
    Dim iFirstCtl As Integer
    Dim dShrinkFactor As Double
    Dim dxFixedLabel As Integer
    Dim ictl As Integer
    Dim iLabelPos As Integer
    Dim xCtlMax As Integer
    iblk = iblkStartChain
    fPrevDependence = False
    Do
        If pn.rgblk(iblk).dxMaxTks = -1 Or pn.rgblk(iblk).dxMaxTks = 0 Then
            pn.rgblk(iblk).dxMaxTks = 31680 / frwz_XTwipsPerTick
        End If
        If pn.rgblk(iblk).dyMaxTks = -1 Or pn.rgblk(iblk).dyMaxTks = 0 Then
            pn.rgblk(iblk).dyMaxTks = 31680 / frwz_YTwipsPerTick
        End If
        If pn.fMainPane Then
            If pn.cPageBreaks Then
                pn.rgblk(iblk).dyMaxTks = wlib_Min(pn.rgblk(iblk).dyMaxTks, pn.dyPageBreakTks)
            End If
        End If
        SimLayoutBlock pn.rgblk(iblk)
    Loop Until Not FNextBlockXIsPrevDependent(iblk, pn, fPrevDependence)
    iblkEndChain = iblk - 1
    SetShrinkPolicy pn, iblkStartChain, iblkEndChain, dShrinkFactor
    xCtlMax = frwz_dxDocPane - frwz_XTwipsPerTick * 1
    For iblk = iblkStartChain To iblkEndChain
        If dShrinkFactor < 1 Then
            iFirstCtl = 0
            For iStripe = 0 To pn.rgblk(iblk).cStripes - 1
                CalcControlShrinkages pn.rgblk(iblk).rgstrp(iStripe), pn.rgblk(iblk), iFirstCtl, dShrinkFactor
                iFirstCtl = iFirstCtl + pn.rgblk(iblk).rgstrp(iStripe).cControls
            Next iStripe
            If pn.rgblk(iblk).fVertical Then
                If pn.rgblk(iblk).rgci(0).iControlType = acSubform Then
                    dxFixedLabel = 0
                Else
                    iLabelPos = styl_ILabelPosition(acTextBox, (pn.rgblk(iblk).iSection), frwz_frmrptPane)
                    If (iLabelPos = 0 Or iLabelPos = 2) Then
                        On Error Resume Next
                        For ictl = 0 To pn.rgblk(iblk).cControls - 1
                            dxFixedLabel = DxDyGridAligned(dShrinkFactor * frwz_frmrptPane.Controls(StLabelOfStCtl(pn.rgblk(iblk).rgci(ictl).stControlName)).Width, True)
                            If Err = 0 Then Exit For
                        Next ictl
                        If Err <> 0 Then
                            dxFixedLabel = 0
                        End If
                        On Error GoTo 0
                    End If
                End If
            End If
        Else
            dxFixedLabel = 0
        End If
        rcBlock = RcBlkNextFromRcBlkPrev(rcBlock, pn.rgblk(iblk), (pn.fMainPane And pn.cPageBreaks), pn.dyPageBreakTks)
        LayoutBlock pn.rgblk(iblk), rcBlock, (dShrinkFactor < 1), dxFixedLabel, xCtlMax, (iblk = iblkEndChain)
    Next iblk
End Sub
Private Sub SimLayoutBlock(blk As FRWZ_BLOCK)
    Const C_STRIPESMAXDEFAULT = 10
    Const I_RCBELOW = 0
    Const I_RCRIGHT = 1
    Dim Ctl As Control
    Dim ctlLabel As Control
    Dim rcStripe As WLIB_RECT
    ReDim rcAvailable(1) As WLIB_RECT
    Dim rcCtl As WLIB_RECT
    Dim iPrimary As Integer
    Dim iBackup As Integer
    Dim ictl As Integer
    Dim cStripes As Integer
    If Not blk.fVertical Then
        If blk.fWrap Then blk.fWrap = False
        blk.cCtlStripeMax = 1000
    End If
    If blk.cCtlStripeMax = 0 Then blk.cCtlStripeMax = 1000
    If blk.fVertical Then
        iPrimary = I_RCBELOW
        iBackup = I_RCRIGHT
    Else
        iPrimary = I_RCRIGHT
        iBackup = I_RCBELOW
    End If
    If blk.fVertical Or Not blk.fWrap Then
        rcAvailable(iPrimary).Right = 20000000
    Else
        rcAvailable(iPrimary).Right = blk.dxMaxTks * frwz_XTwipsPerTick
    End If
    rcAvailable(iPrimary).bottom = blk.dyMaxTks * frwz_YTwipsPerTick
    rcAvailable(iBackup) = rcAvailable(iPrimary)
    AnchorRect rcStripe, rcAvailable(iPrimary)
    ShiftRect rcAvailable(iPrimary), (blk.dxIndentTks * frwz_XTwipsPerTick), 0
    ReDim blk.rgstrp(0 To (C_STRIPESMAXDEFAULT - 1))
    cStripes = 1
    For ictl = 0 To blk.cControls - 1
        If blk.rgstrp(cStripes - 1).cControls > 0 Then
            If blk.fVertical Then
                If blk.dyCtlSepTks Then ShiftRect rcAvailable(iPrimary), 0, blk.dyCtlSepTks * frwz_YTwipsPerTick
            Else
                If blk.dxCtlSepTks Then ShiftRect rcAvailable(iPrimary), blk.dxCtlSepTks * frwz_XTwipsPerTick, 0
            End If
        End If
        CtlAndLblFromCi blk.rgci(ictl), blk.iSection, blk.fAttachedLabels, blk.fLabelsInHeader, Ctl, ctlLabel
        SizeControlFromControlType Ctl, blk.rgci(ictl)
        If Not ctlLabel Is Nothing Then
            If Not frwz_fLblSizeCalcedBlk Then
                CalcLabelExtents ctlLabel
                frwz_fLblSizeCalcedBlk = True
            End If
            SetLabelExtents ctlLabel, (blk.rgci(ictl).iLabelPos), blk.fAttachedLabels
        End If
        If Not blk.fAttachedLabels Then
            If Not ctlLabel Is Nothing Then
                If Ctl.Width > ctlLabel.Width Then
                    ctlLabel.Width = Ctl.Width
                ElseIf ctlLabel.Width > Ctl.Width Then
                    If Ctl.ControlType = acTextBox Then Ctl.Width = ctlLabel.Width
                End If
            End If
        End If
        rcCtl = RcDesired(Ctl, ctlLabel, blk.fAttachedLabels)
        AnchorRect rcCtl, rcAvailable(iPrimary)
        If (Not FWithin(rcCtl, rcAvailable(iPrimary))) Or (blk.rgstrp(cStripes - 1).cControls = blk.cCtlStripeMax) Then
            blk.rgstrp(cStripes - 1).dxSimTotal = rcStripe.Right - rcStripe.Left
            If Not blk.fWrap Then
                If Not blk.fAttachedLabels Then DeleteDocControl frwz_iDocTypePane, frwz_frmrptPane.Name, StLabelOfStCtl(Ctl.Name)
                DeleteDocControl frwz_iDocTypePane, frwz_frmrptPane.Name, Ctl.Name
                blk.cControls = ictl
                GoTo SimLayoutBlock_Conclude
            End If
            cStripes = cStripes + 1
            If cStripes > C_STRIPESMAXDEFAULT Then ReDim Preserve blk.rgstrp(0 To (cStripes - 1))
            CrowdRect rcAvailable(iBackup), rcStripe, (Not blk.fVertical)
            rcAvailable(iPrimary) = rcAvailable(iBackup)
            rcStripe.bottom = rcStripe.top
            rcStripe.Right = rcStripe.Left
            AnchorRect rcStripe, rcAvailable(iPrimary)
            If blk.fVertical Then ShiftRect rcAvailable(iPrimary), blk.dxCtlSepTks * frwz_XTwipsPerTick, 0
            If Not blk.fVertical Then ShiftRect rcAvailable(iPrimary), 0, blk.dyCtlSepTks * frwz_YTwipsPerTick
            If blk.fVertical And blk.dyIndentTks Then ShiftRect rcAvailable(iPrimary), 0, blk.dyIndentTks * frwz_YTwipsPerTick
            If Not blk.fVertical And blk.dxIndentTks Then ShiftRect rcAvailable(iPrimary), blk.dxIndentTks * frwz_XTwipsPerTick, 0
            AnchorRect rcCtl, rcAvailable(iPrimary)
            If Not FWithin(rcCtl, rcAvailable(iPrimary)) Then
                rcCtl.bottom = wlib_Min(rcCtl.bottom, blk.dyMaxTks * frwz_YTwipsPerTick)
            End If
        End If
        If (rcStripe.Right < rcCtl.Right) Then rcStripe.Right = rcCtl.Right
        If (rcStripe.bottom < rcCtl.bottom) Then rcStripe.bottom = rcCtl.bottom
        CrowdRect rcAvailable(iPrimary), rcStripe, blk.fVertical
        If blk.fVertical Or (ctlLabel Is Nothing) Then
            blk.rgci(ictl).dx = rcCtl.Right - rcCtl.Left
        Else
            blk.rgci(ictl).dx = wlib_Max(rcCtl.Right - rcCtl.Left, ctlLabel.Width)
        End If
        If Not frwz_fDocWithSubdocsPane Then
            blk.rgci(ictl).dy = rcCtl.bottom - rcCtl.top
        ElseIf Not (blk.rgci(ictl).iControlType = acSubform) Then
            blk.rgci(ictl).dy = rcCtl.bottom - rcCtl.top
        End If
        If blk.fVertical Then
            blk.rgstrp(cStripes - 1).dxSimCtls = wlib_Max(blk.rgstrp(cStripes - 1).dxSimCtls, blk.rgci(ictl).dx)
        Else
            blk.rgstrp(cStripes - 1).dxSimCtls = blk.rgstrp(cStripes - 1).dxSimCtls + blk.rgci(ictl).dx
        End If
        blk.rgstrp(cStripes - 1).cControls = blk.rgstrp(cStripes - 1).cControls + 1
    Next ictl
SimLayoutBlock_Conclude:
    blk.rgstrp(cStripes - 1).dxSimTotal = rcStripe.Right - rcStripe.Left
    blk.cStripes = cStripes
    frwz_fLblSizeCalcedBlk = False
End Sub
Private Sub SetShrinkPolicy(pn As FRWZ_PANE, iStart As Integer, iEnd As Integer, dShrinkFactor As Double)
    Const DX_CONTROLSMIN = 2880
    Const D_SHRINKFACTORMIN = 0.25
    Const D_FUDGE = 0.02
    Dim xLeftEdge As Long
    Dim iblk As Integer
    Dim iStripe As Integer
    Dim dxTotalSim As Long
    Dim dxCtlsSim As Long
    Dim dxEmptySim As Long
    Dim dxAcceptableMin As Long
    Dim dxCurAvail As Integer
    xLeftEdge = pn.rgblk(iStart).dxIndentTks * frwz_XTwipsPerTick
    For iblk = iStart To iEnd
        For iStripe = 0 To pn.rgblk(iblk).cStripes - 1
            dxCtlsSim = dxCtlsSim + pn.rgblk(iblk).rgstrp(iStripe).dxSimCtls
            dxTotalSim = dxTotalSim + pn.rgblk(iblk).rgstrp(iStripe).dxSimTotal
        Next iStripe
    Next iblk
    dxCurAvail = frwz_dxDocPane - xLeftEdge - (1 * frwz_XTwipsPerTick)
    dxEmptySim = dxTotalSim - dxCtlsSim
    dxAcceptableMin = dxEmptySim + DX_CONTROLSMIN
    If dxTotalSim > dxCurAvail Then
        If pn.fFitToPage And (xLeftEdge + dxAcceptableMin) <= frwz_dxDocPane Then
            GoSub SetShrinkPolicy_CalcShrinkFactor
            If dShrinkFactor < D_SHRINKFACTORMIN Then GoTo SetShrinkPolicy_LastGasp
        ElseIf (xLeftEdge + dxTotalSim) <= 31680 Then
            frwz_dxDocPane = xLeftEdge + dxTotalSim
            dShrinkFactor = 1
        ElseIf (xLeftEdge + dxAcceptableMin) <= 31680 Then
            GoTo SetShrinkPolicy_LastGasp
        Else
            Error 32001
        End If
    Else
        dShrinkFactor = 1
    End If
SetShrinkPolicy_Exit:
    Exit Sub
SetShrinkPolicy_CalcShrinkFactor:
    dShrinkFactor = 1 - ((dxTotalSim - (frwz_dxDocPane - xLeftEdge)) / dxCtlsSim)
    Return
SetShrinkPolicy_LastGasp:
    frwz_dxDocPane = 31680
    GoSub SetShrinkPolicy_CalcShrinkFactor
    If dShrinkFactor >= (D_SHRINKFACTORMIN) Then
        dShrinkFactor = dShrinkFactor - D_FUDGE
    Else
        Error 32001
    End If
End Sub
Private Sub CalcControlShrinkages(strp As FRWZ_STRIPE, blk As FRWZ_BLOCK, iFirstCtl As Integer, dShrinkFactor As Double)
    Dim ictl As Integer
    Dim dxCutoff As Integer
    dxCutoff = DxDyGridAligned(dShrinkFactor * strp.dxSimCtls, True)
    For ictl = iFirstCtl To iFirstCtl + strp.cControls - 1
        If blk.fVertical Then
            blk.rgci(ictl).dx = wlib_Min(dxCutoff, DxDyGridAligned(blk.rgci(ictl).dx, True))
        Else
            blk.rgci(ictl).dx = DxDyGridAligned(dShrinkFactor * blk.rgci(ictl).dx, True)
        End If
    Next ictl
End Sub
Private Sub LayoutBlock(blk As FRWZ_BLOCK, rcBlock As WLIB_RECT, fShrink As Boolean, dxFixedLabel As Integer, _
                        xCtlMax As Integer, fLastBlockInChain As Boolean)
    Dim ictl As Integer
    Dim iStripe As Integer
    Dim iCtlFirst As Integer
    Dim errReturned As Integer
    Dim Ctl As Control
    Dim ctlLabel As Control
    Static yDetLabel As Integer
    Dim rcCtl As WLIB_RECT
    Dim rcLbl As WLIB_RECT
    Dim rcActual As WLIB_RECT
    Dim pt As WLIB_POINT
    Dim dxLabel As Integer
    Dim dyLabel As Integer
    Dim xLabel As Integer
    Dim yLabel As Integer
    Dim iGL As Integer
    Dim isectDetLbls As Integer
    Dim dysectDetLbls As Integer
    Dim dxBrOffset As Integer
    Dim yCtlScreenMax As Long
    If frwz_iDocTypePane = acReport Then
        If frwz_fFooterAggs Then
            iGL = IglFromSection(blk.iSection)
            If iGL <> -99 Then
                If Not frwz_rgfFtrTagCreated(iGL) Then
                    CreateFooterTagForAggs iGL, frwz_ISectionFromGL(iGL, False), rcBlock.Left
                End If
            End If
        End If
    End If
    If Not blk.fAttachedLabels Then
        If Not frwz_fDetLblPlacedPane Then
            On Error Resume Next
            Do
                Set ctlLabel = frwz_frmrptPane.Controls(StLabelOfStCtl(blk.rgci(ictl).stControlName))
                ictl = ictl + 1
            Loop Until (Not (ctlLabel Is Nothing)) Or (ictl = blk.cControls)
            On Error GoTo 0
            If Not (ctlLabel Is Nothing) Then
                isectDetLbls = ILabelSection(blk.iSection, blk.fAttachedLabels, blk.fLabelsInHeader)
                frwz_frmrptPane.Section(isectDetLbls).Height = 0
                dysectDetLbls = frwz_frmrptPane.Section(isectDetLbls).Height
                If dysectDetLbls > ctlLabel.Height Then
                    yDetLabel = (Int((dysectDetLbls / frwz_YTwipsPerTick) + 1) + blk.dyCtlSepTks) * frwz_YTwipsPerTick
                Else
                    yDetLabel = 1 * frwz_YTwipsPerTick
                End If
                frwz_frmrptPane.Section(isectDetLbls).Height = 31680
                frwz_fDetLblPlacedPane = True
            End If
        End If
    End If
    pt.x = DxDyGridAligned(rcBlock.Left, True, 0)
    pt.y = DxDyGridAligned(rcBlock.top, False, 0)
    rcActual.Left = pt.x
    rcActual.top = pt.y
    For iStripe = 0 To blk.cStripes - 1
        For ictl = iCtlFirst To iCtlFirst + blk.rgstrp(iStripe).cControls - 1
            Set Ctl = frwz_frmrptPane.Controls(blk.rgci(ictl).stControlName)
            If Not blk.rgci(ictl).fNoLabel Then
                Set ctlLabel = frwz_frmrptPane.Controls(StLabelOfStCtl(blk.rgci(ictl).stControlName))
            Else
                Set ctlLabel = Nothing
            End If
            rcCtl.Left = pt.x
            rcCtl.top = pt.y
            rcCtl.Right = rcCtl.Left + blk.rgci(ictl).dx
            rcCtl.bottom = rcCtl.top + blk.rgci(ictl).dy
            If fShrink Then
                If blk.fVertical Then
                    rcCtl.Left = wlib_Min(rcCtl.Left, xCtlMax)
                    rcCtl.Right = wlib_Min(rcCtl.Right, xCtlMax)
                Else
                    If fLastBlockInChain Then
                        If (ictl = blk.cControls - 1) Then
                            rcCtl.Right = xCtlMax
                        Else
                            rcCtl.Left = wlib_Min(rcCtl.Left, xCtlMax)
                            rcCtl.Right = wlib_Min(rcCtl.Right, xCtlMax)
                        End If
                    End If
                End If
            End If
            If blk.fAttachedLabels Then
                If Not blk.rgci(ictl).fNoLabel Then
                    If fShrink Then
                        If dxFixedLabel > 0 Then
                            ctlLabel.Width = dxFixedLabel
                        Else
                            ctlLabel.Width = wlib_Min(ctlLabel.Width, Ctl.Width)
                        End If
                    End If
                End If
                errReturned = styl_ErrPlaceControlsFromData(Ctl, ctlLabel, rcCtl, rcCtl, frwz_frmrptPane, _
                                                            blk.rgci(ictl).iControlType, blk.iSection)
                If errReturned <> 0 Then
                    CleanupLayoutFailure Ctl, ctlLabel
                    GoTo LayoutBlock_NextControl
                End If
                If Ctl.ControlType = acSubform Then
                    If frwz_dyScreenOrPage Then
                        If (blk.iSection = 0) Then
                            If frwz_iDocTypePane = acForm Then
                                If Not yCtlScreenMax Then yCtlScreenMax = _
                                                            (frwz_dyScreenOrPage - frwz_YTwipsPerTick * 1)
                                If Ctl.top < yCtlScreenMax Then
                                    If Ctl.top + Ctl.Height > yCtlScreenMax Then
                                        Ctl.Height = yCtlScreenMax - Ctl.top
                                    End If
                                End If
                            End If
                        End If
                    End If
                End If
            Else
                errReturned = styl_ErrPlaceControlsFromData(Ctl, Nothing, rcCtl, rcCtl, frwz_frmrptPane, _
                                                            blk.rgci(ictl).iControlType, blk.iSection)
                If errReturned <> 0 Then
                    CleanupLayoutFailure Ctl, ctlLabel
                    GoTo LayoutBlock_NextControl
                Else
                    If Not ctlLabel Is Nothing Then
                        rcLbl = rcCtl
                        rcLbl.top = yDetLabel
                        rcLbl.bottom = rcLbl.top + ctlLabel.Height
                        errReturned = styl_ErrPlaceControlsFromData(ctlLabel, Nothing, rcLbl, rcLbl, frwz_frmrptPane, _
                                                                blk.rgci(ictl).iControlType, isectDetLbls)
                        If errReturned <> 0 Then CleanupLayoutFailure Ctl, ctlLabel
                    End If
                End If
            End If
            If blk.rgci(ictl).iSummaryInfo Then
                CreateAggSetsFromCi Ctl, blk.rgci(ictl)
            End If
            If Not ctlLabel Is Nothing Then
                dxLabel = ctlLabel.Width
                dyLabel = ctlLabel.Height
                xLabel = ctlLabel.Left
                yLabel = ctlLabel.top
            End If
            On Error Resume Next
            If blk.fVertical Then
                If Not blk.rgci(ictl).fNoLabel Then
                    pt.y = DxDyGridAligned(wlib_Max(Ctl.top + Ctl.Height, yLabel + dyLabel) + blk.dyCtlSepTks * frwz_YTwipsPerTick, False)
                Else
                    pt.y = DxDyGridAligned(Ctl.top + Ctl.Height + (blk.dyCtlSepTks * frwz_YTwipsPerTick), False)
                End If
            Else
                If Not blk.rgci(ictl).fNoLabel Then
                    pt.x = wlib_Max(Ctl.Left + Ctl.Width, xLabel + dxLabel) + blk.dxCtlSepTks * frwz_XTwipsPerTick
                Else
                    pt.x = Ctl.Left + Ctl.Width + blk.dxCtlSepTks * frwz_XTwipsPerTick
                End If
            End If
            rcActual.Right = wlib_Max(rcActual.Right, wlib_Max(Ctl.Left + Ctl.Width, xLabel + dxLabel))
            rcActual.bottom = wlib_Max(rcActual.bottom, wlib_Max(Ctl.top + Ctl.Height, yLabel + dyLabel))
            On Error GoTo 0
LayoutBlock_NextControl:
        Next ictl
        If blk.fVertical Then
            pt.x = rcActual.Right + blk.dxCtlSepTks * frwz_XTwipsPerTick
            pt.y = rcActual.top
        Else
            pt.x = rcActual.Left
            pt.y = rcActual.bottom + blk.dyCtlSepTks * frwz_YTwipsPerTick
        End If
        iCtlFirst = ictl
    Next iStripe
    If blk.dxBoundingRectQtrTks Then CtlBoundingRect rcActual, blk.dxBoundingRectQtrTks, blk.iSection
    rcBlock = rcActual
End Sub
Private Sub CleanupLayoutFailure(Ctl As Control, ctlLabel As Control)
    Const C_LAYOUTFAILURESMAX = 5
    If Not ctlLabel Is Nothing Then DeleteDocControl frwz_iDocTypePane, frwz_frmrptPane.Name, ctlLabel.Name
    If Not Ctl Is Nothing Then DeleteDocControl frwz_iDocTypePane, frwz_frmrptPane.Name, Ctl.Name
    frwz_cLayoutFailures = frwz_cLayoutFailures + 1
    If frwz_cLayoutFailures > C_LAYOUTFAILURESMAX Then Error 32000
End Sub
Private Sub CreateAggSetsFromCi(Ctl As Control, ci As FRWZ_CONTROL_INFO)
    Dim iAgg As Integer
    Dim x As Long
    Dim dx As Long
    Dim ctlGT As Control
    Dim stGTCtlSrc As String
    Dim stGTCtlName As String
    Dim iGTAgg As Integer
    x = Ctl.Left
    dx = Ctl.Width
    If (ci.iSummaryInfo And (2 ^ 0)) Or (ci.iSummaryInfo And (2 ^ 4)) Then
        Select Case ci.iDataType
            Case dbText, dbBoolean, dbDate, -999
                iGTAgg = 4
            Case dbByte, dbInteger, dbLong, dbCurrency, dbSingle, dbDouble
                iGTAgg = 0
        End Select
        stGTCtlSrc = StAggFieldCtlSrc(ci.stControlSource, iGTAgg, "")
        If iGTAgg = 0 Then
            If frst_LCID = 1041 Or frst_LCID = 1028 Or frst_LCID = 1042 Or frst_LCID = 2052 Then
                stGTCtlName = Left$(ci.stControlName, 64 - _
                          Len(frwz_stGrandTotal)) & frwz_stGrandTotal & frst_rgstAggFxnsLcl(0)
            Else
                stGTCtlName = Left$(ci.stControlName, 64 - _
                          Len(frwz_stGrandTotal)) & " " & frwz_stGrandTotal & " " & frst_rgstAggFxnsLcl(0)
            End If
        Else
            If frst_LCID = 1041 Or frst_LCID = 1028 Or frst_LCID = 1042 Or frst_LCID = 2052 Then
                stGTCtlName = Left$(ci.stControlName, 64 - _
                          Len(frwz_stGrandTotal)) & frwz_stGrandTotal & frst_rgstAggFxnsLcl(4)
            Else
                stGTCtlName = Left$(ci.stControlName, 64 - _
                          Len(frwz_stGrandTotal)) & " " & frwz_stGrandTotal & " " & frst_rgstAggFxnsLcl(4)
            End If
        End If
        stGTCtlName = wlib_StUniqueControlName((frwz_frmrptPane.Name), frwz_iDocTypePane, stGTCtlName)
        Set ctlGT = CtlNew(acTextBox, 2, "", stGTCtlName, stGTCtlSrc, "", x, 0, dx, 0, True)
        SizeControlFromCchOrCaption ctlGT, 0, ""
        ctlGT.Width = Ctl.Width
        ctlGT.Format = ci.stFormat
        If ci.iDecimalPlaces <> -1 Then ctlGT.DecimalPlaces = ci.iDecimalPlaces
        If Not frwz_fGrandTotalLabelCreated Then Set ctlGT = CtlNew(acLabel, 2, "", "", "", frwz_stGrandTotal, (frwz_XTwipsPerTick), 0, -1, 0, True)
        SizeControlFromCchOrCaption ctlGT, 0, ctlGT.Caption
    End If
    For iAgg = 0 To 9
        If (ci.iSummaryInfo And (2 ^ iAgg)) Then
            If ci.iDataType = dbText Then
                Select Case iAgg
                    Case 0, 1, 5, 6
                            Exit Sub
                End Select
            End If
            Create1AggSetFromCiIagg iAgg, x, dx, frwz_rgiAggSlots(iAgg), stGTCtlName, ci
        End If
    Next iAgg
End Sub
Private Sub Create1AggSetFromCiIagg(iAgg As Integer, x As Long, dx As Long, cSlots As Integer, stGTCtlName As String, _
                                       ci As FRWZ_CONTROL_INFO)
    Const CCH_UNUSED = 20
    Dim iGL As Integer
    Dim iFooter As Integer
    Dim StGrpExpr As String
    Dim stAggField As String
    Dim stctlsrcAggField As String
    Dim ctlAgg As Control
    stctlsrcAggField = StAggFieldCtlSrc(ci.stControlSource, iAgg, stGTCtlName)
    For iGL = (frwz_cGrpFtrsPane - 1) To 0 Step -1
        iFooter = frwz_ISectionFromGL(iGL, False)
        StGrpExpr = frwz_frmrptPane.GroupLevel(iGL).ControlSource
        If frst_LCID = 1041 Or frst_LCID = 1028 Or frst_LCID = 1042 Or frst_LCID = 2052 Then
        stAggField = Left$(ci.stControlName, 64 - Len(frst_rgstAggFxnsLcl(iAgg)) - Len(frwz_stOf)) & frwz_stOf & _
                     frst_rgstAggFxnsLcl(iAgg)
        Else
            stAggField = frst_rgstAggFxnsLcl(iAgg) & " " & frwz_stOf & " " & _
                     Left$(ci.stControlName, 64 - Len(frst_rgstAggFxnsLcl(iAgg)) - Len(frwz_stOf))
        End If
        stAggField = wlib_StUniqueControlName((frwz_frmrptPane.Name), frwz_iDocTypePane, stAggField)
        Set ctlAgg = CtlNew(acTextBox, iFooter, "", stAggField, stctlsrcAggField, "", x, 0, dx, 0, True)
        ctlAgg.Height = frwz_dyCtlFtr
        ctlAgg.top = cSlots * frwz_dyCtlFtr
        If iAgg = 4 Then
            ctlAgg.Format = "Fixed"
            ctlAgg.DecimalPlaces = 0
        ElseIf iAgg = 9 Then
            ctlAgg.Format = "Percent"
        Else
            ctlAgg.Format = ci.stFormat
            If ci.iDecimalPlaces <> -1 Then ctlAgg.DecimalPlaces = ci.iDecimalPlaces
        End If
    Next iGL
End Sub
Private Sub CreateFooterTagForAggs(iGL As Integer, iSection As Integer, xCtl As Long)
    Const CCH_FOOTERTAG = 100
    Dim ctlFooterTag As Control
    Dim stctlsrcFooterTag As String
    Dim iAgg As Integer
    Dim ctlAggFxnLabel As Control
    stctlsrcFooterTag = StFooterTagCtlSrc((frwz_frmrptPane.GroupLevel(iGL).ControlSource))
    Set ctlFooterTag = CtlNew(acTextBox, iSection, "", "", stctlsrcFooterTag, "", xCtl, 0, _
                                      -1, 0, True)
    ctlFooterTag.Width = (frwz_dxDocPane - frwz_XTwipsPerTick * 1) - ctlFooterTag.Left
    For iAgg = 0 To 9
        If frwz_rgiAggSlots(iAgg) Then
            Set ctlAggFxnLabel = CtlNew(acLabel, iSection, "", "", "", frst_rgstAggFxnsLcl(iAgg), _
                                        xCtl, 0, -1, 0, True)
            SizeControlFromCchOrCaption ctlAggFxnLabel, 0, ctlAggFxnLabel.Caption
            ctlAggFxnLabel.top = frwz_rgiAggSlots(iAgg) * ctlAggFxnLabel.Height
        End If
    Next iAgg
    frwz_dyCtlFtr = ctlAggFxnLabel.Height
    frwz_rgfFtrTagCreated(iGL) = True
End Sub
Private Function StAggFieldCtlSrc(ByVal stCtlSrc As String, iAgg As Integer, stGTCtlName As String) As String
    Dim stLeftBracket As String
    Dim stRightBracket As String
    If Left$(stCtlSrc, 1) = "=" Then stCtlSrc = Right$(stCtlSrc, Len(stCtlSrc) - 1)
    If Left$(stCtlSrc, 1) <> "[" Then
        stLeftBracket = "["
        stRightBracket = "]"
        stCtlSrc = frst_StReplaceDot(stCtlSrc, "].[")
    Else
    End If
    If iAgg = 9 Then
        StAggFieldCtlSrc = "=Sum(" & stLeftBracket & stCtlSrc & stRightBracket & ")/" & "([" & stGTCtlName & "])"
    Else
        StAggFieldCtlSrc = "=" & frst_rgstAggFxns(iAgg) & "(" & stLeftBracket & stCtlSrc & stRightBracket & ")"
    End If
End Function
Private Function StFooterTagCtlSrc(StGrpExpr As String) As String
    Const AMP = "&"
    Dim st As String
    Dim stExpr As String
    Dim stCrLf As String
    Dim stQ1 As String
    Dim stQ2 As String
    stCrLf = Chr$(13) & Chr$(10)
    stQ1 = Chr$(39)
    stQ2 = Chr$(34)
    If InStr(StGrpExpr, "[") Then
        stExpr = StGrpExpr
    Else
        stExpr = "[" & StGrpExpr & "]"
    End If
         st = "=" & stQ2 & wlib_StFromRsIds(2024, frst_rsStrings, "String") & " " & stQ2 & " " & AMP & " "
    st = st & stQ2 & stQ1 & StGrpExpr & stQ1 & " = " & stQ2 & " " & AMP & " " & stQ2 & " " & stQ2 & " " & AMP & " " & stExpr & " " & AMP & " "
    st = st & stQ2 & " (" & stQ2 & " " & AMP & " "
    st = st & "Count(*) " & AMP & " " & stQ2 & " " & stQ2 & " " & AMP & " " & "IIf(Count(*) = 1, "
    st = st & stQ2 & wlib_StFromRsIds(2025, frst_rsStrings, "String") & stQ2 & ", "
    st = st & stQ2 & wlib_StFromRsIds(2026, frst_rsStrings, "String") & stQ2 & ") " & AMP & " " & stQ2 & ")" & stQ2
    StFooterTagCtlSrc = st
End Function
Private Function CtlBoundingRect(rc As WLIB_RECT, dxBoundingRectQtrTks As Integer, iSection As Integer) As Control
    Dim Ctl As Control
    Dim dxBrOffset As Integer
    If dxBoundingRectQtrTks > 0 Then
        dxBrOffset = (wlib_Min(8, dxBoundingRectQtrTks) / 4) * frwz_XTwipsPerTick
    End If
    Set Ctl = CtlNew(acRectangle, iSection, "", "", "", "", _
                     wlib_Max(0, (rc.Left - dxBrOffset)), _
                     wlib_Max(0, (rc.top - dxBrOffset)), _
                     wlib_Min(31680, (rc.Right - rc.Left) + 2 * dxBrOffset), _
                     wlib_Min(31680, (rc.bottom - rc.top) + 2 * dxBrOffset), _
                     False)
    Ctl.BackStyle = 0
    Set CtlBoundingRect = Ctl
End Function
Private Function ErrApplyCS(Ctl As Control, Optional vControlSection As Variant) As Long
    Dim lStyleParts As Long
    Dim errReturned As Integer
    If Ctl.Section = 0 Then
        lStyleParts = 0
    Else
        lStyleParts = &HFFFF
    End If
    errReturned = styl_ErrApplyCS(Ctl, Ctl.ControlType, lStyleParts, frwz_frmrptPane, vControlSection)
    If (errReturned = 5000) Then
        errReturned = styl_ErrApplyCS(Ctl, acTextBox, &HFFFF, frwz_frmrptPane, vControlSection)
        ErrApplyCS = 5000
    End If
    If Not ((errReturned = 0) Or (errReturned = 5000)) Then
        Error errReturned
    End If
End Function
Private Sub CacheSubdocCtlProps(cPanes As Integer, rgpn() As FRWZ_PANE)
    Dim iPane As Integer
    ReDim frwz_rgsdi(1 To (cPanes - 1))
    For iPane = 1 To (cPanes - 1)
        frwz_rgsdi(iPane).stSourceObject = rgpn(iPane).stDocName
        frwz_rgsdi(iPane).stLinkChildFields = rgpn(iPane).stLinkChildFields
        frwz_rgsdi(iPane).stLinkMasterFields = rgpn(iPane).stLinkMasterFields
    Next iPane
End Sub
Private Sub CleanupDoc(pn As FRWZ_PANE)
    Dim iSection As Integer
    Dim dy As Integer
    For iSection = 0 To (frwz_cSectionsMax - 1)
        If frwz_rgfSectionExists(iSection) Then
            frwz_frmrptPane.Section(iSection).Height = 0
            If Not (frwz_fGrpHdrFldsInDetail And iSection = 0) Then
                If frwz_frmrptPane.Section(iSection).Height > 0 Then
                    If ((iSection = 0) And pn.rgblk(0).dyIndentTks) Then
                        dy = frwz_frmrptPane.Section(iSection).Height + frwz_YTwipsPerTick * pn.rgblk(0).dyIndentTks
                        If frwz_iDocTypePane = acForm Then dy = wlib_Min(dy, frwz_dyScreenOrPage)
                    Else
                        dy = frwz_frmrptPane.Section(iSection).Height + frwz_YTwipsPerTick * 1
                    End If
                    frwz_frmrptPane.Section(iSection).Height = wlib_Min(dy, 31680)
                End If
            End If
        End If
    Next iSection
    frwz_frmrptPane.Width = 0
    If (frwz_iDocTypePane = acReport) And (frwz_fSubReportPane = False) And (frwz_frmrptPane.Width < frwz_dxScreenOrPage) Then
        frwz_frmrptPane.Width = frwz_dxScreenOrPage
    Else
        frwz_frmrptPane.Width = wlib_Min(frwz_frmrptPane.Width + frwz_XTwipsPerTick * 1, 31680)
    End If
End Sub
Private Sub CreateDocHeaderAndFooter(stPictureFile As String, stViewCaption As String)
    Const DX_PICTURE = 1080
    Const DY_PICTURE = 1080
    Const DX_FTRCTLMAX = 5040
    Const I_SMSTRETCH = 1
    Const I_TALEFT = 1
    Const I_TARIGHT = 3
    Const CTKS_DXSEP = 1
    Const CTKS_DYSEP = 1
    Const CTKS_WSHDR = 6
    Const CTKS_WSFTR = 3
    Dim Ctl As Control
    Dim xCtl As Long
    Dim yCtl As Long
    Dim dxCtlSepUnit As Integer
    Dim dyCtlSepUnit As Integer
    Dim stctlsrcPgFld As String
    Dim dxFtrCtl As Long
    dxCtlSepUnit = frwz_XTwipsPerTick * CTKS_DXSEP
    dyCtlSepUnit = frwz_YTwipsPerTick * CTKS_DYSEP
    xCtl = dxCtlSepUnit
    yCtl = dyCtlSepUnit
    If Len(stPictureFile) Then
        Set Ctl = CtlNew(acImage, 1, "", "", "", "", xCtl, yCtl, DX_PICTURE, DY_PICTURE, False)
        Ctl.Picture = stPictureFile
        Ctl.SizeMode = I_SMSTRETCH
        xCtl = Ctl.Left + Ctl.Width + dxCtlSepUnit
    End If
    If frwz_iDocTypeMain = acReport Then
        If Len(stViewCaption) Then
            Set Ctl = CtlNew(acLabel, 1, "", "", "", stViewCaption, xCtl, yCtl, -1, 0, True)
            SizeControlFromCchOrCaption Ctl, 0, stViewCaption
            yCtl = Ctl.top + Ctl.Height + dyCtlSepUnit
        End If
        frwz_frmrptPane.Section(1).Height = frwz_frmrptPane.Section(1).Height + (CTKS_WSHDR * frwz_YTwipsPerTick)
        xCtl = dxCtlSepUnit
        yCtl = dyCtlSepUnit + (CTKS_WSFTR * frwz_YTwipsPerTick)
        dxFtrCtl = wlib_Min(DX_FTRCTLMAX, ((frwz_frmrptMain.Width / 2) - 2 * dxCtlSepUnit))
        Set Ctl = CtlNew(acTextBox, 4, "", "", "=Now()", "", xCtl, yCtl, -1, 0, True)
        Ctl.Format = "Long Date"
        Ctl.TextAlign = I_TALEFT
        SizeControlFromCchOrCaption Ctl, CchFromDateFormat(Ctl.Format), "", , dxFtrCtl
        Select Case frst_LCID
            Case 1041, 1042
                stctlsrcPgFld = "=" & " [Page] " & Chr$(38) & " " & Chr$(34) & " " & wlib_StFromRsIds(2028, frst_rsStrings, "String") _
                                & " " & Chr$(34) & " " & Chr$(38) & " [Pages]" _
                                & " " & Chr$(38) & Chr$(34) & " " & wlib_StFromRsIds(2027, frst_rsStrings, "String") & Chr$(34)
            Case Else
                stctlsrcPgFld = "=" & Chr$(34) & wlib_StFromRsIds(2027, frst_rsStrings, "String") _
                        & " " & Chr$(34) & " " & Chr$(38) & " [Page] " & Chr$(38) & " " & Chr$(34) & " " _
                        & wlib_StFromRsIds(2028, frst_rsStrings, "String") _
                        & " " & Chr$(34) & " " & Chr$(38) & " [Pages]"
        End Select
        Set Ctl = CtlNew(acTextBox, 4, "", "", stctlsrcPgFld, "", xCtl, yCtl, -1, 0, True)
        SizeControlFromCchOrCaption Ctl, Len(stctlsrcPgFld), "", , dxFtrCtl
        Ctl.Left = frwz_frmrptMain.Width - dxCtlSepUnit - Ctl.Width
        Ctl.TextAlign = I_TARIGHT
    End If
End Sub
Private Function IScreenExtent(fWidth As Boolean) As Integer
    Const DX_MIN = 2880
    Const DX_DEFAULT = 7920
    Const DY_MIN = 2880
    Const DY_DEFAULT = 4320
    Dim stValueName As String
    If fWidth Then
        stValueName = "Form Width"
    Else
        stValueName = "Form Height"
    End If
    If fWidth Then
        IScreenExtent = frst_LFromStRegValue(acForm, stValueName, DX_MIN, 31680, DX_DEFAULT)
    Else
        IScreenExtent = frst_LFromStRegValue(acForm, stValueName, DY_MIN, 31680, DY_DEFAULT)
    End If
End Function
Private Sub PrepSubdocsLayout(pn As FRWZ_PANE)
    Const D_PCTMAIN1 = 0.5
    Const D_PCTMAIN2 = 0.25
    Const C_SUBDOCSVISIBLE = 2
    Dim cSubdocs As Integer
    Dim dyTotalTks As Integer
    Dim dyCtlSubdoc As Integer
    Dim ictl As Integer
    cSubdocs = pn.rgblk(1).cControls
    dyTotalTks = pn.rgblk(0).dyMaxTks
    If cSubdocs = 1 Then
        pn.rgblk(0).dyMaxTks = D_PCTMAIN1 * dyTotalTks
        dyCtlSubdoc = (dyTotalTks - pn.rgblk(0).dyMaxTks) * frwz_YTwipsPerTick
    ElseIf cSubdocs > 1 Then
        pn.rgblk(0).dyMaxTks = D_PCTMAIN2 * dyTotalTks
        dyCtlSubdoc = (dyTotalTks - pn.rgblk(0).dyMaxTks) * frwz_YTwipsPerTick / C_SUBDOCSVISIBLE
    End If
    For ictl = 0 To cSubdocs - 1
        pn.rgblk(1).rgci(ictl).dx = pn.rgblk(0).dxMaxTks * frwz_XTwipsPerTick
        pn.rgblk(1).rgci(ictl).dy = dyCtlSubdoc
    Next ictl
End Sub
Private Sub CrowdRect(rcCrowded As WLIB_RECT, rc As WLIB_RECT, fCrowdDown As Boolean)
    If fCrowdDown Then
        If (rcCrowded.top < rc.bottom) Then rcCrowded.top = DxDyGridAligned(rc.bottom, False)
    Else
        If (rcCrowded.Left < rc.Right) Then rcCrowded.Left = DxDyGridAligned(rc.Right, True)
    End If
End Sub
Private Sub CalcDateCchs()
    Dim iDay As Integer
    Dim cchDay As Integer
    Dim iMonth As Integer
    Dim cchMonth As Integer
    Dim i As Integer
    Dim st As String
    For i = 1 To 7
        st = Format$(i, "dddd")
        If Len(st) > cchDay Then
            iDay = i
            cchDay = Len(st)
        End If
    Next i
    frwz_cchDayOfWeekMax = cchDay
    For i = 1 To 12
        st = Format$(i * 30, "mmmm")
        If Len(st) > cchMonth Then
            iMonth = i
            cchMonth = Len(st)
        End If
    Next i
    frwz_cchMonthMax = cchMonth
End Sub
Private Function DxDyGridAligned(dxdy As Long, fWidth As Boolean, Optional vTksRoundUp As Variant) As Long
    If IsMissing(vTksRoundUp) Then vTksRoundUp = 1
    If fWidth Then
        DxDyGridAligned = Int((dxdy / frwz_XTwipsPerTick) + vTksRoundUp) * frwz_XTwipsPerTick
    Else
        DxDyGridAligned = Int((dxdy / frwz_YTwipsPerTick) + vTksRoundUp) * frwz_YTwipsPerTick
    End If
End Function
Private Function FNextBlockXIsPrevDependent(iblk As Integer, pn As FRWZ_PANE, fPrevDependence As Boolean)
    iblk = iblk + 1
    If iblk <= pn.cBlocks - 1 Then
        If pn.rgblk(iblk).iXAlign = 2 Then
            fPrevDependence = True
            FNextBlockXIsPrevDependent = True
        End If
        If fPrevDependence And pn.rgblk(iblk).iXAlign = 1 Then
            FNextBlockXIsPrevDependent = True
        End If
    End If
End Function
Private Sub SetTwipsPerTick(iGridX As Integer, iGridY As Integer)
    If wlib_FEnglishMeasurements Then
        frwz_XTwipsPerTick = 1440& / iGridX
        frwz_YTwipsPerTick = 1440& / iGridY
    Else
        frwz_XTwipsPerTick = 567 / iGridX
        frwz_YTwipsPerTick = 567 / iGridY
    End If
End Sub
Private Function IglFromSection(iSection As Integer) As Integer
    If Not (iSection >= 5 And iSection <= 24) Then
        IglFromSection = -99
        Exit Function
    End If
    IglFromSection = (iSection - 5) \ 2
End Function
Function frwz_ISectionFromGL(iGL As Integer, fHeader As Boolean) As Integer
    frwz_ISectionFromGL = 5 + (iGL * 2) + (fHeader + 1)
End Function
Private Function FSetAggSlots(pn As FRWZ_PANE) As Boolean
    Dim iAgg As Integer
    Dim cAggSlots As Integer
    Dim fIAggExists As Boolean
    Dim iblk As Integer
    Dim ici As Integer
    ReDim frwz_rgiAggSlots(0 To 9)
    For iAgg = 0 To 9
        fIAggExists = False
        For iblk = 0 To pn.cBlocks - 1
            If pn.rgblk(iblk).iSection = 0 Then
                For ici = 0 To pn.rgblk(iblk).cControls - 1
                    If (pn.rgblk(iblk).rgci(ici).iSummaryInfo) And (2 ^ iAgg) Then
                        cAggSlots = cAggSlots + 1
                        frwz_rgiAggSlots(iAgg) = cAggSlots
                        fIAggExists = True
                        Exit For
                    End If
                Next ici
            End If
            If fIAggExists Then Exit For
        Next iblk
    Next iAgg
    If cAggSlots Then FSetAggSlots = True
End Function
Private Function FWithin(rc1 As WLIB_RECT, rc2 As WLIB_RECT) As Boolean
    If rc1.bottom <= rc2.bottom And rc1.Right <= rc2.Right Then
        FWithin = True
    End If
End Function
Private Function RcBlkNextFromRcBlkPrev(rcPrev As WLIB_RECT, blk As FRWZ_BLOCK, fPageBreaks As Boolean, _
                                        dyPageBreakTks As Integer) As WLIB_RECT
    Dim rcNext As WLIB_RECT
    Select Case blk.iXAlign
        Case 0
            rcNext.Left = 0
        Case 1
            rcNext.Left = rcPrev.Left
        Case 2
            rcNext.Left = rcPrev.Right
    End Select
    Select Case blk.iYAlign
        Case 0
            rcNext.top = 0
        Case 1
            rcNext.top = rcPrev.top
        Case 2
            rcNext.top = rcPrev.bottom
            If fPageBreaks Then
                If rcNext.top > 0 Then rcNext.top = (Int(rcNext.top / (dyPageBreakTks * frwz_YTwipsPerTick)) + 1) * (dyPageBreakTks * frwz_YTwipsPerTick)
            End If
    End Select
    rcNext.Left = rcNext.Left + blk.dxIndentTks * frwz_XTwipsPerTick
    rcNext.top = rcNext.top + blk.dyIndentTks * frwz_YTwipsPerTick
    rcNext.Right = rcNext.Left + blk.dxMaxTks * frwz_XTwipsPerTick
    rcNext.bottom = rcNext.top + blk.dyMaxTks * frwz_YTwipsPerTick
    If rcNext.Right > 31680 Then rcNext.Right = 31680
    If rcNext.bottom > 31680 Then rcNext.bottom = 31680
    RcBlkNextFromRcBlkPrev = rcNext
End Function
Private Function RcDesired(Ctl As Control, ctlLabel As Control, fAttachedLabels As Boolean) As WLIB_RECT
    Dim rc As WLIB_RECT
    Dim dx As Long
    Dim dy As Long
    Dim errReturned As Integer
    If fAttachedLabels And (Not ctlLabel Is Nothing) Then
        errReturned = styl_ErrGetPlacementRectFromData(Ctl, ctlLabel, rc)
        If errReturned <> 0 Then Error errReturned
    Else
        If Ctl.ControlType = acPageBreak Then
            dx = 0
            dy = 0
        Else
            If ctlLabel Is Nothing Then
                dx = Ctl.Width
            Else
                dx = wlib_Max(Ctl.Width, ctlLabel.Width)
            End If
            dy = Ctl.Height
        End If
        rc.Right = rc.Left + dx
        rc.bottom = rc.top + dy
    End If
    RcDesired = rc
End Function
Private Sub CalcLabelExtents(ctlLabel As Control)
    SizeControlFromCchOrCaption ctlLabel, frst_LFromStRegValue(frwz_iDocTypePane, "Fixed Label Characters", 1, 100, 20), ""
    frwz_dxLabelMaxBlk = ctlLabel.Width
    frwz_dyLabelBlk = ctlLabel.Height
End Sub
Private Function IPaneFromStDocName(stDocName As String) As Integer
    Dim iPane As Integer
    For iPane = LBound(frwz_rgsdi) To UBound(frwz_rgsdi)
        If frwz_rgsdi(iPane).stSourceObject = stDocName Then
            IPaneFromStDocName = iPane
            Exit For
        End If
    Next iPane
End Function
Private Sub CtlAndLblFromCi(ci As FRWZ_CONTROL_INFO, ByVal iSection As Integer, fAttachedLabels As Boolean, _
                            fLabelsInHeader As Boolean, Ctl As Control, ctlLabel As Control)
    Const X_RIGHTLABEL = 3000
    Dim fGrpHdrFldInDetail As Boolean
    Dim stParent As String
    Dim stCaption As String
    Dim iSectionLbl As Integer
    Dim ipnSubDoc As Integer
    Dim iProp As Integer
    Dim errReturned As Integer
    If Not FValidControlType(ci.iControlType) Then
        If ci.iDataType = dbLongBinary Then
            ci.iControlType = acBoundObjectFrame
        Else
            ci.iControlType = acTextBox
        End If
    End If
    If ci.iControlType = acSubform Then ipnSubDoc = IPaneFromStDocName(ci.stControlName)
    If ci.stControlName <> "" Then
        ci.stControlName = wlib_StUniqueControlName((frwz_frmrptPane.Name), frwz_iDocTypePane, ci.stControlName)
    End If
    If frwz_fGrpHdrFldsInDetail Then
        If iSection <> 0 Then
            iSection = 0
            fGrpHdrFldInDetail = True
        End If
    End If
    Set Ctl = CtlNew(ci.iControlType, iSection, "", ci.stControlName, ci.stControlSource, "", 0, 0, _
                     -1, 0, False)
    If Len(ci.stControlName) = 0 Then ci.stControlName = Ctl.Name
    If (ci.iControlType = acLabel) Or (ci.iControlType = acCommandButton) Or (ci.iControlType = acToggleButton) Then
        Ctl.Caption = Nz(ci.stCaption, "")
        ci.fNoLabel = True
    End If
    If Not FCanHaveLabel(ci.iControlType) Then ci.fNoLabel = True
    If Not ci.fNoLabel Then
        If fAttachedLabels Then
            stParent = Ctl.Name
        Else
            stParent = ""
        End If
        If ci.stCaption <> "" Then
             stCaption = ci.stCaption
        Else
             stCaption = ci.stControlName
        End If
        iSectionLbl = ILabelSection(iSection, fAttachedLabels, fLabelsInHeader)
        Set ctlLabel = CtlNew(acLabel, iSectionLbl, stParent, StLabelOfStCtl(ci.stControlName), "", stCaption, 0, 0, _
                              -1, 0, False)
        If (Not fAttachedLabels) Then ctlLabel.Tag = "DetachedLabel"
    Else
        Set ctlLabel = Nothing
    End If
    If Not ctlLabel Is Nothing Then
        If frwz_fSubReportPane Then
            ErrApplyCS ctlLabel, 3
        Else
            ErrApplyCS ctlLabel
        End If
    End If
    If ErrApplyCS(Ctl) = 5000 Then
        ci.iControlType = acTextBox
    End If
    ci.iLabelPos = styl_ILabelPosition(ci.iControlType, iSection, frwz_frmrptPane)
    If (ci.iControlType <> acTextBox) Then
        If (ci.iControlType <> acSubform) Then
            If ci.iLabelPos = -1 Then
                ci.iLabelPos = styl_ILabelPosition(acTextBox, iSection, frwz_frmrptPane)
            End If
        End If
    End If
    If (Not fAttachedLabels) Then
        If Not ctlLabel Is Nothing Then
            Select Case ci.iDataType
                Case dbBoolean, dbByte, dbInteger, dbLong, dbCurrency, dbSingle, dbDouble, dbDate, -999
                    If Ctl.ControlType = acTextBox Then
                        ctlLabel.TextAlign = 3
                        ctlLabel.Left = X_RIGHTLABEL
                    Else
                        ctlLabel.TextAlign = 1
                    End If
                Case Else
                    ctlLabel.TextAlign = 1
            End Select
        End If
    End If
    If iSection = 0 Then
        If frwz_fShowDetailBorders Then
            Ctl.BorderStyle = 1
        End If
    End If
    If fGrpHdrFldInDetail Then Ctl.HideDuplicates = True
    If Ctl.ControlType = acSubform Then
        If ipnSubDoc > 0 Then
            Ctl.SourceObject = frwz_rgsdi(ipnSubDoc).stSourceObject
            Ctl.LinkChildFields = frwz_rgsdi(ipnSubDoc).stLinkChildFields
            Ctl.LinkMasterFields = frwz_rgsdi(ipnSubDoc).stLinkMasterFields
            If frwz_iDocTypePane = acReport Then frwz_frmrptPane.Section(iSection).CanGrow = True
        End If
    End If
    On Error Resume Next
    If (ci.lAttributes And dbHyperlinkField) Then
        Ctl.FontUnderline = Application.GetOption("Underline Hyperlinks")
        Ctl.ForeColor = 1279872587
    End If
    If Len(ci.stFormat) > 0 Then Ctl.Format = ci.stFormat
    If ci.iDecimalPlaces <> -1 Then Ctl.DecimalPlaces = ci.iDecimalPlaces
    If ci.cProps > 0 Then
        For iProp = 0 To ci.cProps - 1
            Ctl.Properties(ci.rgprop(iProp).stName) = ci.rgprop(iProp).stValue
        Next iProp
    End If
    On Error GoTo 0
End Sub
Private Function ILabelSection(iSection As Integer, fAttachedLabels As Boolean, fLabelsInHeader As Boolean) As Integer
    If fAttachedLabels Then
        ILabelSection = iSection
    ElseIf fLabelsInHeader Then
        If frwz_iDocTypePane = acForm Then
            ILabelSection = 1
        ElseIf frwz_fSubReportPane Then
            ILabelSection = 1
        ElseIf frwz_iDocTypePane = acReport Then
            ILabelSection = 3
        End If
    Else
        ILabelSection = ISectionAbove(iSection)
    End If
End Function
Private Function ISectionAbove(iSection As Integer) As Integer
    Const NULL_SECTION = -1
    Dim i As Integer
    Dim iRet As Integer
    iRet = NULL_SECTION
    If iSection = 1 Then
        iRet = 1
        GoTo ISectionAbove_Exit
    End If
    For i = (ISectionLayoutOrder(iSection) - 1) To 0 Step -1
        If frwz_rgfSectionExists(frwz_rgiTtbSection(i)) Then
            iRet = frwz_rgiTtbSection(i)
            GoTo ISectionAbove_Exit
        End If
    Next i
ISectionAbove_Exit:
    ISectionAbove = iRet
    Exit Function
End Function
Private Function ISectionLayoutOrder(iSection As Integer) As Integer
    Dim i As Integer
    Do Until frwz_rgiTtbSection(i) = iSection
        i = i + 1
    Loop
    ISectionLayoutOrder = i
End Function
Private Sub SizeControlFromControlType(Ctl As Control, ci As FRWZ_CONTROL_INFO)
    Select Case Ctl.ControlType
        Case acTextBox, acComboBox, acListBox
            If ci.dx <= 0 And ci.dy <= 0 Then
                SizeTextControl Ctl, ci
            Else
                SizeControlFromCiDxDy Ctl, ci
            End If
        Case acLabel
            If ci.dx > 0 Or ci.dy > 0 Then
                SizeControlFromCiDxDy Ctl, ci
            ElseIf Len(Ctl.Caption) Then
                SizeControlFromCchOrCaption Ctl, 0, Ctl.Caption
            End If
        Case acCommandButton, acToggleButton
            If ci.dx > 0 And ci.dy > 0 Then
                SetControlWidthAndHeight Ctl, ci.dx, ci.dy
            ElseIf Len(Ctl.Caption) Then
                SizeControlFromCchOrCaption Ctl, 0, Ctl.Caption
                If ci.dx > 0 Then SetControlWidthAndHeight Ctl, ci.dx, Ctl.Height
            End If
        Case acLine, acRectangle
            If (ci.dx <> 0) Or (ci.dy <> 0) Then SetControlWidthAndHeight Ctl, Abs(ci.dx), Abs(ci.dy)
        Case acPageBreak
        Case Else
            If ci.dx > 0 And ci.dy > 0 Then
                SetControlWidthAndHeight Ctl, ci.dx, ci.dy
            End If
    End Select
End Sub
Private Sub SizeControlFromCiDxDy(Ctl As Control, ci As FRWZ_CONTROL_INFO)
    Dim dxdy As WLIB_POINT
    If ci.dx > 0 And ci.dy <= 0 Then
        dxdy = DxDyCtlFromFontAndCch(Ctl, 0, Abs(ci.dy))
        SetControlWidthAndHeight Ctl, ci.dx, dxdy.y
    ElseIf ci.dx <= 0 And ci.dy > 0 Then
        dxdy = DxDyCtlFromFontAndCch(Ctl, Abs(ci.dx), 0)
        SetControlWidthAndHeight Ctl, dxdy.x, ci.dy
    ElseIf ci.dx > 0 And ci.dy > 0 Then
        SetControlWidthAndHeight Ctl, ci.dx, ci.dy
    End If
End Sub
Private Sub SizeTextControl(Ctl As Control, ci As FRWZ_CONTROL_INFO)
    Const I_SBVERTONLY = 2
    Const CCH_TDFLDSIZEDEFAULT = 50
    Const CCH_TEXTBOX = 30
    Const C_LINESTEXTBOXMAX = 2
    Const CCH_MEMO = 60
    Const C_LINESMEMO = 4
    Const C_LINESLISTBOX = 8
    Const CCH_AGGDIGITS = 3
    Const DX_DSCOLWIDTHMAX = 3000
    Dim cLines As Integer
    Dim cchCtl As Integer
    Dim stCaption As String
    Dim fMultiLine As Boolean
    If ci.dx < 0 Then
        ci.dx = Abs(ci.dx)
    End If
    If ci.dy < 0 Then
        ci.dy = Abs(ci.dy)
        cLines = ci.dy
    End If
    If Ctl.ControlType = acListBox Then
        cchCtl = CCH_TEXTBOX
        If cLines = 0 Then cLines = C_LINESLISTBOX
    End If
    If Ctl.ControlType = acComboBox Then
        cchCtl = CCH_TEXTBOX
        If cLines = 0 Then cLines = 1
    End If
    If cLines = 0 Then cLines = 1
    If cchCtl = 0 Then
        Select Case ci.iDataType
            Case -999
                stCaption = "(" & wlib_StFromAccessIds(7508) & ")"
            Case dbText
                If (ci.dx = CCH_TDFLDSIZEDEFAULT) Or (ci.dx = 0) Then ci.dx = CCH_TEXTBOX
                If ci.dx < CCH_MEMO Then
                    cchCtl = ci.dx
                Else
                    cchCtl = CCH_MEMO
                    If frwz_iDocTypePane = acForm Then cLines = wlib_Min(C_LINESTEXTBOXMAX, 1 + ci.dx \ (cchCtl + 1))
                    fMultiLine = (cLines > 1)
                End If
            Case dbBoolean
                cchCtl = wlib_Max(Len(Format$(True, ci.stFormat)), Len(Format$(False, ci.stFormat)))
            Case dbByte, dbInteger, dbLong, dbSingle, dbDouble, dbCurrency
                cchCtl = CchFromNumericCi(ci)
                If (ci.iSummaryInfo) Then cchCtl = cchCtl + CCH_AGGDIGITS
            Case dbDate
                cchCtl = CchFromDateFormat(ci.stFormat)
            Case dbMemo
                If ci.dx > 0 Then
                    cchCtl = ci.dx
                Else
                    If (ci.lAttributes And dbHyperlinkField) Then
                        cchCtl = CCH_TEXTBOX
                    Else
                        cchCtl = CCH_MEMO
                        fMultiLine = True
                    End If
                End If
                If frwz_iDocTypePane = acForm Then
                    If ci.dy Then
                        cLines = ci.dy
                    Else
                        If (ci.lAttributes And dbHyperlinkField) Then
                            If frwz_iDocTypePane = acForm Then cLines = wlib_Min(C_LINESTEXTBOXMAX, 1 + ci.dx \ (cchCtl + 1))
                            fMultiLine = (cLines > 1)
                        Else
                            cLines = C_LINESMEMO
                            fMultiLine = True
                        End If
                    End If
                End If
            Case Else
                cchCtl = CCH_TEXTBOX
        End Select
    End If
    If cchCtl > CCH_MEMO Then
        If ci.iDataType = dbText Then
            cchCtl = CCH_MEMO
        Else
            cchCtl = CCH_TEXTBOX
        End If
    ElseIf cchCtl < 1 Then
        cchCtl = CCH_TEXTBOX
    End If
    If cLines > C_LINESLISTBOX Then
        cLines = C_LINESLISTBOX
    ElseIf cLines < 1 Then
        cLines = 1
    End If
    SizeControlFromCchOrCaption Ctl, cchCtl, stCaption, cLines
    If frwz_iDocTypePane = acForm Then Ctl.ColumnWidth = wlib_Min(Ctl.Width, DX_DSCOLWIDTHMAX)
    If fMultiLine Or cLines > 1 Then
        On Error Resume Next
        If frwz_iDocTypePane = acForm Then
            Ctl.EnterKeyBehavior = True
            If Ctl.ControlType = acTextBox Then Ctl.ScrollBars = I_SBVERTONLY
        ElseIf frwz_iDocTypePane = acReport Then
            Ctl.CanGrow = True
        End If
        On Error GoTo 0
    End If
End Sub
Private Sub SizeControlFromCchOrCaption(Ctl As Control, cch As Integer, stCaption As String, Optional vcLines As Variant, _
                                        Optional vdx As Variant, Optional vdy As Variant)
    Dim dxdy As WLIB_POINT
    If Len(stCaption) Then
        AccessSizeToFit Ctl
    Else
        If IsMissing(vcLines) Then vcLines = 1
        dxdy = DxDyCtlFromFontAndCch(Ctl, cch, (vcLines))
        If Not IsMissing(vdx) Then
            SetControlWidthAndHeight Ctl, (vdx), dxdy.y
        ElseIf Not IsMissing(vdy) Then
            SetControlWidthAndHeight Ctl, dxdy.x, (vdy)
        Else
            SetControlWidthAndHeight Ctl, dxdy.x, dxdy.y
        End If
    End If
End Sub
Private Function DxDyCtlFromFontAndCch(Ctl As Control, cch As Integer, cLines As Integer) As WLIB_POINT
    Const CCH_MAX = 100
    Const C_LINESMAX = 20
    Dim dxdy As WLIB_POINT
    Dim csi As STYL_CONTROLSIZINGINFO
    If cch >= 0 And cch <= 5 Then
        csi.cchUseMaxWidth = 2
    ElseIf cch > 5 And cch <= 10 Then
        csi.cchUseMaxWidth = 1
    End If
    csi.cch = wlib_Max(1, wlib_Min(CCH_MAX, cch))
    cLines = wlib_Max(1, wlib_Min(C_LINESMAX, cLines))
    On Error Resume Next
    csi.stFontName = Ctl.FontName
    csi.iFontSize = Ctl.FontSize
    csi.iFontWeight = Ctl.FontWeight
    csi.fFontItalic = Ctl.FontItalic
    csi.fFontUnderline = Ctl.FontUnderline
    csi.iBorderStyle = Ctl.BorderStyle
    csi.iBorderWidth = Ctl.BorderWidth
    csi.iSpecialEffect = Ctl.SpecialEffect
    On Error GoTo 0
    styl_CsiFromFontAndBorder csi
    dxdy.x = csi.dxLine + (2 * csi.dxBorder)
    dxdy.y = cLines * csi.dyLine + (2 * csi.dyBorder)
    DxDyCtlFromFontAndCch = dxdy
End Function
Private Sub SetControlWidthAndHeight(Ctl As Control, dx As Long, dy As Long)
    Const DX_DEFAULT = 1440
    Const DY_DEFAULT = 240
    If dx < 0 Then
        Ctl.Width = DX_DEFAULT
    ElseIf (31680 - Ctl.Left > dx) Then
        Ctl.Width = dx
    Else
        Ctl.Width = wlib_Min(DX_DEFAULT, 31680 - Ctl.Left)
    End If
    If dy < 0 Then
        Ctl.Height = DY_DEFAULT
    ElseIf (31680 - Ctl.top > dy) Then
        Ctl.Height = dy
    Else
        Ctl.Height = wlib_Min(DY_DEFAULT, 31680 - Ctl.top)
    End If
End Sub
Private Function CchFromNumericCi(ci As FRWZ_CONTROL_INFO) As Integer
    Const C_DIGITSBYTE = 3
    Const C_DIGITSINT = 6
    Const C_DIGITSLONG = 10
    Const C_DIGITSDOUBLE = 12
    Const CCH_ADDGENERAL = 1
    Const CCH_ADDCURRENCY = 2
    Const CCH_ADDPERCENT = 5
    Const CCH_ADDSCIENTIFIC = 6
    Dim cDigits As Integer
    Select Case ci.iDataType
        Case dbByte
            cDigits = C_DIGITSBYTE
        Case dbInteger
            cDigits = C_DIGITSINT
        Case dbLong, dbSingle
            cDigits = C_DIGITSLONG
        Case dbDouble, dbCurrency
            cDigits = C_DIGITSDOUBLE
    End Select
    If (ci.iDataType = dbByte) Or (ci.iDataType = dbInteger) Or (ci.iDataType = dbLong) Then
        CchFromNumericCi = cDigits
    ElseIf ci.stFormat = "General Number" Then
        CchFromNumericCi = cDigits + CCH_ADDGENERAL
    ElseIf ci.stFormat = "Currency" Then
        CchFromNumericCi = (4 / 3) * cDigits + CCH_ADDCURRENCY + ci.iDecimalPlaces
    ElseIf ci.stFormat = "Fixed" Then
        CchFromNumericCi = cDigits + CCH_ADDGENERAL + ci.iDecimalPlaces
    ElseIf ci.stFormat = "Standard" Then
        CchFromNumericCi = (4 / 3) * cDigits
    ElseIf ci.stFormat = "Percent" Then
        CchFromNumericCi = CCH_ADDPERCENT + ci.iDecimalPlaces
    ElseIf ci.stFormat = "Scientific" Then
        CchFromNumericCi = CCH_ADDSCIENTIFIC + ci.iDecimalPlaces
    End If
End Function
Private Function CchFromDateFormat(stFormat As String) As Integer
    Const CCH_GENERAL = 20
    Const CCH_ADDLONG = 11
    Const CCH_MEDIUM = 10
    Const CCH_SHORT = 9
    Const CCH_LTIME = 12
    Const CCH_MTIME = 8
    Const CCH_STIME = 5
    Const CCH_OTHER = 20
    If (Len(stFormat) = 0) Then
        CchFromDateFormat = CCH_SHORT
    ElseIf stFormat = "General Date" Then
        CchFromDateFormat = CCH_GENERAL
    ElseIf stFormat = "Long Date" Then
        CchFromDateFormat = frwz_cchDayOfWeekMax + frwz_cchMonthMax + CCH_ADDLONG
    ElseIf stFormat = "Medium Date" Then
        CchFromDateFormat = CCH_MEDIUM
    ElseIf stFormat = "Short Date" Then
        CchFromDateFormat = CCH_SHORT
    ElseIf stFormat = "Long Time" Then
        CchFromDateFormat = CCH_LTIME
    ElseIf stFormat = "Medium Time" Then
        CchFromDateFormat = CCH_MTIME
    ElseIf stFormat = "Short Time" Then
        CchFromDateFormat = CCH_STIME
    Else
        CchFromDateFormat = CCH_OTHER
    End If
End Function
Private Sub SetLabelExtents(ctlLabel As Control, iLabelPos As Integer, fAttachedLabel As Boolean)
    If fAttachedLabel And (iLabelPos = 0 Or iLabelPos = 2) Then
        SetControlWidthAndHeight ctlLabel, frwz_dxLabelMaxBlk, frwz_dyLabelBlk
    Else
        SizeControlFromCchOrCaption ctlLabel, 0, ctlLabel.Caption
    End If
End Sub
Private Function IDefaultView(fMainPane As Boolean, iPaneContent As Integer, cPanes As Integer) As Integer
    Const I_SINGLEFORM = 0
    Const I_CONTINUOUSFORMS = 1
    Const I_DATASHEET = 2
    If fMainPane And cPanes > 1 Then
        IDefaultView = I_SINGLEFORM
    Else
        Select Case iPaneContent
            Case 1, 4
                IDefaultView = I_SINGLEFORM
            Case 2
                IDefaultView = I_CONTINUOUSFORMS
            Case 3
                IDefaultView = I_DATASHEET
            Case Else
        End Select
    End If
End Function
Private Sub Shutdown(stNewName As String, iOpen As Integer, iPaneContent As Integer, fSave As Boolean)
    If (Not fSave And iOpen = 0) Then iOpen = 1
    Select Case iOpen
        Case 0
            If fSave Then SaveAsAndCloseDoc frwz_iDocTypeMain, frwz_frmrptMain.Name, stNewName
        Case 1
            If fSave Then SaveDoc frwz_iDocTypeMain, frwz_frmrptMain.Name, stNewName
            If Not FOpenDocInBrowse(iPaneContent) Then
                If frwz_iDocTypeMain = acForm Then
                    MsgBox wlib_StFromRsIds(2042, frst_rsStrings, "String"), vbOKOnly + vbInformation
                ElseIf frwz_iDocTypeMain = acReport Then
                    MsgBox wlib_StFromRsIds(2043, frst_rsStrings, "String"), vbOKOnly + vbInformation
                End If
            End If
        Case 2
            If fSave Then SaveDoc frwz_iDocTypeMain, frwz_frmrptMain.Name, stNewName
            If frwz_iDocTypeMain = acForm Then
                DoCmd.OpenForm frwz_frmrptMain.Name, acDesign
            ElseIf frwz_iDocTypeMain = acReport Then
                DoCmd.OpenReport frwz_frmrptMain.Name, acDesign
            End If
    End Select
End Sub
Private Sub SaveAsAndCloseDoc(iDocType As Integer, stName As String, stNewName As String)
    SaveDoc iDocType, stName, stNewName
    DoCmd.close iDocType, stNewName
End Sub
Private Sub SaveDoc(iDocType As Integer, stDoc As String, stNewName As String)
    If Len(stNewName) = 0 Or (stDoc = stNewName) Then
        If ((frwz_fDelaySave) And (frwz_frmrptPane.HasModule)) Then
            SysCmd 503, frwz_frmrptPane.Hwnd, stDoc
            frwz_frmrptPane.Visible = False
        Else
            DoCmd.Save iDocType, stDoc
        End If
    Else
        If ((frwz_fDelaySave) And (frwz_frmrptPane.HasModule)) Then
            SysCmd 503, frwz_frmrptPane.Hwnd, stNewName
            frwz_frmrptPane.Visible = False
        Else
            DoCmd.SelectObject iDocType, stDoc, False
            DoCmd.Save , stNewName
        End If
    End If
End Sub
Private Function FOpenDocInBrowse(iPaneContent As Integer) As Boolean
On Error GoTo FOpenDocInBrowse_Err
    Const ERR_MENUITEMNOTAVAILABLE = 2046
    Dim stDoc As String
    stDoc = frwz_frmrptMain.Name
    If frwz_iDocTypeMain = acForm Then
        If iPaneContent = 3 Then
            DoCmd.OpenForm frwz_frmrptMain.Name, acFormDS
        Else
            DoCmd.OpenForm frwz_frmrptMain.Name, acNormal
            DoCmd.DoMenuItem acFormBar, 7, 6, , acMenuVer70
        End If
    Else
        DoCmd.OpenReport frwz_frmrptMain.Name, acPreview
    End If
    FOpenDocInBrowse = True
FOpenDocInBrowse_Exit:
    Exit Function
FOpenDocInBrowse_Err:
    If Err = ERR_MENUITEMNOTAVAILABLE Then FOpenDocInBrowse = True
    On Error GoTo 0
    If frwz_iDocTypeMain = acForm Then
        Set frwz_frmrptMain = Forms(stDoc)
    ElseIf frwz_iDocTypeMain = acReport Then
        Set frwz_frmrptMain = Reports(stDoc)
    End If
    GoTo FOpenDocInBrowse_Exit
End Function
Private Function StLabelOfStCtl(stCtl As String) As String
    Dim ich As Integer
    Select Case frst_LCID
        Case 1041, 1028, 1042, 2052
            ich = wlib_GetNumOfChar(stCtl, 64 - wlib_GetByteOfString(frwz_stLabelSuffix) - 1)
            StLabelOfStCtl = Left$(stCtl, ich) & frwz_stLabelSuffix
        Case Else
            StLabelOfStCtl = Left$(stCtl, 64 - Len(frwz_stLabelSuffix) - 1) & " " & frwz_stLabelSuffix
    End Select
End Function
Private Function FrmRptNew(iDocType As Integer) As Object
On Error GoTo FrmRptNew_Err
    Const ERR_NODEFAULTPRINTER = 2202
    Dim cAlerts As Integer
FrmRptNew_Start:
    If iDocType = acForm Then
        Set FrmRptNew = CreateForm()
    ElseIf iDocType = acReport Then
        Set FrmRptNew = CreateReport()
    End If
FrmRptNew_Exit:
    Exit Function
FrmRptNew_Err:
    If Err = ERR_NODEFAULTPRINTER And cAlerts < 2 Then
        If (vbCancel = MsgBox(wlib_StFromRsIds(2031, frst_rsStrings, "String"), vbOKCancel + vbInformation)) Then
            Error ERR_NODEFAULTPRINTER
        End If
        cAlerts = cAlerts + 1
        Resume FrmRptNew_Start
    Else
        Error Err
    End If
End Function
Private Sub AdornDoc(frmrpt As Object, iDocType As Integer, iLayoutTemplate As Integer, cgl As Integer)
    Dim rs As Recordset
    Dim stSQL As String
    Dim rcRegion As WLIB_RECT
    Dim iSection As Integer
    Dim stFilterProp As String
    Dim stFilterPropValue As String
    Select Case iLayoutTemplate
        Case 10, 11, 13, 1, 2
        Case 15
            iLayoutTemplate = 10
        Case 12
            iLayoutTemplate = 11
        Case 14
            iLayoutTemplate = 13
        Case Else
            Exit Sub
    End Select
            stSQL = "SELECT * FROM frwz_tblAdornments WHERE [frwz_tblAdornments].[DocType] = " & iDocType
    stSQL = stSQL & " AND [frwz_tblAdornments].[LayoutTemplateID] = " & iLayoutTemplate & ";"
    Set rs = frst_dbCode.OpenRecordset(stSQL, dbOpenSnapshot)
    On Error Resume Next
    rs.MoveFirst
    If Err Then
        On Error GoTo 0
        Exit Sub
    End If
    On Error GoTo 0
    Do Until rs.EOF
        stFilterProp = ""
        If rs!Section = 97 Then
            iSection = frwz_ISectionFromGL((cgl - 1), True)
            rcRegion = RcControls(frmrpt, iSection, "Tag", "DetachedLabel")
            stFilterProp = "Tag"
            stFilterPropValue = "DetachedLabel"
        ElseIf rs!Section = 99 Then
            iSection = frwz_ISectionFromGL((cgl - 1), False)
            If frwz_rgfSectionExists(iSection) Then
                rcRegion = RcSurround(frmrpt, iSection, rs!Controls)
            Else
                GoTo AdornDoc_MoveNext
            End If
        ElseIf rs!Section = 98 Then
            iSection = frwz_ISectionFromGL((cgl - 1), True)
            If frwz_rgfSectionExists(iSection) Then
                rcRegion = RcControls(frmrpt, iSection, "Tag", "DetachedLabel", False)
            Else
                GoTo AdornDoc_MoveNext
            End If
        ElseIf frwz_rgfSectionExists(rs!Section) Then
            iSection = rs!Section
            rcRegion = RcSurround(frmrpt, iSection, rs!Controls)
        Else
            GoTo AdornDoc_MoveNext
        End If
        If rs!ControlType = acLine Then
            If rs!top Then
                rcRegion.bottom = rcRegion.top
            Else
                rcRegion.top = rcRegion.bottom
            End If
        End If
        If rs!Offset <> 0 Then
            rcRegion.top = rcRegion.top + ((rs!Offset / 4) * frwz_YTwipsPerTick)
            rcRegion.bottom = rcRegion.bottom + ((rs!Offset / 4) * frwz_YTwipsPerTick)
        End If
        If stFilterProp <> "" Then
            AdornRegion frmrpt, iDocType, iSection, rcRegion, rs, stFilterProp, stFilterPropValue
        Else
            AdornRegion frmrpt, iDocType, iSection, rcRegion, rs
        End If
AdornDoc_MoveNext:
        rs.MoveNext
    Loop
End Sub
Private Function RcControls(frmrpt As Object, iSection As Integer, Optional vStProp As Variant, _
                            Optional vValue As Variant, Optional vInclude As Variant) As WLIB_RECT
    Dim ictl As Integer
    Dim Ctl As Control
    Dim rc As WLIB_RECT
    Dim fRcInitialized As Integer
    Dim vPropVal As Variant
    If IsMissing(vStProp) Then
        vStProp = ""
        vValue = ""
        vInclude = False
    ElseIf IsMissing(vValue) Then
        vStProp = ""
        vValue = ""
        vInclude = False
    ElseIf IsMissing(vInclude) Then
        vInclude = True
    End If
    For ictl = 0 To frmrpt.Count - 1
        Set Ctl = frmrpt(ictl)
        If Ctl.ControlType = acPageBreak Then Exit For
        If Ctl.Section = iSection Then
            If vStProp <> "" Then
                On Error Resume Next
                vPropVal = Ctl.Properties(vStProp)
            End If
            If Err = 0 Then
                If (vStProp = "") Or (vInclude And vPropVal = vValue) _
                                  Or (Not vInclude And ((vPropVal <> vValue) Or IsNull(vPropVal))) Then
                    If Not fRcInitialized Then
                        rc.top = Ctl.top
                        rc.Left = Ctl.Left
                        fRcInitialized = True
                    Else
                        rc.top = wlib_Min(rc.top, Ctl.top)
                        rc.Left = wlib_Min(rc.Left, Ctl.Left)
                    End If
                    rc.bottom = wlib_Max(rc.bottom, Ctl.top + Ctl.Height)
                    rc.Right = wlib_Max(rc.Right, Ctl.Left + Ctl.Width)
                End If
            Else
                On Error GoTo 0
            End If
        End If
    Next ictl
    RcControls = rc
End Function
Private Sub AdornRegion(frmrpt As Object, iDocType As Integer, iSection As Integer, rc As WLIB_RECT, rs As Recordset, _
                        Optional vStFilterProp As Variant, Optional vFilterValue As Variant)
    Const I_BSNORMAL = 1
    Const I_MENUBARFORMDESIGN = 3
    Const I_MENUBARREPORT = 7
    Const I_MENUNAMEFORMAT = 4
    Const I_MENUCMDSENDTOBACK = 9
    Dim Ctl As Control
    If Not (rs!ControlType = acRectangle Or rs!ControlType = acLine) Then
        Exit Sub
    End If
    If (rs!ControlType = acRectangle And ((rc.Left = rc.Right) Or (rc.bottom = rc.top))) Then
        Exit Sub
    End If
    Set Ctl = CtlNew(rs!ControlType, iSection, "", "", "", "", _
                     rc.Left, rc.top, (rc.Right - rc.Left), (rc.bottom - rc.top), True)
    If Not IsMissing(vStFilterProp) Then
        On Error Resume Next
        Ctl.Properties(vStFilterProp) = vFilterValue
        On Error GoTo 0
    End If
    If Not IsNull(rs!SpecialEffect) Then Ctl.SpecialEffect = rs!SpecialEffect
    If Not IsNull(rs!BorderStyle) Then Ctl.BorderStyle = rs!BorderStyle
    If Not IsNull(rs!BorderColor) Then Ctl.BorderColor = rs!BorderColor
    If Not IsNull(rs!BorderWidth) Then Ctl.BorderWidth = rs!BorderWidth
    If rs!ControlType = acRectangle Then
        If Not IsNull(rs!BackStyle) Then Ctl.BackStyle = rs!BackStyle
        If Not IsNull(rs!BackColor) Then Ctl.BackColor = rs!BackColor
    End If
    If rs!ControlType = acRectangle Then
        If Ctl.BackStyle = I_BSNORMAL Then
            DoCmd.SelectObject frwz_iDocTypePane, frwz_frmrptPane.Name
            Ctl.InSelection = True
            If iDocType = acForm Then
                DoCmd.DoMenuItem I_MENUBARFORMDESIGN, I_MENUNAMEFORMAT, I_MENUCMDSENDTOBACK, , acMenuVer70
            ElseIf iDocType = acReport Then
                DoCmd.DoMenuItem I_MENUBARREPORT, I_MENUNAMEFORMAT, I_MENUCMDSENDTOBACK, , acMenuVer70
            End If
            Ctl.InSelection = False
        End If
    End If
End Sub
Private Function RcSurround(frmrpt As Object, iSection As Integer, fControls As Boolean) As WLIB_RECT
    Dim rc As WLIB_RECT
    If fControls Then
        rc = RcControls(frmrpt, iSection)
    Else
        rc.Right = frmrpt.Width
        rc.bottom = frmrpt.Section(iSection).Height
    End If
    RcSurround = rc
End Function
Private Sub CreatePageBreaks(cPageBreaks As Integer, dyPageBreakTks As Integer)
    Dim i As Integer
    For i = 0 To cPageBreaks - 1
        CtlNew acPageBreak, 0, "", "", "", "", 0, (i + 1) * dyPageBreakTks * frwz_YTwipsPerTick, 0, 0, False
    Next i
    frwz_frmrptPane.Section(0).Height = (cPageBreaks + 1) * dyPageBreakTks * frwz_YTwipsPerTick
End Sub
Private Function CtlNew(iCtlType As Integer, iSection As Integer, stParent As String, stName As String, _
                        stCtlSrc As String, stCaption As String, x As Long, y As Long, dx As Long, dy As Long, _
                        fApplyStyle As Integer) As Control
On Error GoTo CtlNew_Err
    Const ERR_CONTROLNAMEEXISTS = 2104
    Dim Ctl As Control
    Static i As Integer
    Dim cchSuffix As Integer
    Set Ctl = CreateDocControl(frwz_iDocTypePane, (frwz_frmrptPane.Name), iCtlType, iSection, stParent, stCtlSrc, _
                                 x, y, dx, dy)
CtlNew_SetControlName:
    If Len(stName) > 0 Then Ctl.ControlName = stName
    If Len(stCaption) > 0 Then Ctl.Caption = stCaption
    If fApplyStyle Then ErrApplyCS Ctl
    Set CtlNew = Ctl
    Exit Function
CtlNew_Err:
    If Err = ERR_CONTROLNAMEEXISTS Then
        On Error GoTo 0
        i = i + 1
        cchSuffix = Len(CStr(i))
        If (Len(stName) + cchSuffix) > 64 Then
            stName = Left$(stName, 64 - cchSuffix) & i
        Else
            stName = stName & i
        End If
        stName = wlib_StUniqueControlName((frwz_frmrptPane.Name), frwz_iDocTypePane, stName)
        GoTo CtlNew_SetControlName
    Else
        Error Err
    End If
End Function
Private Function CreateDocControl(iDocType As Integer, stDoc As String, iControlType As Integer, _
                                  iSection As Integer, stParent As String, stCtlSrc As String, _
                                  x As Long, y As Long, dx As Long, dy As Long) As Control
    Select Case iDocType
        Case acForm
            If dx = -1 Then
                Set CreateDocControl = CreateControl(stDoc, iControlType, iSection, stParent, stCtlSrc, x, y)
            Else
                Set CreateDocControl = CreateControl(stDoc, iControlType, iSection, stParent, stCtlSrc, x, y, dx, dy)
            End If
        Case acReport
            If dx = -1 Then
                Set CreateDocControl = CreateReportControl(stDoc, iControlType, iSection, stParent, stCtlSrc, x, y)
            Else
                Set CreateDocControl = CreateReportControl(stDoc, iControlType, iSection, stParent, stCtlSrc, x, y, dx, dy)
            End If
    End Select
End Function
Private Sub DeleteDocControl(iDocType As Integer, stDoc As String, stCtl As String)
    Select Case iDocType
        Case acForm
            DeleteControl stDoc, stCtl
        Case acReport
            DeleteReportControl stDoc, stCtl
    End Select
End Sub
Private Function FValidControlType(iControlType As Integer) As Boolean
    If iControlType < acLabel Or iControlType > acToggleButton Then
        Exit Function
    End If
    If iControlType = acTextBox Then
        FValidControlType = True
    ElseIf iControlType = acLabel Then: FValidControlType = True
    ElseIf iControlType = acComboBox Then: FValidControlType = True
    ElseIf iControlType = acListBox Then: FValidControlType = True
    ElseIf iControlType = acCommandButton Then: FValidControlType = True
    ElseIf iControlType = acSubform Then: FValidControlType = True
    ElseIf iControlType = acLine Then: FValidControlType = True
    ElseIf iControlType = acRectangle Then: FValidControlType = True
    ElseIf iControlType = acCheckBox Then: FValidControlType = True
    ElseIf iControlType = acToggleButton Then: FValidControlType = True
    ElseIf iControlType = acBoundObjectFrame Then: FValidControlType = True
    ElseIf iControlType = acImage Then: FValidControlType = True
    ElseIf iControlType = acObjectFrame Then: FValidControlType = True
    ElseIf iControlType = acOptionButton Then: FValidControlType = True
    ElseIf iControlType = acOptionGroup Then: FValidControlType = True
    ElseIf iControlType = acPageBreak Then: FValidControlType = True
    End If
End Function
Private Function FCanHaveLabel(iControlType As Integer) As Boolean
    If iControlType = acTextBox Then
        FCanHaveLabel = True
    ElseIf iControlType = acLabel Then: FCanHaveLabel = False
    ElseIf iControlType = acComboBox Then: FCanHaveLabel = True
    ElseIf iControlType = acListBox Then: FCanHaveLabel = True
    ElseIf iControlType = acCommandButton Then: FCanHaveLabel = True
    ElseIf iControlType = acSubform Then: FCanHaveLabel = True
    ElseIf iControlType = acLine Then: FCanHaveLabel = False
    ElseIf iControlType = acRectangle Then: FCanHaveLabel = False
    ElseIf iControlType = acCheckBox Then: FCanHaveLabel = True
    ElseIf iControlType = acToggleButton Then: FCanHaveLabel = True
    ElseIf iControlType = acBoundObjectFrame Then: FCanHaveLabel = True
    ElseIf iControlType = acImage Then: FCanHaveLabel = False
    ElseIf iControlType = acObjectFrame Then: FCanHaveLabel = False
    ElseIf iControlType = acOptionButton Then: FCanHaveLabel = True
    ElseIf iControlType = acOptionGroup Then: FCanHaveLabel = True
    ElseIf iControlType = acPageBreak Then: FCanHaveLabel = False
    End If
End Function
Private Sub AnchorRect(rc As WLIB_RECT, rcTarget As WLIB_RECT)
    Dim dx As Long
    Dim dy As Long
    dx = rc.Right - rc.Left
    dy = rc.bottom - rc.top
    rc.Left = rcTarget.Left
    rc.Right = rcTarget.Left + dx
    rc.top = rcTarget.top
    rc.bottom = rcTarget.top + dy
End Sub
Private Sub ShiftRect(rc As WLIB_RECT, dx As Long, dy As Long)
    rc.Left = rc.Left + dx
    rc.top = rc.top + dy
End Sub
Private Sub AccessSizeToFit(Ctl As Control)
    DoCmd.SelectObject frwz_iDocTypePane, frwz_frmrptPane.Name
    Ctl.InSelection = True
    If frwz_iDocTypePane = acForm Then
        DoCmd.DoMenuItem 3, 4, 5, 0, acMenuVer70
    ElseIf frwz_iDocTypePane = acReport Then
        DoCmd.DoMenuItem 7, 4, 5, 0, acMenuVer70
    End If
    Ctl.InSelection = False
End Sub
Private Sub LayoutFeJustifiedDoc(pn As FRWZ_PANE)
    Dim iblk As Integer
    Dim rcCtls As WLIB_RECT
    For iblk = 0 To pn.cBlocks - 1
        If frwz_frmrptPane.Section(pn.rgblk(iblk).iSection).Height > 0 Then
            frwz_frmrptPane.Section(pn.rgblk(iblk).iSection).Height = 0
        End If
        LayoutFeJustifiedBlock pn.rgblk(iblk), frwz_frmrptPane.Section(pn.rgblk(iblk).iSection).Height
    Next iblk
End Sub
Private Sub LayoutFeJustifiedBlock(blk As FRWZ_BLOCK, y As Long)
    Const DX_INDENTTKS = 2
    Const DY_INDENTTKS = 2
    Const DY_REPORTPADTKS = 4
    Const C_LINESMEMO = 3
    Const D_SHRINKLIMITPCT = 0.5
    Const CCH_MULTILINEMIN = 100
    Const DY_SUBDOC = 2160
    Dim ci As FRWZ_CONTROL_INFO
    Dim Ctl As Control
    Dim ctlLbl As Control
    Dim ctlPrev As Control
    Dim ctlLblPrev As Control
    Dim pt As WLIB_POINT
    Dim ictl As Integer
    Dim dyCtl As Integer
    Dim dxdyMemoCtl As WLIB_POINT
    Dim dyLbl As Integer
    Dim dxCtlAndLbl As Long
    Dim dxBlk As Long
    Dim dyBlk As Long
    Dim dxAvailable As Long
    Dim cCtlsStripe As Integer
    dxBlk = (Int(frwz_dxScreenOrPage / frwz_XTwipsPerTick) - DX_INDENTTKS) * frwz_XTwipsPerTick
    dyBlk = (Int(31680 / frwz_YTwipsPerTick) - DY_INDENTTKS) * frwz_YTwipsPerTick
    blk.fAttachedLabels = True
    dyCtl = DxDyGridAligned(frwz_frmrptPane.DefaultControl(acTextBox).Height, False)
    pt.x = DX_INDENTTKS * frwz_XTwipsPerTick
    pt.y = y + DY_INDENTTKS * frwz_YTwipsPerTick
    For ictl = 0 To blk.cControls - 1
        dxAvailable = dxBlk - pt.x
        ci = blk.rgci(ictl)
        ci.fNoLabel = False
        If ci.iDataType = dbLongBinary Then ci.iControlType = acBoundObjectFrame
        If ci.iDataType = dbMemo Then ci.iControlType = acTextBox
        CtlAndLblFromCi blk.rgci(ictl), blk.iSection, blk.fAttachedLabels, False, Ctl, ctlLbl
        If ci.iDataType = dbMemo Then
            GoSub LayoutFeJustifiedBlock_LargeTextControl
        ElseIf ci.iDataType = dbText And Abs(ci.dx) >= CCH_MULTILINEMIN Then
            GoSub LayoutFeJustifiedBlock_LargeTextControl
        ElseIf Ctl.ControlType = acListBox Then
            SizeTextControl Ctl, blk.rgci(ictl)
            GoSub LayoutFeJustifiedBlock_WrapIfNeeded
        ElseIf Ctl.ControlType = acSubform Then
            Ctl.Width = dxBlk
            Ctl.Height = DY_SUBDOC
            GoSub LayoutFeJustifiedBlock_WrapIfNeeded
        ElseIf Ctl.ControlType = acBoundObjectFrame Then
            AccessSizeToFit Ctl
            Ctl.Width = dxBlk
            Ctl.BackColor = frwz_frmrptPane.DefaultControl(acTextBox).BackColor
            Ctl.BackStyle = frwz_frmrptPane.DefaultControl(acTextBox).BackStyle
            GoSub LayoutFeJustifiedBlock_WrapIfNeeded
        Else
            SizeControlFromControlType Ctl, blk.rgci(ictl)
            Ctl.Height = dyCtl
        End If
        On Error Resume Next
        Ctl.BorderStyle = 1
        Ctl.BorderWidth = 0
        ctlLbl.BorderStyle = 1
        ctlLbl.BorderWidth = 0
        On Error GoTo 0
        SizeControlFromCchOrCaption ctlLbl, 0, ctlLbl.Caption
        If dyLbl = 0 Then dyLbl = ctlLbl.Height
        If cCtlsStripe Then
            If dxAvailable > Ctl.Width Then
            ElseIf ctlLbl.Width > dxAvailable Then
                GoSub LayoutFeJustifiedBlock_JustifyPrevControl
                GoSub LayoutFeJustifiedBlock_StartNewStripe
            ElseIf dxAvailable < (D_SHRINKLIMITPCT * Ctl.Width) Then
                GoSub LayoutFeJustifiedBlock_JustifyPrevControl
                GoSub LayoutFeJustifiedBlock_StartNewStripe
            End If
        End If
        dxCtlAndLbl = wlib_Max(wlib_Min(Ctl.Width, dxAvailable), wlib_Min(ctlLbl.Width, dxAvailable))
        Ctl.Width = dxCtlAndLbl
        ctlLbl.Width = dxCtlAndLbl
        ctlLbl.Height = dyLbl
        ctlLbl.Left = pt.x
        ctlLbl.top = pt.y
        Ctl.Left = ctlLbl.Left
        Ctl.top = ctlLbl.top + ctlLbl.Height
        Set ctlPrev = Ctl
        Set ctlLblPrev = ctlLbl
        If (ictl = blk.cControls - 1) Then GoTo LayoutFeJustifiedBlock_Exit
        If Ctl.Left + Ctl.Width >= dxBlk Then
            GoSub LayoutFeJustifiedBlock_StartNewStripe
        ElseIf Ctl.ControlType = acBoundObjectFrame Then
            GoSub LayoutFeJustifiedBlock_StartNewStripe
        ElseIf Ctl.ControlType = acListBox Then
            GoSub LayoutFeJustifiedBlock_StartNewStripe
        Else
            pt.x = Ctl.Left + Ctl.Width
            cCtlsStripe = cCtlsStripe + 1
        End If
    Next ictl
LayoutFeJustifiedBlock_Exit:
    If frwz_iDocTypePane = acReport Then GoSub LayoutFeJustifiedBlock_JustifyPrevControl
    frwz_frmrptPane.Section(blk.iSection).Height = 0
    If frwz_iDocTypePane = acForm Then
        frwz_frmrptPane.Section(blk.iSection).Height = wlib_Min(frwz_frmrptPane.Section(blk.iSection).Height + _
                                                                frwz_YTwipsPerTick * DY_INDENTTKS, 31680)
    ElseIf frwz_iDocTypePane = acReport Then
        frwz_frmrptPane.Section(blk.iSection).Height = wlib_Min(frwz_frmrptPane.Section(blk.iSection).Height + _
                                                                frwz_YTwipsPerTick * DY_REPORTPADTKS, 31680)
    End If
    frwz_frmrptPane.Width = 0
    frwz_frmrptPane.Width = wlib_Min(frwz_frmrptPane.Width + frwz_XTwipsPerTick * DX_INDENTTKS, 31680)
    If frwz_iDocTypePane = acReport Then
        Set Ctl = CtlBoundingRect(RcSurround(frwz_frmrptPane, blk.iSection, True), 0, blk.iSection)
        Ctl.BorderWidth = 2
    End If
    Exit Sub
LayoutFeJustifiedBlock_LargeTextControl:
    Ctl.Width = dxBlk
    If dxdyMemoCtl.y = 0 Then
        dxdyMemoCtl = DxDyCtlFromFontAndCch(Ctl, 0, C_LINESMEMO)
    End If
    Ctl.Height = dxdyMemoCtl.y
    GoSub LayoutFeJustifiedBlock_WrapIfNeeded
    Return
LayoutFeJustifiedBlock_WrapIfNeeded:
    If cCtlsStripe Then
        GoSub LayoutFeJustifiedBlock_JustifyPrevControl
        GoSub LayoutFeJustifiedBlock_StartNewStripe
    End If
    Return
LayoutFeJustifiedBlock_JustifyPrevControl:
    If Not ctlPrev Is Nothing Then
        If (ctlPrev.Left + ctlPrev.Width) < dxBlk Then
            ctlPrev.Width = dxBlk - ctlPrev.Left
            ctlLblPrev.Width = ctlPrev.Width
        End If
    End If
    Return
LayoutFeJustifiedBlock_StartNewStripe:
    pt.x = DX_INDENTTKS * frwz_XTwipsPerTick
    pt.y = ctlPrev.top + ctlPrev.Height
    dxAvailable = dxBlk - pt.x
    cCtlsStripe = 0
    Return
End Sub

'---
Attribute VB_Name = "frui_modEntry"
Option Compare Database
Option Explicit
Function frui_Entry(stRecSrc As String, iDocType As Integer)
On Error GoTo frui_Entry_Err
    Dim fCurDbOpened As Boolean
    Dim errReturned As Long
    If iDocType = 102 Then
        iDocType = acForm
        frui_uii.fInvokedFromExcel = True
    ElseIf iDocType = 103 Then
        iDocType = acReport
        frui_uii.fInvokedFromExcel = True
    Else
        frui_uii.fInvokedFromExcel = False
    End If
    wlib_OpenCurrentDB
    fCurDbOpened = True
    ReDim frui_uii.di.rgiDocType(0)
    frui_uii.di.rgiDocType(0) = iDocType
    frui_uii.di.fpkd.dbobj.stName = stRecSrc
    errReturned = frst_ErrToggleDbAndRs(True)
    If errReturned <> 0 Then Error errReturned
    frst_InitLCID
    frst_fCancelWizard = False
    DoCmd.OpenForm "frui_frmMain", , , , , acDialog
frui_Entry_Exit:
    On Error Resume Next
    errReturned = frst_ErrToggleDbAndRs(False)
    If errReturned <> 0 Then Error errReturned
    If fCurDbOpened Then wlib_CloseCurrentDB
    Exit Function
frui_Entry_Err:
    If Err <> 2501 Then wlib_HandleError Err, Error$
    Resume frui_Entry_Exit
End Function
Function ssq_Entry()
    frui_Entry "", acQuery
End Function
Function frui_CUserLevels(vw As AUTO_VIEW) As Integer
    Dim iLevel As Integer
    Dim c As Integer
    For iLevel = 0 To vw.cLevels - 1
        If vw.rglvl(iLevel).fUserDefined Then c = c + 1
    Next iLevel
    frui_CUserLevels = c
End Function
Sub frui_PopulateGrpFieldsArray(fpkd As FPK_DATA, vw As AUTO_VIEW)
    Const C_SLOTSDEFAULT = 10
    Dim iFld As Integer
    Dim cGrpFlds As Integer
    Dim cArraySlots As Integer
    cArraySlots = C_SLOTSDEFAULT
    ReDim frui_uii.rgiGrpFields(0 To (cArraySlots - 1))
    For iFld = 0 To fpkd.cfiSel - 1
        If frst_FGrpSortField(fpkd.rgfiSel(iFld).iType) Then
            If Not frst_FLonerFld(iFld, fpkd, vw) Then
                cGrpFlds = cGrpFlds + 1
                If cGrpFlds > cArraySlots Then
                    cArraySlots = cArraySlots + C_SLOTSDEFAULT
                    ReDim Preserve frui_uii.rgiGrpFields(0 To (cArraySlots - 1))
                End If
                frui_uii.rgiGrpFields(cGrpFlds - 1) = iFld
            End If
        End If
    Next iFld
    frui_uii.cGrpFields = cGrpFlds
    frui_uii.fGrpFieldsPopulated = True
End Sub
Public Sub frui_PopulateSortFieldsArray()
    Const C_SLOTSDEFAULT = 10
    Dim iFld As Integer
    Dim cFlds As Integer
    Dim cArraySlots As Integer
    If Not frui_uii.fDetailFieldsPopulated Then frui_PopulateDetailFieldsArray
    cArraySlots = C_SLOTSDEFAULT
    ReDim frui_uii.rgiSortFields(0 To (cArraySlots - 1))
    For iFld = 0 To frui_uii.cDetailFields - 1
        If frst_FGrpSortField(frui_uii.di.fpkd.rgfiSel(frui_uii.rgiDetailFields(iFld)).iType) Then
            cFlds = cFlds + 1
            If cFlds > cArraySlots Then
                cArraySlots = cArraySlots + C_SLOTSDEFAULT
                ReDim Preserve frui_uii.rgiSortFields(0 To (cArraySlots - 1))
            End If
            frui_uii.rgiSortFields(cFlds - 1) = frui_uii.rgiDetailFields(iFld)
        End If
    Next iFld
    frui_uii.cSortFields = cFlds
    frui_uii.fSortFieldsPopulated = True
End Sub
Sub frui_PopulateAggFieldsArray()
    Const C_SLOTSDEFAULT = 10
    Dim iFld As Integer
    Dim cFlds As Integer
    Dim cArraySlots As Integer
    If Not frui_uii.fDetailFieldsPopulated Then frui_PopulateDetailFieldsArray
    cArraySlots = C_SLOTSDEFAULT
    ReDim frui_uii.rgiAggFields(0 To (cArraySlots - 1))
    For iFld = 0 To frui_uii.cDetailFields - 1
        If FFieldAllowsAggs(frui_uii.di.fpkd.rgfiSel(frui_uii.rgiDetailFields(iFld))) Then
            cFlds = cFlds + 1
            If cFlds > cArraySlots Then
                cArraySlots = cArraySlots + C_SLOTSDEFAULT
                ReDim Preserve frui_uii.rgiAggFields(0 To (cArraySlots - 1))
            End If
            frui_uii.rgiAggFields(cFlds - 1) = frui_uii.rgiDetailFields(iFld)
        End If
    Next iFld
    frui_uii.cAggFields = cFlds
    frui_uii.fAggFieldsPopulated = True
End Sub
Sub frui_PopulateDetailFieldsArray()
    frst_RgifiFromWizardLvl frui_uii.rgiDetailFields(), frui_uii.cDetailFields, _
                          frui_uii.di.vw.rglvl(frui_uii.di.vw.cLevels - 1), True, frui_uii.di.fpkd, frui_uii.di.vw
    SetKeyFieldFlags frui_uii.rgiDetailFields(), frui_uii.cDetailFields, frui_uii.di.fpkd
    frui_uii.fDetailFieldsPopulated = True
End Sub
Sub frui_InvalidateFieldArrays(fInvalidateGrpFlds As Boolean)
    frui_uii.fDetailFieldsPopulated = False
    frui_uii.fSortFieldsPopulated = False
    frst_csort = 0
    frui_uii.fAggFieldsPopulated = False
    frui_uii.di.fHideDetail = False
    frui_uii.fQrySummarize = False
    frui_uii.fQryCountDetails = False
    frui_uii.fPctOfTotal = False
    If fInvalidateGrpFlds Then frui_uii.fGrpFieldsPopulated = False
End Sub
Private Function FFieldAllowsAggs(fi As FPK_FLDINFO) As Integer
    FFieldAllowsAggs = Not ((fi.iType = dbText) Or (fi.iType = dbDate) Or (fi.iType = dbMemo) Or (fi.iType = dbLongBinary) Or _
                        ((fi.lAttributes And &H1000&) = &H1000&) Or _
                        ((fi.lAttributes And &H2000&) = &H2000&))
End Function
Private Sub SetKeyFieldFlags(rgifi() As Integer, cFi As Integer, fpkd As FPK_DATA)
On Error GoTo SetKeyFieldFlags_Err
    Dim iFld As Integer
    Dim stSrcTbl As String
    Dim stSrcFld As String
    Dim fCurDbOpened As Boolean
    wlib_OpenCurrentDB
    fCurDbOpened = True
    For iFld = 0 To cFi - 1
        If ((fpkd.rgfiSel(rgifi(iFld)).lAttributes And &H1000&) = 0 And _
                (fpkd.rgfiSel(rgifi(iFld)).lAttributes And &H2000&) = 0) Then
            stSrcTbl = fpkd.rgfiSel(rgifi(iFld)).stSrcTbl
            stSrcFld = fpkd.rgfiSel(rgifi(iFld)).stSrcFld
            If Len(stSrcTbl) > 0 And Len(stSrcFld) > 0 Then
                If frui_FKeyField(wlib_dbCur.TableDefs(stSrcTbl), stSrcFld, True) Then
                    fpkd.rgfiSel(rgifi(iFld)).lAttributes = fpkd.rgfiSel(rgifi(iFld)).lAttributes Or &H1000&
                End If
                If frui_FKeyField(wlib_dbCur.TableDefs(stSrcTbl), stSrcFld, False) Then
                    fpkd.rgfiSel(rgifi(iFld)).lAttributes = fpkd.rgfiSel(rgifi(iFld)).lAttributes Or &H2000&
                End If
            End If
        End If
    Next iFld
SetKeyFieldFlags_Err:
    If fCurDbOpened Then wlib_CloseCurrentDB
End Sub
Public Function frui_FKeyField(td As TableDef, stSrcFld As String, fPrimary As Boolean) As Boolean
    Dim iNdx As Integer
    Dim iFld As Integer
    For iNdx = 0 To td.Indexes.Count - 1
        If (fPrimary And td.Indexes(iNdx).Primary) Or (Not fPrimary And td.Indexes(iNdx).Foreign) Then
            For iFld = 0 To td.Indexes(iNdx).Fields.Count - 1
                If stSrcFld = td.Indexes(iNdx).Fields(iFld).Name Then
                    frui_FKeyField = True
                    Exit Function
                End If
            Next iFld
        End If
    Next iNdx
End Function

'---
Attribute VB_Name = "frst_modShared"
Option Compare Database
Option Explicit
Type AUTO_KEY
    rgfi() As FPK_FLDINFO
    cFi As Integer
End Type
Type AUTO_NODE
    inod As Integer
    dbobj As WLIB_DBOBJ
    iManyness As Integer
    fUserFields As Boolean
End Type
Type AUTO_LEVEL
    rginod() As Integer
    cNodes As Integer
    inodInKey As Integer
    inodOutKey As Integer
    irelEntering As Integer
    irelLeaving As Integer
    rgiFiInKey() As Integer
    cFiInKey As Integer
    rgiFiOutKey() As Integer
    cFiOutKey As Integer
    iGrpMethod As Integer
    fSortDesc As Integer
    fUserDefined As Boolean
    ifiGrpExpr As Integer
    fFldAssigned As Boolean
End Type
Type AUTO_VIEW
    rglvl() As AUTO_LEVEL
    cLevels As Integer
End Type
Type AUTO_SYSREL
    inod1 As Integer
    inod2 As Integer
    key As AUTO_KEY
    iCardinality As Integer
End Type
Type AUTO_DATAMODEL
    rgnod() As AUTO_NODE
    rginod() As Integer
    cNodes As Integer
    rginodValidHp() As Integer
    cNodesValidHp As Integer
    rgrel() As AUTO_SYSREL
End Type
Type FRST_PROPERTY
    stName As String
    stValue As String
    iType As Integer
    iSection As Integer
End Type
Type FRST_DOCINFO
    fpkd As FPK_DATA
    vw As AUTO_VIEW
    mdl As AUTO_DATAMODEL
    iQGType As Integer
    fSplitQuery As Boolean
    cLevelsMax As Integer
    iHoistPoint As Integer
    fMapToPanes As Boolean
    cPanes As Integer
    rgiDocType() As Integer
    rgstDocName() As String
    rgiPaneContent() As Integer
    stRecSrc As String
    fFitToPage As Boolean
    iTargetDevice As Integer
    iLayoutTemplate As Integer
    fLinkedDocs As Boolean
    fHideDetail As Boolean
    fUseStoredQuery As Boolean
End Type
Type FRST_GROUP_METHOD
    iDataType As Integer
    iGroupOn As Integer
    iGroupInterval As Integer
    idsCaption As Long
End Type
Type FRST_SORT
    iFi As Integer
    fSortDesc As Boolean
End Type
Type FRUI_UIINFO
    fInvokedFromExcel As Boolean
    di As FRST_DOCINFO
    rgiGrpFields() As Integer
    cGrpFields As Integer
    fGrpFieldsPopulated As Boolean
    rgiDetailFields() As Integer
    cDetailFields As Integer
    fDetailFieldsPopulated As Boolean
    rgiSortFields() As Integer
    cSortFields As Integer
    fSortFieldsPopulated As Boolean
    rgiAggFields() As Integer
    cAggFields As Integer
    fAggFieldsPopulated As Boolean
    fFpkRevisit As Boolean
    fQrySummarize As Boolean
    fQryCountDetails As Boolean
    iQryGroupMethod As Integer
    inodCountRecs As Integer
    fCancelAggsDialog As Boolean
    vwCustom As AUTO_VIEW
    fRptGrpRevisit As Boolean
    iSelectedUserLevel As Integer
    fPctOfTotal As Integer
    fPaneContentsValidated As Boolean
    fStyleCartoonInitialized As Boolean
    lStyleID As Long
    iOpenMode As Integer
    fSaveParentDoc As Integer
    fHelpCard As Integer
    fDocNamesValidated As Boolean
End Type
Global frst_rggm(0 To (7 + 5 + 7)) As FRST_GROUP_METHOD
Global frst_rgiGmNumeric(0 To 7) As Integer
Global frst_rgiGmText(0 To 5) As Integer
Global frst_rgiGmDate(0 To 7) As Integer
Global frst_csort As Integer
Global frst_rgsort() As FRST_SORT
Global frst_stMDTFile As String
Global frst_dbCode As Database
Global frst_rsStrings As Recordset
Global frst_fCancelWizard As Boolean
Global frst_rgstAggFxns() As String
Global frst_rgstAggFxnsLcl() As String
Global frui_uii As FRUI_UIINFO
Global frst_LCID As Long
Sub frst_InitLCID()
    If frst_LCID = 0 Then
        frst_LCID = wlib_GetLCID()
    End If
End Sub
Function frst_ErrToggleDbAndRs(fOpen As Boolean) As Long
On Error GoTo frst_ErrToggleDbAndRs_Err
    Static cRefs As Integer
    If fOpen Then
        If cRefs = 0 Then
            Set frst_dbCode = CodeDb()
            Set frst_rsStrings = frst_dbCode.OpenRecordset("frst_tblStrings", dbOpenTable)
            frst_rsStrings.Index = "PrimaryKey"
        End If
        cRefs = cRefs + 1
    Else
        If cRefs = 1 Then
            frst_rsStrings.close
            frst_dbCode.close
        End If
        cRefs = cRefs - 1
    End If
    frst_ErrToggleDbAndRs = 0
frst_ErrToggleDbAndRs_Exit:
    Exit Function
frst_ErrToggleDbAndRs_Err:
    frst_ErrToggleDbAndRs = Err
    Resume frst_ErrToggleDbAndRs_Exit
End Function
Function frst_FIsQuery(stRecordSource As String) As Boolean
    frst_FIsQuery = (wlib_ObjTypOfSzRS(stRecordSource) = 2)
End Function
Function frst_FIsTable(stRecordSource As String) As Boolean
    frst_FIsTable = (wlib_ObjTypOfSzRS(stRecordSource) = 1)
End Function
Function auto_ErrInitEngine(stMdtFile As String) As Integer
On Error GoTo auto_ErrInitEngine_Err
    Dim errReturned As Long
    errReturned = frst_ErrToggleDbAndRs(True)
    If errReturned <> 0 Then Error errReturned
    frst_stMDTFile = stMdtFile
    Erase frst_rgsort
    frst_csort = 0
    auto_ErrInitEngine = 0
auto_ErrInitEngine_Exit:
    Exit Function
auto_ErrInitEngine_Err:
    auto_ErrInitEngine = Err
    Resume auto_ErrInitEngine_Exit
End Function
Function auto_ErrUnInitEngine() As Integer
On Error GoTo auto_ErrUnInitEngine_Err
    Dim errReturned As Long
    errReturned = frst_ErrToggleDbAndRs(False)
    If errReturned <> 0 Then Error errReturned
    auto_ErrUnInitEngine = 0
auto_ErrUnInitEngine_Exit:
    Exit Function
auto_ErrUnInitEngine_Err:
    auto_ErrUnInitEngine = Err
    Resume auto_ErrUnInitEngine_Exit
End Function
Function frst_StConcat(rgst() As String, c As Integer, stSep As String) As String
    Dim i As Integer
    Dim stRet As String
    For i = 0 To c - 1
        stRet = stRet & rgst(i)
        If i < (c - 1) Then
            stRet = stRet & stSep
        End If
    Next i
    frst_StConcat = stRet
End Function
Function frst_FInArray(j As Integer, rgi() As Integer, c As Integer) As Boolean
    Dim i As Integer
    For i = 0 To c - 1
        If j = rgi(i) Then
            frst_FInArray = True
            Exit Function
        End If
    Next i
End Function
Function frst_LRsTypeOmit() As Long
    frst_LRsTypeOmit = &H8& _
                    Or &H10& _
                    Or &H20& _
                    Or &H40& _
                    Or &H80& _
                    Or &H400&
End Function
Sub frst_PopulateAggFxnsArrays()
    ReDim frst_rgstAggFxns(0 To 8)
    frst_rgstAggFxns(0) = "Sum"
    frst_rgstAggFxns(1) = "Avg"
    frst_rgstAggFxns(2) = "Min"
    frst_rgstAggFxns(3) = "Max"
    frst_rgstAggFxns(4) = "Count"
    frst_rgstAggFxns(5) = "StdDev"
    frst_rgstAggFxns(6) = "Var"
    frst_rgstAggFxns(7) = "First"
    frst_rgstAggFxns(8) = "Last"
    ReDim frst_rgstAggFxnsLcl(0 To 9)
    frst_rgstAggFxnsLcl(0) = wlib_StFromAccessIds(14516)
    frst_rgstAggFxnsLcl(1) = wlib_StFromAccessIds(14517)
    frst_rgstAggFxnsLcl(2) = wlib_StFromAccessIds(14518)
    frst_rgstAggFxnsLcl(3) = wlib_StFromAccessIds(14519)
    frst_rgstAggFxnsLcl(4) = wlib_StFromAccessIds(14520)
    frst_rgstAggFxnsLcl(5) = wlib_StFromAccessIds(14521)
    frst_rgstAggFxnsLcl(6) = wlib_StFromAccessIds(14522)
    frst_rgstAggFxnsLcl(7) = wlib_StFromAccessIds(14523)
    frst_rgstAggFxnsLcl(8) = wlib_StFromAccessIds(14524)
    frst_rgstAggFxnsLcl(9) = wlib_StFromAccessIds(4625)
End Sub
Function frst_StNodeFromInod(inod As Integer, mdl As AUTO_DATAMODEL) As String
    frst_StNodeFromInod = mdl.rgnod(mdl.rginod(inod)).dbobj.stName
End Function
Function frst_InodMostMany(mdlT As AUTO_DATAMODEL) As Integer
    Dim i As Integer
    For i = 0 To mdlT.cNodes - 1
        If mdlT.rgnod(i).iManyness = -1 Then
            frst_InodMostMany = mdlT.rgnod(i).inod
            Exit Function
        End If
    Next i
End Function
Function frst_FTotalsRequired(fpkd As FPK_DATA, ilvlDetail As Integer) As Boolean
    Dim iFld As Integer
    Dim iAgg As Integer
    For iFld = 0 To fpkd.cfiSel - 1
        If frst_IFieldInfo(fpkd.rgfiSel(iFld), 2 ^ 27, 2 ^ 4 - 1) = ilvlDetail Then
            For iAgg = 0 To 3
                If fpkd.rgfiSel(iFld).lClientInfo And 2 ^ iAgg Then
                    frst_FTotalsRequired = True
                    Exit Function
                End If
            Next iAgg
        End If
    Next iFld
End Function
Function frst_FGrpSortField(iDataType As Integer) As Boolean
    If (iDataType <> dbLongBinary) And (iDataType <> dbMemo) Then frst_FGrpSortField = True
End Function
Function frst_LFromStRegValue(iDocType As Integer, stValueName As String, lMin As Long, lMax As Long, _
                              lDefault As Long) As Long
On Error GoTo frst_LFromStRegValue_ReturnDefault
    Dim hkeyRoot As Long
    Dim stKeyName As String
    Dim szRegValue As String * 255
    Dim lVal As Long
    If iDocType = acForm Then
        stKeyName = "Form Wizards"
    ElseIf iDocType = acReport Then
        stKeyName = "Report Wizards"
    ElseIf iDocType = acQuery Then
        stKeyName = "Query Wizards"
    Else
        stKeyName = "Preferences"
    End If
    If (0 <> wlib_OpenAccessRegKey("Wizards", hkeyRoot)) Then GoTo frst_LFromStRegValue_ReturnDefault
    If (0 = wlib_ErrGetRegVal(hkeyRoot, stKeyName, stValueName, ByVal szRegValue, Len(szRegValue))) Then
        lVal = CLng(wlib_StFromSz(szRegValue))
        If (lVal >= lMin) And (lVal <= lMax) Then
            frst_LFromStRegValue = lVal
            GoTo frst_LFromStRegValue_Exit
        End If
    End If
frst_LFromStRegValue_ReturnDefault:
    frst_LFromStRegValue = lDefault
frst_LFromStRegValue_Exit:
    Exit Function
End Function
Sub frst_HandleError(errCode As Long, iDocType As Integer)
    Dim id As Long
    Select Case errCode
        Case 20001
            id = 1024
        Case 53
            id = 152
        Case 32000
            id = 1153
        Case 32001
            id = 1156
        Case 31999
            If iDocType = acForm Then
                id = 1154
            ElseIf iDocType = acReport Then
                id = 1155
            End If
        Case 32002
            id = 1157
        Case Else
    End Select
    If id Then
        wlib_IMsgBox id, "", vbOKOnly + vbInformation
    ElseIf errCode <> 0 Then
        wlib_HandleError errCode, Error$
    End If
End Sub
Function frst_IFieldInfo(fi As FPK_FLDINFO, lOffset As Long, iStorageMask As Integer) As Integer
    frst_IFieldInfo = (fi.lClientInfo / lOffset) And iStorageMask
End Function
Sub frst_SetFieldInfo(iVal As Integer, fi As FPK_FLDINFO, lOffset As Long, iStorageMask As Integer, lLocationMask As Long)
    fi.lClientInfo = (fi.lClientInfo And lLocationMask) Or ((iVal And iStorageMask) * lOffset)
End Sub
Sub frst_RgifiFromWizardLvl(rgifiLvl() As Integer, cfiLvl As Integer, lvl As AUTO_LEVEL, fBottomLevel As Integer, _
                                fpkd As FPK_DATA, vw As AUTO_VIEW)
    Dim iNode As Integer
    Dim iFld As Integer
    Dim inodCurFld As Integer
    ReDim rgifiLvl(0 To (fpkd.cfiSel - 1))
    cfiLvl = 0
    For iFld = 0 To fpkd.cfiSel - 1
        If Not FAssignedToUserLevel(iFld, fpkd, vw) Then
            inodCurFld = frst_IFieldInfo(fpkd.rgfiSel(iFld), 2 ^ 19, 2 ^ 8 - 1)
            If inodCurFld = 255 Then
                If fBottomLevel Then
                    cfiLvl = cfiLvl + 1
                    rgifiLvl(cfiLvl - 1) = iFld
                End If
            Else
                For iNode = 0 To lvl.cNodes - 1
                    If lvl.rginod(iNode) = inodCurFld Then
                        cfiLvl = cfiLvl + 1
                        rgifiLvl(cfiLvl - 1) = iFld
                        Exit For
                    End If
                Next iNode
            End If
        End If
    Next iFld
    ReDim Preserve rgifiLvl(0 To (cfiLvl - 1))
End Sub
Function frst_FLonerFld(iFi As Integer, fpkd As FPK_DATA, vw As AUTO_VIEW) As Boolean
    Dim iFld As Integer
    Dim iLevel As Integer
    Dim ifiLevel As Integer
    ifiLevel = frst_IFieldInfo(fpkd.rgfiSel(iFi), 2 ^ 27, 2 ^ 4 - 1)
    For iLevel = 0 To vw.cLevels - 1
        If vw.rglvl(iLevel).fUserDefined Then
            If iLevel <> ifiLevel Then
                If vw.rglvl(iLevel).ifiGrpExpr = iFi Then
                    If vw.rglvl(iLevel).fFldAssigned Then
                        frst_FLonerFld = True
                        Exit Function
                    End If
                End If
            End If
        End If
    Next iLevel
    For iFld = 0 To fpkd.cfiSel - 1
        If iFld <> iFi Then
            If frst_IFieldInfo(fpkd.rgfiSel(iFld), 2 ^ 27, 2 ^ 4 - 1) = ifiLevel Then
                Exit Function
            End If
        End If
    Next iFld
    frst_FLonerFld = True
End Function
Private Function FAssignedToUserLevel(iFi As Integer, fpkd As FPK_DATA, vw As AUTO_VIEW)
    Dim iLevel As Integer
    For iLevel = 0 To vw.cLevels - 1
        If vw.rglvl(iLevel).fUserDefined Then
            If iFi = vw.rglvl(iLevel).ifiGrpExpr Then
                If vw.rglvl(iLevel).fFldAssigned Then
                    FAssignedToUserLevel = True
                    Exit Function
                End If
            End If
        End If
    Next iLevel
End Function
Public Function frst_StReplaceDot(st As String, stReplacement As String) As String
    Dim iDotPos As Integer
    iDotPos = InStr(st, ".")
    If iDotPos = 0 Then
        frst_StReplaceDot = st
    Else
        frst_StReplaceDot = Left$(st, iDotPos - 1) & stReplacement & Right$(st, Len(st) - iDotPos)
    End If
End Function

'---
Attribute VB_Name = "fl_modFieldLinker"
Option Compare Database
Option Explicit
Global fl_rgfiMaster()  As FPK_FLDINFO
Global fl_rgfiChild()  As FPK_FLDINFO
Global fl_cMasterFlds As Integer
Global fl_cChildFlds As Integer
Type FL_SNGLFIELD
    FAdded  As Integer
    iSrcIdx As Integer
    fiLink As FPK_FLDINFO
End Type
Type FL_SNGLLINK
    cFields As Integer
    iWeight As Integer
    rgsfMaster(0 To 3 - 1) As FL_SNGLFIELD
    rgsfChild(0 To 3 - 1) As FL_SNGLFIELD
End Type
Type FL_LINKINFO
    fAnalyze As Integer
    iSelectedLink As Integer
    cLinkPairs As Integer
    rgslPair(5) As FL_SNGLLINK
End Type
Global fl_liPanes As FL_LINKINFO
Global fl_iLoadLink As Integer
Global fl_rsStrings As Recordset
Global fl_dbCode As Database
Private Sub AddLinkFldFromFi(iLink As Integer, iFld As Integer, iType As Integer, iFi As Integer)
    Dim sf As FL_SNGLFIELD
    If iType = 1 Then
        sf.fiLink = fl_rgfiMaster(iFi)
        sf.FAdded = False
        sf.iSrcIdx = iFi
        fl_liPanes.rgslPair(iLink).rgsfMaster(iFld) = sf
    ElseIf iType = 2 Then
        sf.fiLink = fl_rgfiChild(iFi)
        sf.FAdded = False
        sf.iSrcIdx = iFi
        fl_liPanes.rgslPair(iLink).rgsfChild(iFld) = sf
    End If
End Sub
Private Sub AddLinkFldFromRel(iLink As Integer, iFld As Integer, iType As Integer, rel As Relation, irelfld As Integer)
    Dim fi As FPK_FLDINFO
    If iType = 1 Then
        fi.stName = rel.Fields(irelfld).Name
        fi.stRecSrc = rel.Table
        fi.stSrcTbl = rel.Table
        fi.stSrcFld = rel.Fields(irelfld).Name
        fl_liPanes.rgslPair(iLink).rgsfMaster(iFld).fiLink = fi
        fl_liPanes.rgslPair(iLink).rgsfMaster(iFld).FAdded = True
        fl_liPanes.rgslPair(iLink).rgsfMaster(iFld).iSrcIdx = -1
    ElseIf iType = 2 Then
        fi.stName = rel.Fields(irelfld).ForeignName
        fi.stRecSrc = rel.ForeignTable
        fi.stSrcTbl = rel.ForeignTable
        fi.stSrcFld = rel.Fields(irelfld).ForeignName
        fl_liPanes.rgslPair(iLink).rgsfChild(iFld).fiLink = fi
        fl_liPanes.rgslPair(iLink).rgsfChild(iFld).FAdded = True
        fl_liPanes.rgslPair(iLink).rgsfChild(iFld).iSrcIdx = -1
    End If
End Sub
Private Function FDupLink(rel As Relation) As Integer
    Dim i As Integer
    If rel.Fields.Count > 1 Then Exit Function
    For i = 1 To fl_liPanes.cLinkPairs - 1
        If rel.Fields(0).Name = fl_liPanes.rgslPair(i).rgsfMaster(0).fiLink.stSrcFld Then
            If rel.Fields(0).ForeignName = fl_liPanes.rgslPair(i).rgsfChild(0).fiLink.stSrcFld Then
                fl_liPanes.rgslPair(i).iWeight = 10
                FDupLink = True
                Exit Function
            End If
        End If
    Next i
End Function
Private Function FInArray(st As String, rgst() As String) As Integer
On Error GoTo FInArray_Err
    Dim i As Integer
    For i = LBound(rgst) To UBound(rgst)
        If st = rgst(i) Then
            FInArray = True
            Exit For
        End If
    Next i
FInArray_Exit:
    Exit Function
FInArray_Err:
   Resume FInArray_Exit
End Function
Private Sub FindNameLinks()
    Dim iMasterFld As Integer
    Dim iChildFld As Integer
    Dim iLink As Integer
    For iMasterFld = 0 To fl_cMasterFlds - 1
        For iChildFld = 0 To fl_cChildFlds - 1
            If (fl_rgfiMaster(iMasterFld).stSrcFld = fl_rgfiChild(iChildFld).stSrcFld) Then
                If fl_fMatchDataTypes(fl_rgfiMaster(iMasterFld).iType, fl_rgfiChild(iChildFld).iType) Then
                    iLink = fl_liPanes.cLinkPairs
                    fl_liPanes.rgslPair(iLink).cFields = 1
                    If ((fl_rgfiMaster(iMasterFld).lAttributes And &H10000000) > 0) Or ((fl_rgfiChild(iChildFld).lAttributes And &H40000000) > 0) Then
                        fl_liPanes.rgslPair(iLink).iWeight = 30
                    Else
                        fl_liPanes.rgslPair(iLink).iWeight = 40
                    End If
                    AddLinkFldFromFi iLink, 0, 1, iMasterFld
                    AddLinkFldFromFi iLink, 0, 2, iChildFld
                    fl_liPanes.cLinkPairs = iLink + 1
                    If fl_liPanes.cLinkPairs >= 5 Then Exit Sub
                End If
            End If
        Next iChildFld
    Next iMasterFld
End Sub
Private Sub FindRelLinks()
    Dim rgstMasterTables() As String
    Dim cMasterTables As Integer
    Dim rgstChildTables() As String
    Dim cChildTables As Integer
    Dim irel As Integer
    Dim irelfld As Integer
    Dim iMasterFld As Integer
    Dim iChildFld As Integer
    Dim rel As Relation
    Dim iLink As Integer
    Dim fFound As Integer
    Dim fImplicit As Integer
    Dim fi As FPK_FLDINFO
    For iMasterFld = 0 To fl_cMasterFlds - 1
        fi = fl_rgfiMaster(iMasterFld)
        If Not FInArray(fi.stSrcTbl, rgstMasterTables()) Then
            cMasterTables = cMasterTables + 1
            ReDim Preserve rgstMasterTables(cMasterTables - 1)
            rgstMasterTables(cMasterTables - 1) = (fi.stSrcTbl)
        End If
        If fi.stSrcTbl <> fi.stRecSrc Then
            If Not FInArray(fi.stRecSrc, rgstMasterTables()) Then
                cMasterTables = cMasterTables + 1
                ReDim Preserve rgstMasterTables(cMasterTables - 1)
                rgstMasterTables(cMasterTables - 1) = (fi.stRecSrc)
            End If
        End If
    Next iMasterFld
    For iChildFld = 0 To fl_cChildFlds - 1
        fi = fl_rgfiChild(iChildFld)
        If Not FInArray(fi.stSrcTbl, rgstChildTables()) Then
            cChildTables = cChildTables + 1
            ReDim Preserve rgstChildTables(cChildTables - 1)
            rgstChildTables(cChildTables - 1) = (fi.stSrcTbl)
        End If
        If fi.stRecSrc <> fi.stSrcTbl Then
            If Not FInArray(fi.stRecSrc, rgstChildTables()) Then
                cChildTables = cChildTables + 1
                ReDim Preserve rgstChildTables(cChildTables - 1)
                rgstChildTables(cChildTables - 1) = (fi.stRecSrc)
            End If
        End If
    Next iChildFld
    For irel = 0 To wlib_dbCur.Relations.Count - 1
        Set rel = wlib_dbCur.Relations(irel)
        If FInArray((rel.Table), rgstMasterTables()) Then
            If FInArray((rel.ForeignTable), rgstChildTables()) Then
                If Not FDupLink(rel) Then
                    fImplicit = False
                    iLink = fl_liPanes.cLinkPairs
                    fl_liPanes.rgslPair(iLink).cFields = rel.Fields.Count
                    If rel.Fields.Count < 3 Then
                        For irelfld = 0 To rel.Fields.Count - 1
                            For iMasterFld = 0 To fl_cMasterFlds - 1
                                If rel.Fields(irelfld).Name = fl_rgfiMaster(iMasterFld).stSrcFld Then
                                    AddLinkFldFromFi iLink, irelfld, 1, iMasterFld
                                    fFound = True
                                    Exit For
                                End If
                            Next iMasterFld
                            If Not fFound Then
                                AddLinkFldFromRel iLink, irelfld, 1, rel, irelfld
                                fImplicit = True
                            End If
                            fFound = False
                            For iChildFld = 0 To fl_cChildFlds - 1
                                If rel.Fields(irelfld).ForeignName = fl_rgfiChild(iChildFld).stSrcFld Then
                                    AddLinkFldFromFi iLink, irelfld, 2, iChildFld
                                    fFound = True
                                    Exit For
                                End If
                            Next iChildFld
                            If Not fFound Then
                                AddLinkFldFromRel iLink, irelfld, 2, rel, irelfld
                                fImplicit = True
                            End If
                        Next irelfld
                    End If
                    If fImplicit Then
                        fl_liPanes.rgslPair(iLink).iWeight = 20
                    Else
                        fl_liPanes.rgslPair(iLink).iWeight = 10
                    End If
                    fl_liPanes.cLinkPairs = iLink + 1
                    If fl_liPanes.cLinkPairs >= 5 Then Exit Sub
                End If
            End If
        End If
    Next irel
End Sub
Function fl_CGetFPKFromStRecSrc(db As Database, stRecSrc As String, rgfi() As FPK_FLDINFO, iObjType As Integer) As Integer
    Const I_OBJTYPESQL = -1
    Dim iFld As Integer
    Dim j As Integer
    Dim tqd As Object
    Dim rsi As WLIB_DBOBJ
    Dim rgfiOmit() As FPK_FLDINFO
    Dim cfiOmit As Integer
    Dim lrgbitDatatypeOmit As Long
    Dim cFi As Integer
    Dim ifiMax As Integer
    rsi.stName = stRecSrc
    Select Case wlib_ObjTypOfSzRS(stRecSrc)
        Case 1
            rsi.iObjType = acTable
        Case 2
            rsi.iObjType = acQuery
        Case Else
            rsi.iObjType = I_OBJTYPESQL
    End Select
    iObjType = rsi.iObjType
    If Not fpk_FGetFldsOfRecSrc(rsi, rgfiOmit(), cfiOmit, lrgbitDatatypeOmit, rgfi(), cFi, ifiMax) Then
        GoTo fl_CGetFPKFromStRecSrc_Exit
    End If
    For iFld = 0 To cFi - 1
        If rsi.iObjType = I_OBJTYPESQL Then rgfi(iFld).stRecSrc = wlib_StFromRsIds(6504, fl_rsStrings, "Message")
        If Not rgfi(iFld).fShowRsName Then
            For j = iFld + 1 To cFi - 1
                If rgfi(j).stName = rgfi(iFld).stName Then
                    rgfi(iFld).fShowRsName = True
                    rgfi(j).fShowRsName = True
                End If
            Next j
        End If
    Next iFld
    fl_CGetFPKFromStRecSrc = cFi
fl_CGetFPKFromStRecSrc_Exit:
    Exit Function
fl_CGetFPKFromStRecSrc_Err:
    fl_CGetFPKFromStRecSrc = 0
    Resume fl_CGetFPKFromStRecSrc_Exit
End Function
Sub fl_CleanLinks()
    fl_liPanes.iSelectedLink = 0
    fl_liPanes.fAnalyze = False
    fl_liPanes.cLinkPairs = 0
    Erase fl_liPanes.rgslPair
End Sub
Function fl_ErrCheckLink(frm As Object) As Integer
    Dim iFld As Integer
    Dim vMaster As Variant
    Dim vChild As Variant
    For iFld = 0 To 3 - 1
        vMaster = Nz((frm("cbMasterLink" & iFld)), "")
        vChild = Nz((frm("cbChildLink" & iFld)), "")
        If (Len(vMaster) > 0 And Len(vChild) = 0) Or (Len(vMaster) = 0 And Len(vChild) > 0) Then
            fl_ErrCheckLink = 6506
            Exit Function
        End If
    Next iFld
    fl_ErrCheckLink = 0
End Function
Function fl_ErrExistCustomLink(stMaster, stChild) As Integer
On Error GoTo fl_ErrExistCustomLink_Err
    Dim iStart As Integer
    Dim iLoc As Integer
    Dim iFld As Integer
    Dim cMaster As Integer
    Dim cChild As Integer
    Dim c As Integer
    fl_ErrExistCustomLink = 0
    If Len(stMaster) = 0 Or Len(stChild) = 0 Then
        fl_ErrExistCustomLink = 6504
        GoTo fl_ErrExistCustomLink_Exit
    End If
    iStart = 1
    If Right(stMaster, 1) <> ";" Then stMaster = stMaster & ";"
    iLoc = InStr(iStart, stMaster, ";")
    Do Until iLoc = 0
        For iFld = 0 To fl_cMasterFlds - 1
            If Mid(stMaster, iStart, iLoc - iStart) = fl_rgfiMaster(iFld).stName Then
                fl_liPanes.rgslPair(0).rgsfMaster(cMaster).iSrcIdx = iFld
                cMaster = cMaster + 1
                If cMaster = 3 Then Exit Do
                Exit For
            End If
        Next iFld
        c = c + 1
        iStart = iLoc + 1
        iLoc = InStr(iStart, stMaster, ";")
    Loop
    If c <> cMaster Then
        fl_ErrExistCustomLink = 6506
    End If
    iStart = 1
    c = 0
    If Right(stChild, 1) <> ";" Then stChild = stChild & ";"
    iLoc = InStr(iStart, stChild, ";")
    Do Until iLoc = 0
        For iFld = 0 To fl_cChildFlds - 1
            If Mid(stChild, iStart, iLoc - iStart) = fl_rgfiChild(iFld).stName Then
                fl_liPanes.rgslPair(0).rgsfChild(cChild).iSrcIdx = iFld
                cChild = cChild + 1
                If cChild = 3 Then Exit Do
                Exit For
            End If
        Next iFld
        c = c + 1
        iStart = iLoc + 1
        iLoc = InStr(iStart, stChild, ";")
    Loop
    If c <> cChild Then
        fl_ErrExistCustomLink = 6506
    End If
    If cMaster <> cChild Then
        fl_ErrExistCustomLink = 6506
        fl_liPanes.rgslPair(0).cFields = wlib_Min(cMaster, cChild)
    Else
        fl_liPanes.rgslPair(0).cFields = cMaster
    End If
fl_ErrExistCustomLink_Exit:
    Exit Function
fl_ErrExistCustomLink_Err:
    fl_ErrExistCustomLink = Err
    Resume fl_ErrExistCustomLink_Exit
End Function
Function fl_ErrInitEngine() As Integer
On Error GoTo fl_ErrInitEngine_Err
    Set fl_dbCode = CodeDb()
    Set fl_rsStrings = fl_dbCode.OpenRecordset("fl_tblStrings", dbOpenTable)
    fl_rsStrings.Index = "PrimaryKey"
    fl_ErrInitEngine = 0
fl_ErrInitEngine_Exit:
    Exit Function
fl_ErrInitEngine_Err:
    fl_ErrInitEngine = Err
    Resume fl_ErrInitEngine_Exit
End Function
Function fl_ErrSearchForLinks() As Integer
On Error GoTo fl_ErrSearchForLinks_Err
    Dim fDBOpened As Integer
    wlib_Hourglass True
    If Not fl_liPanes.fAnalyze Then GoTo fl_ErrSearchForLinks_Exit
    fl_liPanes.cLinkPairs = 1
    wlib_OpenCurrentDB
    fDBOpened = True
    fl_FillFPKIndx wlib_dbCur, fl_rgfiMaster()
    fl_FillFPKIndx wlib_dbCur, fl_rgfiChild()
    FindNameLinks
    FindRelLinks
    SortLinks
    fl_iLoadLink = 0
fl_ErrSearchForLinks_Exit:
On Error Resume Next
    If fDBOpened Then wlib_CloseCurrentDB
    wlib_Hourglass False
    Exit Function
fl_ErrSearchForLinks_Err:
    fl_ErrSearchForLinks = Err
    Resume fl_ErrSearchForLinks_Exit
End Function
Function fl_ErrUninitEngine() As Integer
On Error GoTo fl_ErrUninitEngine_Err
    fl_CleanLinks
    Erase fl_rgfiChild
    Erase fl_rgfiMaster
    fl_rsStrings.close
    fl_dbCode.close
fl_ErrUninitEngine_Exit:
    Exit Function
fl_ErrUninitEngine_Err:
    fl_ErrUninitEngine = Err
    Resume fl_ErrUninitEngine_Exit
End Function
Sub fl_FillFPKIndx(db As Database, rgfi() As FPK_FLDINFO)
    Dim iFPK As Integer
    Dim cFPK As Integer
    Dim idx As Index
    Dim cIdx As Integer
    Dim iidx As Integer
    Dim tbl As TableDef
    Dim stTbl As String
    cFPK = UBound(rgfi)
    For iFPK = 0 To cFPK - 1
        stTbl = STGetSrcTbl(rgfi(iFPK).stRecSrc, rgfi(iFPK).stSrcTbl, db)
        If Len(stTbl) > 0 Then
            Set tbl = db.TableDefs(stTbl)
            cIdx = tbl.Indexes.Count
            For iidx = 0 To cIdx - 1
                Set idx = tbl.Indexes(iidx)
                If idx.Fields.Count = 1 Then
                    If rgfi(iFPK).stName = idx.Fields(0).Name Then
                        If idx.Primary Then rgfi(iFPK).lAttributes = rgfi(iFPK).lAttributes Or &H10000000
                        If idx.Unique Then rgfi(iFPK).lAttributes = rgfi(iFPK).lAttributes Or &H20000000
                        If idx.Foreign Then rgfi(iFPK).lAttributes = rgfi(iFPK).lAttributes Or &H40000000
                    End If
                End If
            Next iidx
        End If
    Next iFPK
End Sub
Function fl_fMatchDataTypes(ByVal iTypeTo As Integer, ByVal iTypeFrom As Integer) As Integer
On Error GoTo fl_fMatchDataTypes_Err
    If (iTypeTo > dbText) Or (iTypeFrom > dbText) Then
        fl_fMatchDataTypes = False
    ElseIf (iTypeTo < dbText) And (iTypeFrom = dbText) Then
        fl_fMatchDataTypes = False
    ElseIf (iTypeTo = dbText) And (iTypeFrom < dbText) Then
        fl_fMatchDataTypes = False
    Else
        fl_fMatchDataTypes = True
    End If
fl_fMatchDataTypes_Exit:
    Exit Function
fl_fMatchDataTypes_Err:
    wlib_HandleError Err, Error$
    Resume fl_fMatchDataTypes_Exit
End Function
Function fl_STBuildFldName(fi As FPK_FLDINFO) As String
On Error GoTo fl_STBuildFldName_Err
    If fi.fShowRsName Then
        fl_STBuildFldName = fi.stRecSrc & "." & fi.stName
    Else
        fl_STBuildFldName = fi.stName
    End If
fl_STBuildFldName_Exit:
    Exit Function
fl_STBuildFldName_Err:
    fl_STBuildFldName = ""
    Resume fl_STBuildFldName_Exit
End Function
Function fl_StFromIds(id As Integer) As String
    fl_StFromIds = wlib_StFromRsIds((id), fl_rsStrings, "Message")
End Function
Function fl_StFromIdsWithInsert(id As Integer, st As String) As String
    fl_StFromIdsWithInsert = wlib_StFromRsIdsWithInsert((id), fl_rsStrings, "Message", st)
End Function
Function fl_StGetLinkDesc(sl As FL_SNGLLINK) As String
On Error GoTo fl_stGetLinkDesc_Err
    Dim stDesc As String
    Dim stList As String
    Dim iFld As Integer
    If sl.cFields > 0 Then
        For iFld = 0 To sl.cFields - 1
            stList = stList & fl_STBuildFldName(sl.rgsfMaster(iFld).fiLink)
            If (iFld < sl.cFields - 1) Then stList = stList & ", "
        Next iFld
        stDesc = fl_StFromIdsWithInsert(6505, sl.rgsfChild(0).fiLink.stRecSrc & "|" & sl.rgsfMaster(0).fiLink.stRecSrc & "|" & stList)
    Else
        stDesc = fl_StFromIds(6502)
    End If
    fl_StGetLinkDesc = stDesc
fl_stGetLinkDesc_Exit:
    Exit Function
fl_stGetLinkDesc_Err:
    Resume fl_stGetLinkDesc_Exit
End Function
Private Sub SortLinks()
    Dim i1 As Integer
    Dim i2 As Integer
    Dim slTmp As FL_SNGLLINK
    For i1 = 1 To fl_liPanes.cLinkPairs - 1
        For i2 = i1 + 1 To fl_liPanes.cLinkPairs - 1
            If (fl_liPanes.rgslPair(i2).iWeight < fl_liPanes.rgslPair(i1).iWeight) Then
                slTmp = fl_liPanes.rgslPair(i1)
                fl_liPanes.rgslPair(i1) = fl_liPanes.rgslPair(i2)
                fl_liPanes.rgslPair(i2) = slTmp
            End If
        Next i2
    Next i1
End Sub
Function STGetSrcTbl(stRecSrc As String, stSrcTbl As String, db As Database) As String
    If wlib_ObjTypOfSzRS(stRecSrc) = 1 Then
        STGetSrcTbl = stRecSrc
    Else
        STGetSrcTbl = stSrcTbl
    End If
End Function
'---
Attribute VB_Name = "bw_ModEntry"
Option Compare Database
Option Explicit
Type BW_UIINFO
    iCatID As Integer
    iActionID As Integer
    stName As String
    iBtnFace As Integer
    iPictureID As Integer
    stCaption As String
    fShowAllPictures As Boolean
    stBmpFile As String
    fSizeToFit As Integer
    stSuggestedPictureIDs As String
    fNeedDocName As Boolean
    fShowHelp As Boolean
    stDocName As String
    stAppName As String
    stLnkToDataSrc As String
    stLnkFromFld As String
    stLnkToFld As String
    iLnkToType As Integer
    fLnkFrms As Boolean
End Type
Global bw_DBCode As Database
Global bw_UserFrm As Form
Global bw_UserCtl As Control
Global bw_uii As BW_UIINFO
Function bw_Entry(stCtlName As String, stLblName As String) As Variant
On Error GoTo bw_Entry_Err
    Const ERR_FORMOPENCANCEL = 2501
    Const ERR_BADEXPR = 2473
    Dim rsStrings As Recordset
    Dim fDbCurOpen As Boolean
    Dim fAddInStarted As Boolean
    If (Application.CurrentObjectType = acForm) Then
        wlib_OpenCurrentDB
        fDbCurOpen = True
        Set bw_DBCode = CodeDb()
        Set rsStrings = bw_DBCode.OpenRecordset("bw_TblStrings", DB_OPEN_TABLE)
        rsStrings.Index = "PrimaryKey"
        wlib_StartAddIn 3005, rsStrings, "String"
        fAddInStarted = True
        Set bw_UserFrm = Screen.ActiveForm
        DoCmd.OpenForm "bw_FrmMain", , , , , acDialog
    End If
bw_Entry_Exit:
    On Error Resume Next
    rsStrings.close
    bw_DBCode.close
    If fDbCurOpen Then wlib_CloseCurrentDB
    If fAddInStarted Then wlib_EndAddIn
    Exit Function
bw_Entry_Err:
    Select Case Err
        Case ERR_FORMOPENCANCEL
        Case ERR_BADEXPR
            On Error Resume Next
            MsgBox wlib_StFromIds(2008)
        Case Else
            MsgBox Error$
    End Select
    Resume bw_Entry_Exit
End Function
Function pp_Entry(stObjName As String, stCtlName As String, stVal As String)
On Error GoTo pp_Entry_Err
    Dim rsStrings As Recordset
    Dim fDocSelected As Boolean
    Dim oDoc As Object
    Set bw_DBCode = CodeDb()
    Set rsStrings = bw_DBCode.OpenRecordset("bw_TblStrings", DB_OPEN_TABLE)
    rsStrings.Index = "PrimaryKey"
    wlib_StartAddIn 3022, rsStrings, "String"
    Select Case (Application.CurrentObjectType)
        Case acForm
            Set oDoc = Forms(stObjName)
        Case acReport
            Set oDoc = Reports(stObjName)
    End Select
    Set bw_UserCtl = oDoc(stCtlName)
    If (bw_UserCtl.ControlType = acCommandButton) Or (bw_UserCtl.ControlType = acToggleButton) Or (bw_UserCtl.ControlType = acPage) Then
        GoTo pp_WizardUI
    End If
pp_OfficeUI:
    Dim stBmpFile As String
    wlib_FGetPictureFileName stBmpFile
    If (stBmpFile <> "") Then
        If (Dir$(stBmpFile) <> "") Then
            If (fDocSelected) Then
                oDoc.Picture = stBmpFile
            Else
                bw_UserCtl.Picture = stBmpFile
            End If
        Else
            wlib_IMsgBox 2011, stBmpFile, vbInformation
        End If
    End If
    GoTo pp_Entry_Exit
pp_WizardUI:
    DoCmd.OpenForm "pb_FrmPictureBuilder", , , , , acDialog
pp_Entry_Exit:
    On Error Resume Next
    rsStrings.close
    bw_DBCode.close
    wlib_EndAddIn
    Exit Function
pp_Entry_Err:
    If (Err = 2465) Then
        fDocSelected = True
        Resume pp_OfficeUI
    Else
        MsgBox Error$
        Resume pp_Entry_Exit
    End If
End Function
Public Sub bw_ErrAlert(ErrId As Long, stInsert As String)
    wlib_IMsgBox ErrId, stInsert, vbInformation
End Sub
Public Function bw_stGetBmpFile(ByVal Hwnd As Long, stFilter As String) As String
        Dim lErr As Long
        Dim gfni As WLIB_OFFICEGETFILENAMEINFO
        gfni.hwndOwner = Hwnd
        gfni.szFilter = stFilter
        gfni.nFilterIndex = 0
        gfni.szAppName = ""
        gfni.szOpenTitle = ""
        gfni.szDlgTitle = wlib_StFromIds(3021)
        gfni.flags = &H2 Or &H10 Or &H40
        gfni.szFile = ""
        gfni.szInitialDir = SysCmd(SYSCMD_ACCESSDIR) & "Bitmaps"
        gfni.lView = 1
        lErr = wlib_OfficeGetFileName(gfni, True)
        If (lErr = 0) Then
            bw_stGetBmpFile = RTrim(gfni.szFile)
        End If
End Function
'---
Attribute VB_Name = "apwz_modGlobals"
Option Compare Database
Option Explicit
Type APWZ_GLOBALSTRUCT
    lDbTypeID As Long
    stDbType As String
    stDbTypeImgFile As String
    stStartupCode As String
    stGlobalCode As String
    rgcti() As TW_CREATETABLEINFO
    ccti As Integer
    lFrmStyle As Long
    lRptStyle As Long
    stAppName As String
    stBitmap As String
    fBitmap As Integer
    stMdtFile As String
    fStart As Integer
    fWantHelp As Integer
    fSampleData As Integer
    fFinished As Integer
End Type
Global apwzg As APWZ_GLOBALSTRUCT
Global apwz_dbCode As Database
Global apwz_dbData As Database
Global apwz_rsStrings As Recordset
Public Function apwz_Entry(lDbID As Long) As Integer
On Error GoTo apwz_Entry_Err
    Dim errReturned As Long
    Dim rsDbTypes As Recordset
    Dim fAddInStarted As Integer
    Dim rsCode As Recordset
    Set apwz_dbCode = CodeDb()
    Set apwz_rsStrings = apwz_dbCode.OpenRecordset("apwz_tblStrings", dbOpenTable)
    apwz_rsStrings.Index = "PrimaryKey"
    wlib_StartAddIn 5002, apwz_rsStrings, "String"
    fAddInStarted = True
    errReturned = wlib_ErrGetMdtPath(True, apwzg.stMdtFile)
    If (errReturned <> 0) Then
        GoTo apwz_Entry_Exit:
    End If
    Set apwz_dbData = OpenDatabase(apwzg.stMdtFile, False, True)
    apwzg.lDbTypeID = lDbID - 100
    apwzg.ccti = 0
    apwzg.lFrmStyle = 0
    apwzg.lRptStyle = 0
    apwzg.stBitmap = ""
    apwzg.fBitmap = False
    apwzg.fStart = True
    apwzg.fWantHelp = False
    apwzg.fSampleData = False
    apwzg.fFinished = False
    styl_fAppWizard = True
    Set rsDbTypes = apwz_dbData.OpenRecordset("tblDatabaseTypes", dbOpenTable, dbForwardOnly Or dbReadOnly)
    rsDbTypes.Index = "PrimaryKey"
    rsDbTypes.Seek "=", apwzg.lDbTypeID
    apwzg.stAppName = rsDbTypes![DatabaseTypeName]
    apwzg.stDbType = apwzg.stAppName
    apwzg.stDbTypeImgFile = SysCmd(acSysCmdAccessDir) & rsDbTypes![ImageFile]
    apwzg.stStartupCode = Nz(rsDbTypes![StartupCode], "")
    Set rsCode = apwz_dbCode.OpenRecordset("sbm_tblCode")
    rsCode.Index = "PrimaryKey"
    rsCode.Seek "=", 3
    wlib_ReplaceStr apwzg.stStartupCode, "|MINIMIZEDBC", rsCode![Code]
    rsCode.Seek "=", 4
    wlib_ReplaceStr apwzg.stStartupCode, "|GOTODEFAULT", rsCode![Code]
    If (rsDbTypes![RequiresIsLoaded]) Then
        rsCode.Seek "=", 2
        apwzg.stGlobalCode = rsCode![Code]
    End If
    rsCode.close
    rsDbTypes.close
    DoCmd.OpenForm "apwz_frmMain", , , , , acDialog
apwz_Entry_Exit:
On Error Resume Next
    apwz_rsStrings.close
    apwz_dbData.close
    apwz_dbCode.close
    If (fAddInStarted) Then wlib_EndAddIn
    apwz_Entry = apwzg.fFinished
    styl_fAppWizard = False
    Exit Function
apwz_Entry_Err:
    wlib_HandleError Err, Error$
    Resume apwz_Entry_Exit
End Function
Public Function apwz_CfldiGetFldiOfTblID(lTableID As Long, rgfldi() As TW_FLDINFO) As Integer
    Dim qd As QueryDef
    Dim rsFields As Recordset
    Dim cfldi As Integer
    Set qd = apwz_dbData.QueryDefs("apwz_qryTableFields")
    qd.Parameters("ParamDatabaseTypeID") = apwzg.lDbTypeID
    qd.Parameters("ParamTableID") = lTableID
    Set rsFields = qd.OpenRecordset(dbOpenDynaset, dbReadOnly)
    rsFields.MoveLast
    rsFields.MoveFirst
    ReDim rgfldi(0 To rsFields.RecordCount - 1)
    While (Not (rsFields.EOF))
        If (CLng(rsFields![Status]) <> 2) Then
            With rgfldi(cfldi)
                .iFldIndex = cfldi
                .lFldID = rsFields![FieldID]
                .stFldName = Nz(rsFields![FieldName], "")
                .iDataType = rsFields![DataType]
                .iSize = Nz(rsFields![FieldSize], 0)
                .stCaption = Nz(rsFields![Caption], "")
                .fPK = rsFields![PrimaryKey]
                .lLookupTableID = Nz(rsFields![LookupTableID], 0)
                .lFlags = 0
                If (rsFields![Status].Value = 0) Then
                    .lFlags = .lFlags Or &H1& Or &H2&
                End If
                Select Case (rsFields![Index].Value)
                    Case 1
                        .lFlags = .lFlags Or &H4
                    Case 2
                        .lFlags = .lFlags Or &H8
                End Select
                If (.lLookupTableID <> 0) Then
                    apwz_SelectTbl .lLookupTableID, (.lFlags And &H2&)
                End If
            End With
            cfldi = cfldi + 1
        End If
        rsFields.MoveNext
    Wend
    rsFields.close
    apwz_CfldiGetFldiOfTblID = cfldi
End Function
Public Function apwz_SelectTbl(ByVal lTableID As Long, fSelect As Integer) As Integer
    Dim icti As Integer
    For icti = 0 To apwzg.ccti - 1
        With apwzg.rgcti(icti)
            If (.lTableID = lTableID) Then
                If (fSelect) Then
                    .lFlags = .lFlags Or &H1&
                Else
                    .lFlags = .lFlags And (Not &H1&)
                End If
                Exit Function
            End If
        End With
    Next icti
End Function
Public Function apwz_LAddressTypeCode() As Long
    Dim LCID As Long
    LCID = wlib_GetUserDefLCID()
    Select Case LCID
        Case &H809, &H1009, &H1409, &HC09, &H1809, &H1C09, &H816, &H416, &H409
            apwz_LAddressTypeCode = 1
        Case Else
            apwz_LAddressTypeCode = 2
    End Select
End Function
'---
Attribute VB_Name = "af_modUtil"
Option Compare Database
Option Explicit
Type AF_CONTROLINFO
    x As Integer
    y As Integer
    dx As Integer
    dy As Integer
    stFontName As String
    iFontSize As Integer
    iFontWeight As Integer
    fItalic As Integer
    fUnderline As Integer
    fChanged As Integer
    fInSelection As Boolean
End Type
Type AF_SBE_PROPVAL
    vValue As Variant
    cValue As Integer
End Type
Type AF_SBE_PROP
    csbev As Integer
    rgsbev() As AF_SBE_PROPVAL
End Type
Type AF_SBE_CTL
    fFound As Integer
    fHaveLabelInfo As Boolean
    bmLabelPos As Long
    dxLabelOffset As Integer
    dyLabelOffset As Integer
End Type
Type AF_SBE_SECT
    fFound As Integer
    rgsbec(0 To 18) As AF_SBE_CTL
End Type
Type AF_CTINFO
    iControlType As Integer
    stControlTypeName As String
End Type
Global af_iCurrentObjectType As Integer
Global af_stCurrentObjectName As String
Global af_dbCode As Database
Global af_rsStrings As Recordset
Global af_stMdtFile As String
Global af_lDialogResult As Long
Global af_stNewStyleName As String
Global af_stControlTypesVL As String
Function af_Entry()
On Error GoTo af_Entry_Err
    Dim errReturn As Integer
    Dim fStylesInited As Integer
    Dim fAddInStarted As Integer
    af_iCurrentObjectType = Application.CurrentObjectType
    af_stCurrentObjectName = Application.CurrentObjectName
    Set af_dbCode = CodeDb()
    Set af_rsStrings = af_dbCode.OpenRecordset("af_tblStrings", dbOpenTable)
    af_rsStrings.Index = "PrimaryKey"
    wlib_StartAddIn 1, af_rsStrings, "Message"
    fAddInStarted = True
    errReturn = styl_ErrInitEngine(af_stMdtFile, True)
    If errReturn <> 0 Then
        If errReturn = 53 Then
            wlib_IMsgBox 100, af_stMdtFile, vbOKOnly Or vbInformation
            GoTo af_Entry_Exit
        Else
            Err.Raise errReturn
        End If
    End If
    fStylesInited = True
    errReturn = styl_ErrInitCartoon(af_iCurrentObjectType, styl_LDefaultStyle(af_iCurrentObjectType, False), _
                af_stMdtFile, "af_frmAutoFormat", True, _
                wlib_StFromIdsWithInsert(2, wlib_StObjFromIObj(af_iCurrentObjectType)), _
                8749, "acmain80.hlp>Ref")
    If errReturn <> 0 Then Error errReturn
    DoCmd.OpenForm "af_frmAutoformat", , , , , acDialog
af_Entry_Exit:
On Error Resume Next
    If fStylesInited Then styl_ErrUninitEngine
    If fAddInStarted Then wlib_EndAddIn
    af_rsStrings.close
    af_dbCode.close
    Exit Function
af_Entry_Err:
    wlib_HandleError Err, Error$
    Resume af_Entry_Exit
End Function
Function af_IsbecFromICtlType(iCtlType As Integer) As Integer
    Select Case iCtlType
        Case acTextBox
            af_IsbecFromICtlType = 1
        Case acLabel
            af_IsbecFromICtlType = 0
        Case acListBox
            af_IsbecFromICtlType = 3
        Case acComboBox
            af_IsbecFromICtlType = 4
        Case acRectangle
            af_IsbecFromICtlType = 2
        Case acLine
            af_IsbecFromICtlType = 7
        Case acCommandButton
            af_IsbecFromICtlType = 8
        Case acOptionButton
            af_IsbecFromICtlType = 9
        Case acCheckBox
            af_IsbecFromICtlType = 10
        Case acOptionGroup
            af_IsbecFromICtlType = 11
        Case acBoundObjectFrame
            af_IsbecFromICtlType = 12
        Case acObjectFrame
            af_IsbecFromICtlType = 6
        Case acSubform
            af_IsbecFromICtlType = 5
        Case acToggleButton
            af_IsbecFromICtlType = 14
        Case acPageBreak
            af_IsbecFromICtlType = 13
        Case acImage
            af_IsbecFromICtlType = 15
        Case acCustomControl
            af_IsbecFromICtlType = 16
        Case acTabCtl
            af_IsbecFromICtlType = 17
        Case acPage
            af_IsbecFromICtlType = 18
        Case Else
    End Select
End Function

'---
'program to generate VB script.
'generate a class module (.CLS) containing a SINGLE class.


#include "basgendc.inc"


' globals
dim shared base$                        as string
dim shared classname$                   as string
dim shared base_set%                    as int
dim shared lang_id&                     as long
dim shared UseDefaultFName              as int
dim shared ClassNumber                  as int
dim shared DefaultFileName$             as string
dim shared FileExtension$               as string
dim shared IgnoreClassFile$             as string
dim shared UpdateClassFile$             as string
dim shared OverwriteOutputPrompt$       as string
dim shared VisitedFiles$                as string
dim shared OutputPath$                  as string
dim shared SummaryFile$                                 as string

' Yes, much of this GSU code is ugly. It has by quickly generated by copying and pasting the original code
' wrobinson@gsu.edu
' GSU parameters

dim shared attributeNames$ As String     'Space separated list of Attribute names in class current generation
dim shared attributeMethodNames$ As String     'Space separated list of Attribute Method names in class current generation
dim shared methodNames$ As String     'Space separated list of Method names in class current generation
dim shared attrPrefix$ As String        'Prefix for attributes
dim shared proxyForAttr$ As String    'Name of attribute in proxy class that points to domain class (indicates proxy)
dim shared proxyAttr$ As String         'Name of attribute in domain class that points to proxy (indicates domain class)
dim shared proxyClass as int                   '1 if class is a proxy class
dim shared proxyClassType$ as String	       ' Type of current proxy class being considered
dim shared configStr$ As String	       ' MsgBox message
dim shared mainModule$ As String	       ' Name of class for which to generate a module
dim shared generateInheritence as int	      ' Determines if inheritence properties will be generated
dim shared generateProxyProperties as int  ' Determines if proxy attributes & methods will be generated
dim shared generateGetMethod as int	      ' Determines if get methods will be generated
dim shared generateLetMethod as int	      ' Determines if let methods will be generated
dim shared generateSetMethod as int	      ' Determines if set methods will be generated
dim shared generateCreateMethod as int     ' Determines if a creation method will be generated
dim shared getAccess$ As String	      ' Access types....
dim shared letAccess$ As String
dim shared setAccess$ As String
dim shared createAccess$ As String
dim shared doingSuperClass as int
dim shared matchedClassId& as Long
dim shared proxyClassId& as Long

main basmain
  mainModule$ = "Startup"
  attrPrefix$ = "m_"
  proxyForAttr$ = "proxyFor"
  proxyAttr$ = "proxy"
  generateInheritence = 1
  generateProxyProperties = 1
  generateLetMethod = 1
  generateSetMethod = 1
  generateGetMethod = 1
  generateCreateMethod = 1
  getAccess$ = "Public"
  letAccess$ = "Public"
  setAccess$ = "Public"
  createAccess$ = "Public"
  doingSuperClass = 0
  
  configStr$ = "Starting GSU VB Generation with the following configuration... "
  configStr$ = configStr$ + Chr$(13) + Chr$(10) + "  Code generation can be configured; see variables in the generation script."
  configStr$ = configStr$ + Chr$(13) + Chr$(10) + "  Can be configured to generate code for:"
  configStr$ = configStr$ + Chr$(13) + Chr$(10) + "    inheritence, Let/Get/Set methods, Create methods, proxy properties"
  configStr$ = configStr$ + Chr$(13) + Chr$(10) + "  Assumes the following about YOUR model or code fragments:"
  configStr$ = configStr$ + Chr$(13) + Chr$(10) + "	Assumes Main Module (if present) is a class named '" + mainModule$ + "'"
  configStr$ = configStr$ + Chr$(13) + Chr$(10) + "	Assumes attribute prefix for code generation is '" + attrPrefix$ + "'"
  configStr$ = configStr$ + Chr$(13) + Chr$(10) + "	Assumes proxy has attribute '" + proxyForAttr$ + "'"
  configStr$ = configStr$ + Chr$(13) + Chr$(10) + "	Assumes domain class has attribute '" + proxyAttr$ + "'"
  configStr$ = configStr$ + Chr$(13) + Chr$(10) + "  Generating the following methods:"
  configStr$ = configStr$ + Chr$(13) + Chr$(10) + "      Get/Let/Set attribute methods from domain class in proxy that forward to domain class."
  If generateInheritence Then
     configStr$ = configStr$ + Chr$(13) + Chr$(10) + "      - inheritence properties (attributes & methods)."
  End If
  If generateProxyProperties Then
     configStr$ = configStr$ + Chr$(13) + Chr$(10) + "      - methods from domain class in proxy that forward to domain class."
  End If
  configStr$ = configStr$ + Chr$(13) + Chr$(10) + "      - defining Class_Create method for each class."
  If generateGetMethod Then
    configStr$ = configStr$ + Chr$(13) + Chr$(10) + "	- generating Get methods for each class"
    configStr$ = configStr$ + Chr$(13) + Chr$(10) + "	    Get access is " + getAccess$
  End If
  If generateLetMethod Then
    configStr$ = configStr$ + Chr$(13) + Chr$(10) + "	- generating Let methods for each class"
    configStr$ = configStr$ + Chr$(13) + Chr$(10) + "	    Let access is " + letAccess$
  End If
  If generateSetMethod Then
    configStr$ = configStr$ + Chr$(13) + Chr$(10) + "	- generating Set methods for each class"
    configStr$ = configStr$ + Chr$(13) + Chr$(10) + "	    Let access is " + setAccess$
  End If
  If generateCreateMethod Then
    configStr$ = configStr$ + Chr$(13) + Chr$(10) + "	- generating Create methods"
    configStr$ = configStr$ + Chr$(13) + Chr$(10) + "	    Create access is " + createAccess$
  End If
  
  MsgBox configStr$, "Basic Generator", BAS_MSG_ATTENTION
  
'  MsgBox "Starting VB Generation " + "Methods: Let is " + generateLetMethod + " Get " + generateGetMethod + " Create " + generateCreateMethod, "Basic Generator", BAS_MSG_ATTENTION

  ' Set the language in use
  lang_id& = BASGenSetLang(g_session&, "VisualBasic")

  ' Get the file extension
  FileExtension$ = BASGenGetLangExt(g_session&)

  ' determine the default filename
  DefaultFileName$ = BASGenGetDefaultFileName(g_session&)

  ' Determine whether we should use the filename stored against a class
  IgnoreClassFile$ = BASGenGetIgnoreClassFile(g_session&)

  ' Determine whether we should update the filename stored against a class
  UpdateClassFile$ = BASGenGetUpdateClassFile(g_session&)

  ' Determine whether we should prompt the user before overwriting existing
  ' output files
  OverwriteOutputPrompt$ = BASGenGetOverwriteOutput(g_session&)

  OutputPath$ = GetPath$(DefaultFileName$)

  DefaultFileName$ = GetFileName$(DefaultFileName$)

'  msgbox "Path='" + OutputPath$ + "', FileName='" + DefaultFileName$ + "'",
'         "Vb", 0


        'Open summary file
        SummaryFile$ = BasGenGetSummaryFile(g_session&)
        BasGenSetOut (SummaryFile$)
        Print "The following classes were output to the files listed:"
        Print " "
        
 
  'apply the DoClass subroutine to each of the classes
  ClassNumber = 0
  VisitedFiles$ = ""
  BasGenListApply(g_classes&,"DoClass")

  MsgBox "Completed VB Generation for GSU", "Basic Generator", BAS_MSG_ATTENTION
end main

Sub GetClassPtr& (className$)
   
  matchedClassId& = 0
  BasGenListApply(g_classes&,"MatchClassName")
  If matchedClassId& Then
      newName$ = BasGenGetClassString(matchedClassId&, "Name")
  End If
  GetClassPtr& = matchedClassId&
End Sub

Sub MatchClassName ()

   ' the g_id is set on entry.
  ' make local copy incase we make other calls
''  classId& = g_id&

  foundName$ = BasGenGetClassString(g_id&, "Name")
  If lcase$(foundName$) = lcase$(className$) Then
      matchedClassId& =  g_id&
  End If
End Sub

sub GetPath$(file$)
  dim count% as integer
  dim finished% as integer
  dim t$ as string

  count% = Len(file$)
  finished% = 0
  While finished% = 0
    t$ = Mid$(file$, count%, 1)

    If t$ = Mid$("\\", 1, 1) Then
      finished% = 21
    Else
      count% = count% - 1
    End If

    If count% = 0 Then
      finished% = 1
    End If
  Wend

  GetPath$ = Mid$(file$, 1, count%)
End Sub

Function GetFileName$(file$)
  dim count% as integer
  dim finished% as integer
  dim t$ as string

  count% = Len(file$)
  finished% = 0
  While (finished% = 0)
    t$ = Mid$(file$, count%, 1)

    If t$ = Mid$("\\", 1, 1) Then
      finished% = 1
    Else
      count% = count% - 1
    End If

    If (count% = 0) Then
      finished% = 1
    End If
  Wend

  GetFileName$ = Mid$(file$, count + 1, Len(file$))
End Function




Sub DoClass()
  dim FName$  as String
  dim VFName$ as String
  dim Num$    as String




  ' the g_id is set on entry.
  ' make local copy incase we make other calls
  classId& = g_id&

  ddid& = BasGenGetClassLong(classId&, "ddid")
  classname$ = BasGenGetClassString(classId&, "Name")

  'log to the screen
  a$ = "Processing Class: " + classname$
  BasGenLog (a$)



  ' Do we extract the class's own local filename?
  If (IgnoreClassFile$ = "N") Then
    FName$ = BasGenGetProp(classId&, "Class Header File")
  Else
    ClassNumber = ClassNumber + 1
    Num$ = Str$(ClassNumber)

    If (Len(FName$) + Len(Num$)) > 8 Then
      FName$ = Mid$(DefaultFileName$, 1, 8 - Len(Num$))
    Else
      FName$ = DefaultFileName$ + Num$
    End If
  End If



  FName$ = OutputPath$ + FName$


  If InStr(1, FName$, ".") = 0 Then
    FName$ = FName$ + "." + FileExtension$
  End If

        'Write class and file info to summary file
        BasGenSetOutAppend (SummaryFile$)
        Size% = 41    '  MAXNAME+10
        FillBuff$ = String$(Size%, " ")
        FillBuff$ = Mid$(FillBuff$, 1, 39 - Len(classname$) + 1)
        Print classname$ + FillBuff$ + FName$

  VFName$ = "," + Chr$(34) + FName$ + Chr$(34)

  If (InStr(1, VisitedFiles$, VFName$) = 0) Then
    BasGenSetOut (FName$)
    VisitedFiles$ = VisitedFiles$ + VFName$
  Else
    MsgBox "Could not export class '" + classname$ + "'; the target file"
         + "had already been written to with another class",
         "Basic Generator", BAS_MSG_ATTENTION

  End If

  


  ' Print the class file header...
  If classname$ =  mainModule$ Then
     msg$ = "Found class " + mainModule$
     msg$ = msg$ + Chr$(13) + Chr$(10) + "  Creating VB Module with Public Get/Let methods."
    MsgBox msg$, "GSU Generator", BAS_MSG_ATTENTION
    Print "'UML Class Startup is a reserved class in the GSU generation"
    Print "'UML Class Startup is defined as a VB Module"
    Print "Attribute VB_Name = " + Chr$(34) + classname$ + Chr$(34)
    Print " "

  Else
    Print "VERSION 1.0 CLASS"
    Print "BEGIN"
    Print "  MultiUse = -1  'True"
    Print "END"
    Print "Attribute VB_Name = " + Chr$(34) + classname$ + Chr$(34)
    Print "Attribute VB_Creatable = False"
    Print "Attribute VB_Exposed = False"
    Print "Option Explicit"
    Print " "
  End If


  'determine parent classes...
  ' no point; VB does not support inheritence.
  ' See below....


  ' constants...

saved_classname$ = classname$

  'log to the screen
  a$ = "Processing Class: " + classname$ + " - Constants"
  BasGenLog (a$)

  ' Get constant declarations...
  const$ = BasGenGetProp(classId&,"VB Constants")
  
  ' Print the declarations...
  if len(const$)>0 then
    print const$
    Print " "
  End If



  ' types...

  'log to the screen
  a$ = "Processing Class: " + classname$ + " - Types"
  BasGenLog (a$)

  ' Get tyoe declarations...
  type$ = BasGenGetProp(classId&,"VB Types")
  
  ' Print the declarations...
  if len(type$)>0 then
    print type$
    Print " "
  End If


  attributeNames$ = ""
  'log to the screen
  a$ = "Processing Class: " + classname$ + " - Attributes"
  BasGenLog (a$)

  ' Get list of attributes...
  Print " "
  Print "'******************************"
  Print "'Attributes of the BASE class: " + classname$ + " ..."
  Print " "
  'Proxy class determined within DoAttributes loop...
  proxyClass = 0
  proxyClassType$ = ""
  attrList& = BasGenGetClassLong(classId&, "Attributes")
  BasGenListApply(attrList&,"DoAttributes")
  Print " "


  If generateInheritence Then
  ' attributes...
    'determine parent classes...
  'Fake inheritance with attributes of class type (VB does not support inheritence).
          'Output parent classes
        superList& = BasGenGetClassLong(classId&, "SuperClasses")
        BasGenListApply(superList&,"SuperClassAttributes")
   Print " "
  End If

  attributeMethodNames$ = ""
  'log to the screen
  a$ = "Processing Class: " + classname$ + " - Attributes Methods"
  BasGenLog (a$)

  ' Get list of attributes...
  Print " "
  Print "'******************************"
  Print "'Attribute methods of the base class " + classname$ + " ..."
  Print " "
  attrList& = BasGenGetClassLong(classId&, "Attributes")
  BasGenListApply(attrList&,"DoAttributeMethods")
  Print " "

  classname$ = saved_classname$

  If generateProxyProperties Then
  If proxyClass Then
    DoProxyAttributes()
    DoProxyMethods()
  End If
  End If

  Print " "
  Print "'******************************"
  Print "'Methods of the base class " + classname$ + " ..."
  Print " "
  ' operations...
  'log to the screen
  a$ = "Processing Class: " + classname$ + " - Methods"
  BasGenLog (a$)

  MethodNames$ = ""
  ' Get list of methods...
  opList& = BasGenGetClassLong(classId&, "Methods")
  BasGenListApply(opList&,"DoOperations")

  If generateInheritence Then
  'determine parent classes...
  'Fake inheritance with attributes of class type (VB does not support inheritence).
  
          'Output parent classes
        superList& = BasGenGetClassLong(classId&, "SuperClasses")
        BasGenListApply(superList&,"SuperClassOperations")
  Print " "
  End If

  Print "'Only use the base class constructor ..."
  Print " "
  ' constructor...
  a$ = "Processing Class: " + classname$ + " - Constructor"
  construct$ = BasGenGetProp(classId&, "VB Constructor Code")
  If Len(construct$) > 0 Then
    Print "Private Sub Class_Initialize()"
    Print construct$
    Print "End Sub"
  End If

  Print " "
  If generateCreateMethod Then
      DoCreateMethod(classId&)
  End If

  Print " "


  Print "'Only use the base class destructor ..."
  Print " "
  ' destructor...
  a$ = "Processing Class: " + classname$ + " - Destructor"
  destruct$ = BasGenGetProp(classId&, "VB Destructor Code")
  If Len(destruct$) > 0 Then
    Print "Private Sub Class_Terminate()"
    Print destruct$
    Print "End Sub"
  End If



  Print " "

  

  g_rv% = 1 ' mark successfully return
End Sub



Sub old()
  'print attributes
  Print "{"
        
  'demonstrate use of Start/next/end list functions.
  'BasGenListApply would be simpler...
        
        'get attribute listid
        attrList& = BasGenGetClassLong(classId&, "attributes")
        If (0 <> attrList&) Then

                attrCursor& = BasGenListStart(attrList&)

                lastAccess$ = ""
                ' get the first one in the list
                attr& = BasGenListNext(attrCursor&)
                While (attr& <> 0)
                        'get the attribute information
                        access$ = BasGenGetAttrString(attr&, "access")        'pub/priv/prot
            type$       = BasGenGetAttrString(attr&,"type")
            Scope$ = BasGenGetAttrString(attr&, "scope")
                        name$ = BasGenGetAttrString(attr&, "Name")

                        'check private, etc
                        If (lastAccess$ = access$) Then
                                'print " same  ",Access$,":"
                        Else
                                Print "   ", access$, ":"
                                lastAccess$ = access$
                        End If
                        
                        print " ",scope$,"      ",type$,"       ",name$,";"
                        
                        attr& = BasGenListNext(attrCursor&)
                Wend
                BasGenListEnd (attrCursor&) 'finish using the cursor.
        End If 'valid attribute list

        'now get the methods and print them.
        methList& = BasGenGetClassLong(classId&, "Methods")
        If (0 <> methList&) Then

                methCursor& = BasGenListStart(methList&)

                ' get the first one in the list
                meth& = BasGenListNext(methCursor&)
                While (meth& <> 0)
                        'get the attribute name
                        name$ = BasGenGetMethString(meth&, "Name")
                        Parameters$ = BasGenGetMethString(meth&, "FormalParameters")
                        access$ = BasGenGetMethString(meth&, "access")
                        Initialization$ = BasGenGetMethString(meth&, "Initialization")
                        InlineCode$ = BasGenGetProp(meth&, "Inline C++ Code")
                        type$               = BasGenGetMethString(meth&,"type")
                        Scope$ = BasGenGetMethString(meth&, "Scope")
                        Virtuality$ = BasGenGetMethString(meth&, "Virtuality")
                        iVirtual& = BasGenGetMethLong(meth&, "iVirtual")
                        bInline& = BasGenGetMethLong(meth&, "bInline")
                        bOperator& = BasGenGetMethLong(meth&, "bOperator")
                        bFriend& = BasGenGetMethLong(meth&, "bFriend")
                        
                        'check private, etc
                        If (lastAccess$ = access$) Then
                                'print " same  ",Access$,":"
                        Else
                                Print "   ", access$, ":"
                                lastAccess$ = access$
                        End If

                        Line$ = "       "       'initialize output line
                        If (bFriend& <> 0) Then
                                Line$ = Line$ + "friend "
                        End If
                        If (bInline& <> 0) Then
                                Line$ = Line$ + "inline "
                        End If
                        Line$ = Line$ + Virtuality$ + " "
                        line$ = line$ + type$ + "       "
            If (bOperator& <> 0) Then
                                Line$ = Line$ + "operator "
                        End If
                        Line$ = Line$ + name$ + Parameters$
            If (iVirtual& = 3) Then
                                Line$ = Line$ + "=0;"
                        Else
                                If (InlineCode$ <> "") Then
                                        Line$ = Line$ + InlineCode$ + ";"
                                Else
                                        Line$ = Line$ + ";"
                                End If
                        End If
                        
                        Print Line$

                        'get the next one
                        meth& = BasGenListNext(methCursor&)
                Wend
                BasGenListEnd (methCursor&) 'finish using the cursor.
        End If 'valid attribute list

        Print "};"
        Print "/* End; Name=", classname$, "; DDID=", ddid&, "; */"


  g_rv% = 1 ' mark successfully return
End Sub


Sub DoBase()
  ' the g_id is set on entry.
  ' make local copy incase we make other calls
  id_base& = g_id&
    
  'get the Superclass name
  name$ = BasGenGetSuperString(id_base&, "Name")
'  virt$ = BasGenGetSuperString(id_base&,"Virtuality")
'  access$ = BasGenGetSuperString(id_base&,"access")

  ' syntax in <inheritence_spec>...
  If (base_set% <> 1) Then
    base_set% = 1
    base$ = ":"
  Else
    base$ = base$ + ","
  End If
        
  'set the base string
  base$ = base$ + name$
End Sub

Sub SuperClassAttributes()
        id_base& = g_id&        'the g_id is set on entry.  make local copy in case we make other calls

        'get the class pointer
        classId& = BasGenGetSuperLong(id_base&, "ClassPtr")

  ddid& = BasGenGetClassLong(classId&, "ddid")
  classname$ = BasGenGetClassString(classId&, "Name")

  'log to the screen
  a$ = "Processing SuperClass attributes: " + classname$
  BasGenLog (a$)
     
  Print " "
  Print "'******************************"
  Print "'Attributes of the SUPER CLASS: " + classname$ + " ..."
  Print " "
  Print "'Allow for delegation and type checking by adding link to superclass"
  Print "Private ISa" + classname$ + " As New " + classname$
  Print "'NOTE: This does only attributes and operations, other declarations, such as"
  Print "'VB types, VB constants, constructors, destructors, etc. are not copied for inheritance"
  Print "'Simulate inheritance by copying superclass attributes into subclass..."
  Print "'Note: if an attribute appears in a lower class, then the superclass attribute will be left out"
  Print " "
  'Copy the parent attributes into this class
  ' Get list of attributes...
  doingSuperClass = 1
  attrList& = BasGenGetClassLong(classId&, "Attributes")
  BasGenListApply(attrList&,"DoAttributes")
  doingSuperClass = 0
  Print " "

End Sub


Sub SuperClassOperations()
        id_base& = g_id&        'the g_id is set on entry.  make local copy in case we make other calls

        'get the class pointer
        classId& = BasGenGetSuperLong(id_base&, "ClassPtr")

  ddid& = BasGenGetClassLong(classId&, "ddid")
  classname$ = BasGenGetClassString(classId&, "Name")

  'log to the screen
  a$ = "Processing SuperClass methods: " + classname$
  BasGenLog (a$)
  
  Print " "
  Print "'******************************"
  Print "'Attributes Methods of the SUPER CLASS: " + classname$ + " ..."
  Print " "
  Print "'Note: if an attribute appears in a lower class, then the superclass attribute will be left out"
  Print " "
  attrList& = BasGenGetClassLong(classId&, "Attributes")
  BasGenListApply(attrList&,"DoAttributeMethods")
  Print " "
  Print "'******************************"
  Print "'Methods of the SUPER CLASS: " + classname$ + " ..."
  Print " "
  Print "'NOTE: This does only attributes and operations, other declarations, such as"
  Print "'VB types, VB constants, constructors, destructors, etc. are not copied for inheritance"
  Print "'Simulate inheritance by copying superclass attributes into subclass..."
  Print "'Note: if an attribute appears in a lower class, then the superclass attribute will be left out"
  Print " "
  'Copy the parent attributes into this class
  ' Get list of methods...
  doingSuperClass = 1
  opList& = BasGenGetClassLong(classId&, "Methods")
  BasGenListApply(opList&,"DoOperations")
  Print " "
  doingSuperClass = 0

End Sub

Sub DoCreateMethod(classId&)
  attrParam$ = ""
  attrList& = BasGenGetClassLong(classId&, "Attributes")
  If (0 <> attrList&) Then
     attrCursor& = BasGenListStart(attrList&)
     ' get the first one in the list
      attr& = BasGenListNext(attrCursor&)
       While (attr& <> 0)
             'get the attribute information
             name$ = BasGenGetAttrString(attr&, "Name")
             attrParam$ = attrParam$ + "new_" + AttrWithPrefix$(name$)
             attr& = BasGenListNext(attrCursor&)
             If (attr& <> 0) Then
                attrParam$ = attrParam$ + ",  "
             End If
      Wend
  End If 
  attrList& = BasGenGetClassLong(classId&, "Attributes")
  If (0 <> attrList&
        and attrCursor& = BasGenListStart(attrList&)
        ' get the first one in the list
        and attr& = BasGenListNext(attrCursor&)) Then
    Print " "
    Print "'Automatically generated creation method"
   If classname$ =  mainModule$ Then
       Print "Public Sub Class_Create(" + attrParam$ + " As Variant)"
   Else
      Print "Friend Sub Class_Create(" + attrParam$ + " As Variant)"
   End If
       While (attr& <> 0)
             'get the attribute information
             name$ = BasGenGetAttrString(attr&, "Name")
	 type$ = BasGenGetAttrString(attr&,"type")
'	 MsgBox "Original Object Type " + type$, "GSU Generator", BAS_MSG_ATTENTION
	 If len(type$)>0 then
	       type$ = MapType$(type$)
	 End If
	 If type$ = "void" then
	     type$ = "Variant"
	 End If
	 isObject = 0
	 ObjectUsage$ = BasGenGetProp(attr&, "VB Object Usage")
	 if lcase$(type$) = "object" or lcase$(type$)= " as collection" or
	    ' Types found in VBType, but require the Set command...
	    lcase$(type$) = "database" or lcase$(type$) = "database" or lcase$(type$) = "recordset" or lcase$(type$) = "variant"
	    or VBType(type$) = 0
	 Then
	   isObject = 1
	   Print "   Set " + AttrWithPrefix$(name$) + " = new_" + AttrWithPrefix$(name$)
	 Else
	   Print "   " + AttrWithPrefix$(name$) + " = new_" + AttrWithPrefix$(name$)
	 End If
             attr& = BasGenListNext(attrCursor&)
      Wend
      Print "End Sub"
  End If 
End Sub

Sub DoAttributes()
  ' the g_id is set on entry.
  ' make local copy incase we make other calls
  id_attr& = g_id&

  allowattribute = 1

  ' allow all attributes...
  
  If allowattribute = 1 Then
    name$ = BasGenGetAttrString(id_attr&, "Name")
    
  If name$ = proxyForAttr$ Then
    proxyClass = 1
  End If

  If InStr(0, attributeNames$, name$ + " ") Then
    a$ = "Skipping property name: " + name$ + " because it is found in a subclass." + Chr$(13) + Chr$(10)
    BasGenLog (a$)
    GoTo SkipName
  End If

    ' determine visibility...
    a$ = "Processing Class: " + classname$ + " - Attributes: " + name$
         + chr$(13) + chr$(10) +
         "Determining Visibility"
    BasGenLog (a$)
    access$ = BasGenGetProp(id_attr&, "VB Variable Access")
    If Len(access$) < 1 Then
      access$ = BasGenGetAttrString(id_attr&, "access")
    End If
    access$ = access$ + " "

    ' determine array specification...
    a$ = "Processing Class: " + classname$ + " - Attributes: " + name$
         + chr$(13) + chr$(10) +
         "Determining Array Specification"
    BasGenLog (a$)
    arrayspec$ = BasGenGetProp(id_attr&, "VB Array Specification")
    If Len(arrayspec$) > 0 Then
      arrayspec$ = "(" + arrayspec$ + ")"
    Else
      arrayspec$ = BasGenGetProp(id_attr&, "C Storage Occurrences")
      If Len(arrayspec$) > 0 Then
        arrayspec$ = "(" + arrayspec$ + ")"
      End If
    End If

    ' determine type specification...
    a$ = "Processing Class: " + classname$ + " - Attributes: " + name$
         + chr$(13) + chr$(10) +
         "Determining Attribute Type"
    BasGenLog (a$)
         
         
    ' new code to handle associations (wnr)
    ' if association member then output as collection
    collOf$ = BasGenGetAttrString(id_attr&, "CollOf")
    assoc& = BasGenGetAttrLong(id_attr&, "pAssoc")

    If (assoc& <> 0) Then
                assocLine& = BasGenGetAssnLong(assoc&, "pLine")   'this is the handle to the association line
                assocLineName$ = BasGenGetProp(assocLine&, "name")
                If (collOf$ <> "" And assoc& <> 0) Then
                otherclassname$ = BasGenGetAssnString(assoc&, "OtherClassName")
                'isaggregation$ = BasGenGetAssnString(assoc&, "bIsAggregation")
                  fromCollClass$ = BasGenGetProp(assocLine&, "From Collection Class")
                'assType& = BasGenGetAssnLong(assoc&, "assType")
                datatype$ = BasGenGetAssnString(assoc&, "Datatype")
                If (datatype$ = "") Then
                                datatype$ = otherclassname$
                End If
                Print "' Attribute derived from association, so create collection"
                        If (otherclassname$ = "") Then
                        otherclassname$ = BasGenGetProp(id_attr&, "VB Variable Type")
                        End If
                        If otherclassname$ = "" Then
                                otherclassname$ = BasGenGetProp(id_attr&, "type")
                        End If
                type$ = "New " + datatype$ +  " ' of type: " + otherclassname$
                End If
    Else
        'The above code replaces the following statement
        type$ = BasGenGetProp(id_attr&,"VB Variable Type")
    End If
         

    if len(type$)>0 then
    Else
      type$ = BasGenGetAttrString(id_attr&,"type")
      if len(type$)>0 then
        type$ = MapType$(type$)
      End If
    End If

    if type$ = "void" then
      type$ = "Variant"
    End If

    StringLength$ = ""
    ObjectUsage$ = ""
    if lcase$(type$) = "string" then
      ' Determine string length
      a$ = "Processing Class: " + classname$ + " - Attributes: " + name$
           + chr$(13) + chr$(10) +
           "Determining String Length"
    BasGenLog (a$)
      StringLength$ = BasGenGetProp(id_attr&, "VB String Length")
        If (Len(StringLength$) > 0) And (StringLength$ <> "0") Then
                StringLength$ = " * " + StringLength$ + " "
        Else
                StringLength$ = ""
        End If
      type$         = "String" + StringLength$
    elseif lcase$(type$) = "object" or lcase$(type$)=" as collection"
        or VBType(type$) = 0 then
      a$ = "Processing Class: " + classname$ + " - Attributes: " + name$
           + chr$(13) + chr$(10) +
           "Determining Object Usage"
      ObjectUsage$ = BasGenGetProp(id_attr&, "VB Object Usage")
      If LCase$(ObjectUsage$) = "create new object" Then
        ObjectUsage$ = "New "
      Else
        ObjectUsage$ = ""
      End If

      type$ = ObjectUsage$ + type$
    End If

    newtype$ = " As " + type$

    If name$ = proxyForAttr$ Then
      origType$ = BasGenGetAttrString(id_attr&,"type")
      If lcase$(origType$) = type$ Then
          proxyClassType$ = origType$
      Else
        proxyClassType$ = type$
      End If
        proxyClassId& = GetClassPtr&(type$)
   End If

    a$ = "Processing Class: " + classname$ + " - Attributes: " + name$
         + chr$(13) + chr$(10) +
         "Formatting output"
    BasGenLog (a$)
    'Print access$ + name$ + arrayspec$ + newtype$
    'Some reason, SA doesn't add prefix to associations
    Print access$ + AttrWithPrefix$(name$) + arrayspec$ + newtype$
  End If

  'attributeNames$ = attributeNames$ + name$ + " "
  attributeNames$ = attributeNames$ + AttrWithPrefix$(name$) + " "
SkipName:

  g_rv% = 1 ' mark successfully return
End Sub

Sub DoAttributeMethods()
  ' the g_id is set on entry.
  ' make local copy incase we make other calls
  id_attr& = g_id&
  
  allowattribute = 1

  ' allow all attributes...

  If allowattribute = 1 Then
    name$ = BasGenGetAttrString(id_attr&, "Name")

  If InStr(0, attributeMethodNames$, AttrWithPrefix$(name$) + " ") Then
    a$ = "Skipping property name: " + name$ + " because it is found in a subclass." + Chr$(13) + Chr$(10)
    BasGenLog (a$)
    GoTo SkipName
  End If

    ' determine visibility...
    a$ = "Processing Class: " + classname$ + " - Attribute Method: " + name$
         + chr$(13) + chr$(10) +
         "Determining Visibility"
    BasGenLog (a$)
    access$ = BasGenGetProp(id_attr&, "VB Variable Access")
    If Len(access$) < 1 Then
      access$ = BasGenGetAttrString(id_attr&, "access")
    End If
    access$ = access$ + " "

    ' determine type specification...
    a$ = "Processing Class: " + classname$ + " - Attribute Method: " + name$
         + chr$(13) + chr$(10) +
         "Determining Attribute Type"
    BasGenLog (a$)
         
         
    ' new code to handle associations (wnr)
    ' if association member then output as collection
    collOf$ = BasGenGetAttrString(id_attr&, "CollOf")
    assoc& = BasGenGetAttrLong(id_attr&, "pAssoc")

    If (assoc& <> 0) Then
                assocLine& = BasGenGetAssnLong(assoc&, "pLine")   'this is the handle to the association line
                assocLineName$ = BasGenGetProp(assocLine&, "name")
                If (collOf$ <> "" And assoc& <> 0) Then
                otherclassname$ = BasGenGetAssnString(assoc&, "OtherClassName")
                'isaggregation$ = BasGenGetAssnString(assoc&, "bIsAggregation")
                  fromCollClass$ = BasGenGetProp(assocLine&, "From Collection Class")
                'assType& = BasGenGetAssnLong(assoc&, "assType")
                datatype$ = BasGenGetAssnString(assoc&, "Datatype")
                If (datatype$ = "") Then
                                datatype$ = otherclassname$
                End If
                Print "' Attribute derived from association, so create collection"
                        If (otherclassname$ = "") Then
                        otherclassname$ = BasGenGetProp(id_attr&, "VB Variable Type")
                        End If
                        If otherclassname$ = "" Then
                                otherclassname$ = BasGenGetProp(id_attr&, "type")
                        End If
                type$ = "New " + datatype$ +  " ' of type: " + otherclassname$
                End If
    Else
        'The above code replaces the following statement
        type$ = BasGenGetProp(id_attr&,"VB Variable Type")
    End If
         
    if len(type$)>0 then
    Else
      type$ = BasGenGetAttrString(id_attr&,"type")
      if len(type$)>0 then
        type$ = MapType$(type$)
      End If
    End If

    if type$ = "void" then
      type$ = "Variant"
    End If

   isObject = 0
    ObjectUsage$ = BasGenGetProp(id_attr&, "VB Object Usage")
    if lcase$(type$) = "object" or lcase$(type$)= " as collection" or
        ' Types found in VBType, but require the Set command...
        lcase$(type$) = "database" or lcase$(type$) = "database" or lcase$(type$) = "recordset" or lcase$(type$) = "variant"
        or VBType(type$) = 0
    then
        isObject = 1
        a$ = "Processing Class: " + classname$ + " - Attribute Method: " + name$
               + chr$(13) + chr$(10) +
                "Determining Object Usage"
        newtype$ = " As " + type$
        type$ = newtype$
    End If

    a$ = "Processing Class: " + classname$ + " - Attribute Method: " + name$
         + chr$(13) + chr$(10) +
         "Formatting output"
    BasGenLog (a$)
    
    'Get method
    If generateGetMethod Then
        Print "'Automatically generated method for attribute."
        If classname$ =  mainModule$ Then
            Print "Public " +  "Property Get " + AttrWithoutPrefix$(name$) + "()"
        Else
            Print getAccess$ + " Property Get " + AttrWithoutPrefix$(name$) + "()"
       End If
        If proxyClass Then
            Print "'This is a proxy class..."
        End If
        If isObject Then
	Print "    Set " + AttrWithoutPrefix$(name$) + " = " + AttrWithPrefix$(name$)
        Else
	Print "    " + AttrWithoutPrefix$(name$) + " = " + AttrWithPrefix$(name$)
        End If
        Print "End Property"
    End If
    
    'Let method
    If generateLetMethod Then
        Print "'Automatically generated method for attribute."
        paramName$ = "new_" + name$
        If classname$ =  mainModule$ Then
            Print "Public " +  "Property Let "  + AttrWithoutPrefix$(name$) + "(" + paramName$ + ")"
        Else
            Print letAccess$ + " Property Let " + AttrWithoutPrefix$(name$) + "(" + paramName$ + ")"
       End If
        If proxyClass Then
            Print "'This is a proxy class..."
        End If
        If isObject Then
           Print "    Set " + AttrWithPrefix$(name$) + " = " + paramName$
        Else
           Print "    " + AttrWithPrefix$(name$) + " = " + paramName$
        End If
        Print "End Property"
    End If

    'Set method
    If generateSetMethod and isObject Then
        Print "'Automatically generated method for attribute."
        paramName$ = "new_" + name$
        If classname$ =  mainModule$ Then
            Print "Public " +  " Property Set " + AttrWithoutPrefix$(name$) + "(" + paramName$ + ")"
        Else
            Print setAccess$ + " Property Set " + AttrWithoutPrefix$(name$) + "(" + paramName$ + ")"
       End If
        If proxyClass Then
            Print "'This is a proxy class..."
        End If
        Print "    Set " + AttrWithPrefix$(name$) + " = " + paramName$
        Print "End Property"
    End If


  End If


  attributeMethodNames$ = attributeMethodNames$ + AttrWithPrefix$(name$) + " "
SkipName:

  g_rv% = 1 ' mark successfully return
End Sub

Sub DoProxyAttributes()
  ' the g_id is set on entry.
  ' make local copy incase we make other calls
  id_attr& = g_id&

   name$ = BasGenGetAttrString(id_attr&, "Name")

  'log to the screen
  a$ = "Processing Proxy attributes: " + classname$
  BasGenLog (a$)
     
  Print " "
  Print "'******************************"
  Print "'Generated Attribute Methods for " + classname$ + " of PROXY class " + proxyClassType$
  Print " "
  'Copy proxy attributes into this class
  ' Get list of attributes...
  If proxyClassId& Then
      attrList& = BasGenGetClassLong(proxyClassId&, "Attributes")
      BasGenListApply(attrList&,"DoAProxyAttributeMethod")
      Print " "
  End If
End Sub

Sub DoProxyMethods()
  ' the g_id is set on entry.
  ' make local copy incase we make other calls
  id_op& = g_id&

  ' name of operation
  opname$ = BasGenGetMethString(id_op&, "Name")

  'log to the screen
  a$ = "Processing Proxy methods: " + classname$
  BasGenLog (a$)
     
  Print " "
  Print "'******************************"
  Print "'Generated Methods for " + classname$ + " of PROXY class " + proxyClassType$
  Print " "
  'Copy proxy attributes into this class
  ' Get list of attributes...
  If proxyClassId& Then
      opList& = BasGenGetClassLong(proxyClassId&, "Methods")
      BasGenListApply(opList&,"DoAProxyOperation")
      Print " "
  End If
End Sub

Sub DoAProxyAttributeMethod()
  ' the g_id is set on entry.
  ' make local copy incase we make other calls
  id_attr& = g_id&
  
    name$ = BasGenGetAttrString(id_attr&, "Name")

  If InStr(0, attributeMethodNames$, AttrWithPrefix$(name$) + " ") or
       lcase$(proxyAttr$) = lcase$(name$) Then
    a$ = "Skipping property name: " + name$ + " because it is found in a subclass." + Chr$(13) + Chr$(10)
    BasGenLog (a$)
    GoTo SkipName
  End If

    ' determine visibility...
    a$ = "Processing Class: " + classname$ + " - Attribute Method: " + name$
         + chr$(13) + chr$(10) +
         "Determining Visibility"
    BasGenLog (a$)
    access$ = BasGenGetProp(id_attr&, "VB Variable Access")
    If Len(access$) < 1 Then
      access$ = BasGenGetAttrString(id_attr&, "access")
    End If
    access$ = access$ + " "

    ' determine type specification...
    a$ = "Processing Class: " + classname$ + " - Attribute Method: " + name$
         + chr$(13) + chr$(10) +
         "Determining Attribute Type"
    BasGenLog (a$)
         
         
    ' new code to handle associations (wnr)
    ' if association member then output as collection
    collOf$ = BasGenGetAttrString(id_attr&, "CollOf")
    assoc& = BasGenGetAttrLong(id_attr&, "pAssoc")

    If (assoc& <> 0) Then
                assocLine& = BasGenGetAssnLong(assoc&, "pLine")   'this is the handle to the association line
                assocLineName$ = BasGenGetProp(assocLine&, "name")
                If (collOf$ <> "" And assoc& <> 0) Then
                otherclassname$ = BasGenGetAssnString(assoc&, "OtherClassName")
                'isaggregation$ = BasGenGetAssnString(assoc&, "bIsAggregation")
                  fromCollClass$ = BasGenGetProp(assocLine&, "From Collection Class")
                'assType& = BasGenGetAssnLong(assoc&, "assType")
                datatype$ = BasGenGetAssnString(assoc&, "Datatype")
                If (datatype$ = "") Then
                                datatype$ = otherclassname$
                End If
                Print "' Attribute derived from association, so create collection"
                        If (otherclassname$ = "") Then
                        otherclassname$ = BasGenGetProp(id_attr&, "VB Variable Type")
                        End If
                        If otherclassname$ = "" Then
                                otherclassname$ = BasGenGetProp(id_attr&, "type")
                        End If
                type$ = "New " + datatype$ +  " ' of type: " + otherclassname$
                End If
    Else
        'The above code replaces the following statement
        type$ = BasGenGetProp(id_attr&,"VB Variable Type")
    End If
         
    if len(type$)>0 then
    Else
      type$ = BasGenGetAttrString(id_attr&,"type")
      if len(type$)>0 then
        type$ = MapType$(type$)
      End If
    End If

    if type$ = "void" then
      type$ = "Variant"
    End If

   isObject = 0
    ObjectUsage$ = BasGenGetProp(id_attr&, "VB Object Usage")
    if lcase$(type$) = "object" or lcase$(type$)= " as collection" or
        ' Types found in VBType, but require the Set command...
        lcase$(type$) = "database" or lcase$(type$) = "database" or lcase$(type$) = "recordset" or lcase$(type$) = "variant"
        or VBType(type$) = 0
    then
        isObject = 1
        a$ = "Processing Class: " + classname$ + " - Attribute Method: " + name$
               + chr$(13) + chr$(10) +
                "Determining Object Usage"
        newtype$ = " As " + type$
        type$ = newtype$
    End If

    a$ = "Processing Class: " + classname$ + " - Attribute Method: " + name$
         + chr$(13) + chr$(10) +
         "Formatting output"
    BasGenLog (a$)
    
    'Get method
    If generateGetMethod Then
        Print "'Automatically generated method for " + classname$ + " of PROXY class " + proxyClassType$
        Print getAccess$ + " Property Get " + AttrWithoutPrefix$(name$) + "()"
        If proxyClass Then
            Print "'This is a proxy class..."
	Print "'Because Set/Let Properties are declared Friend,"
	Print "'we must explicitly define variable. That is, we can't late bind using Variant."
	Print "   Dim domainObj As " + proxyClassType$
	Print "   Set domainObj = getProxyFor()"
        End If
        If isObject Then
	Print "   Set " + AttrWithoutPrefix$(name$) + " = "  + "domainObj." + AttrWithoutPrefix$(name$)
        Else
	Print "   " + AttrWithoutPrefix$(name$) + " = " +  "domainObj." + AttrWithoutPrefix$(name$)
        End If
        Print "End Property"
    End If
    
    'Let method
    If generateLetMethod Then
        Print "'Automatically generated method for " + classname$ + " of PROXY class " + proxyClassType$
        paramName$ = "new_" + name$
        Print letAccess$ + " Property Let " + AttrWithoutPrefix$(name$) + "(" + paramName$ + ")"
        If proxyClass Then
            Print "'This is a proxy class..."
	Print "'Because Set/Let Properties are declared Friend,"
	Print "'we must explicitly define variable. That is, we can't late bind using Variant."
	Print "   Dim domainObj As " + proxyClassType$
	Print "   Set domainObj = getProxyFor()"
        End If
        If isObject Then
           Print "   Set domainObj." + AttrWithoutPrefix$(name$) + " = " + paramName$
        Else
           Print "   domainObj." + AttrWithoutPrefix$(name$) + " = " + paramName$
'           Print "  getProxyFor()." + AttrWithoutPrefix$(name$) + " = " + paramName$
        End If
        Print "End Property"
    End If

    'Set method
    If generateSetMethod Then
        Print "'Automatically generated method for " + classname$ + " of PROXY class " + proxyClassType$
        paramName$ = "new_" + name$
        Print letAccess$ + " Property Set " + AttrWithoutPrefix$(name$) + "(" + paramName$ + ")"
        If proxyClass Then
            Print "'This is a proxy class..."
	Print "'Because Set/Let Properties are declared Friend,"
	Print "'we must explicitly define variable. That is, we can't late bind using Variant."
	Print "   Dim domainObj As " + proxyClassType$
	Print "   Set domainObj = getProxyFor()"
        End If
        If isObject Then
           Print "   Set domainObj." + AttrWithoutPrefix$(name$) + " = " + paramName$
        Else
           Print "   domainObj." + AttrWithoutPrefix$(name$) + " = " + paramName$
'           Print "  getProxyFor()." + AttrWithoutPrefix$(name$) + " = " + paramName$
        End If
        Print "End Property"
    End If

  attributeMethodNames$ = attributeMethodNames$ + AttrWithPrefix$(name$) + " "
SkipName:

  g_rv% = 1 ' mark successfully return
End Sub

Sub DoOperations()
  ' the g_id is set on entry.
  ' make local copy incase we make other calls
  id_op& = g_id&

  ' name of operation
  opname$ = BasGenGetMethString(id_op&, "Name")

    a$ = "Operation name: " + opname$ + Chr$(13) + Chr$(10)
    BasGenLog (a$)

  If InStr(0, attributeMethodNames$, opname$ + " ") Then
    a$ = "Skipping property name: " + opname$ + " because it is found in a subclass." + Chr$(13) + Chr$(10)
    BasGenLog (a$)
    GoTo SkipName
  End If

  allowoperation = 1

  ' disallow constructors...
  If opname$ = classname$ Then
    allowoperation = 0
  End If

  ' disallow destructors...
  If opname$ = "~" + classname$ Then
    allowoperation = 0
  End If


  If allowoperation = 1 Then
    ' Determine visibility...
    a$ = "Processing Class: " + classname$ + " - Methods"
         + chr$(13) + chr$(10) +
         "Determining Visibility"
    BasGenLog (a$)
    access$ = BasGenGetProp(id_op&, "VB Access")
    If Len(access$) < 1 Then
      access$ = BasGenGetMethString(id_op&, "access")
    End If
    If Len(access$) > 0 Then
      access$ = access$ + " "
    End If

    ' Determine persistence...
    a$ = "Processing Class: " + classname$ + " - Methods"
         + chr$(13) + chr$(10) +
         "Determining Persistence"
    BasGenLog (a$)
    Persist$ = BasGenGetProp(id_op&, "VB Persistence")
    If Len(Persist$) > 0 Then
      If LCase$(Persist$) = "non-static" Then
        Persist$ = ""
      Else
        Persist$ = Persist$ + " "
      End If
    End If

    ' Determine method type...
    a$ = "Processing Class: " + classname$ + " - Methods"
         + chr$(13) + chr$(10) +
         "Determining Method Type"
    BasGenLog (a$)
    MethType$ = BasGenGetProp(id_op&, "VB Method Type")
    If Len(MethType$) > 0 Then
      MethType$ = MethType$ + " "
    Else
      MethType$ = "Sub "
    End If


    ' Determine Property Procedure type...
    If LCase$(MethType$) = "property " Then
      a$ = "Processing Class: " + classname$ + " - Methods"
           + chr$(13) + chr$(10) +
           "Determining Property Procedure Type"
      BasGenLog (a$)

      Property$ = BasGenGetProp(id_op&, "VB Property Method Type")

      If Len(Property$) < 1 Then
        Property$ = "Let "
      Else
        Property$ = Property$ + " "
      End If
    Else
      Property$ = ""
    End If

    ' Determine arguments...
    a$ = "Processing Class: " + classname$ + " - Methods"
         + chr$(13) + chr$(10) +
         "Determining Arguments"
    BasGenLog (a$)
    Args$ = BasGenGetProp(id_op&, "VB Arguments")
    If Len(Args$) < 1 Then
      Args$ = BasGenGetMethString(id_op&, "FormalParameters")
      If Len(Args$) > 0 Then
        Args$ = MapParams$(Args$)
        Args$ = FilterParams$(Args$)
      End If
    End If
    ' get rid of trailing spaces...
    Args$ = trim$(Args$)


    ' Determine return type...
    a$ = "Processing Class: " + classname$ + " - Methods"
         + chr$(13) + chr$(10) +
         "Determining Return Type"
    BasGenLog (a$)

    returntype$ = BasGenGetProp(id_op&, "VB Return Type")
    If Len(returntype$) > 0 Then
    Else
      returntype$ = BasGenGetMethString(id_op&, "ReturnType")
      returntype$ = trim$(returntype$)

      If Len(returntype$) > 0 Then
        If LCase$(returntype$) = "void" Then
          returntype$ = ""
        Else
          returntype$ = MapType$(returntype$)
        End If
      Else
        returntype$ = ""
      End If
    End If

    returntype$ = trim$(returntype$)

    if lcase$(MethType$) = "function " or
       (lcase$(MethType$) = "property " and lcase$(property$) = "get ") then
      If Len(returntype$) > 0 Then
        returntype$ = " As " + returntype$
      End If
    Else
      If Len(returntype$) > 0 Then
        MethType$ = "Function "
        returntype$ = " As " + returntype$
      End If
    End If


    ' Determine method code...
    a$ = "Processing Class: " + classname$ + " - Methods"
         + chr$(13) + chr$(10) +
         "Determining Method Code"
    BasGenLog (a$)
    Code$ = BasGenGetProp(id_op&, "VB Method Code")



    ' format output...

    'log to the screen
    a$ = "Processing Class: " + classname$ + " - Methods"
         + chr$(13) + chr$(10) +
         "Formatting output"
    BasGenLog (a$)

    Print access$ + Persist$ + MethType$ + Property$ + opname$ + "(" + Args$ + ")" + returntype$
    If Len(Code$) > 0 Then
      Print Code$
    End If
    Print "End " + MethType$
    Print " "
  End If


  attributeMethodNames$ = attributeMethodNames$ + opname$ + " "
SkipName:

  g_rv% = 1 ' mark successfully return
End Sub

Sub DoAProxyOperation()
  ' the g_id is set on entry.
  ' make local copy incase we make other calls
  id_op& = g_id&

  ' name of operation
  opname$ = BasGenGetMethString(id_op&, "Name")

    a$ = "Operation name: " + opname$ + Chr$(13) + Chr$(10)
    BasGenLog (a$)

  If InStr(0, attributeMethodNames$, opname$ + " ") Then
    a$ = "Skipping property name: " + opname$ + " because it is found in a subclass." + Chr$(13) + Chr$(10)
    BasGenLog (a$)
    GoTo SkipName
  End If

  allowoperation = 1

  ' disallow constructors...
  If opname$ = classname$ Then
    allowoperation = 0
  End If

  ' disallow destructors...
  If opname$ = "~" + classname$ or
      lcase$(opname$) = "~" + lcase$(proxyClassType$) Then
    allowoperation = 0
  End If


  If allowoperation = 1 Then

    ' Determine visibility...
    a$ = "Processing Class: " + classname$ + " - Methods"
         + chr$(13) + chr$(10) +
         "Determining Visibility"
    BasGenLog (a$)
    access$ = BasGenGetProp(id_op&, "VB Access")
    If Len(access$) < 1 Then
      access$ = BasGenGetMethString(id_op&, "access")
    End If
    If Len(access$) > 0 Then
      access$ = access$ + " "
    End If

    ' Determine persistence...
    a$ = "Processing Class: " + classname$ + " - Methods"
         + chr$(13) + chr$(10) +
         "Determining Persistence"
    BasGenLog (a$)
    Persist$ = BasGenGetProp(id_op&, "VB Persistence")
    If Len(Persist$) > 0 Then
      If LCase$(Persist$) = "non-static" Then
        Persist$ = ""
      Else
        Persist$ = Persist$ + " "
      End If
    End If

    ' Determine method type...
    a$ = "Processing Class: " + classname$ + " - Methods"
         + chr$(13) + chr$(10) +
         "Determining Method Type"
    BasGenLog (a$)
    MethType$ = BasGenGetProp(id_op&, "VB Method Type")
    If Len(MethType$) > 0 Then
      MethType$ = MethType$ + " "
    Else
      MethType$ = "Sub "
    End If


    ' Determine Property Procedure type...
    If LCase$(MethType$) = "property " Then
      a$ = "Processing Class: " + classname$ + " - Methods"
           + chr$(13) + chr$(10) +
           "Determining Property Procedure Type"
      BasGenLog (a$)

      Property$ = BasGenGetProp(id_op&, "VB Property Method Type")

      If Len(Property$) < 1 Then
        Property$ = "Let "
      Else
        Property$ = Property$ + " "
      End If
    Else
      Property$ = ""
    End If

    ' Determine arguments...
    a$ = "Processing Class: " + classname$ + " - Methods"
         + chr$(13) + chr$(10) +
         "Determining Arguments"
    BasGenLog (a$)
    Args$ = BasGenGetProp(id_op&, "VB Arguments")
     If Len(Args$) < 1 Then
      Args$ = BasGenGetMethString(id_op&, "FormalParameters")
      If Len(Args$) > 0 Then
        Args$ = MapParams$(Args$)
        Args$ = FilterParams$(Args$)
      End If
    End If
    ' get rid of trailing spaces...
    Args$ = trim$(Args$)


    ' Determine return type...
    a$ = "Processing Class: " + classname$ + " - Methods"
         + chr$(13) + chr$(10) +
         "Determining Return Type"
    BasGenLog (a$)

    returntype$ = BasGenGetProp(id_op&, "VB Return Type")
    If Len(returntype$) > 0 Then
    Else
      returntype$ = BasGenGetMethString(id_op&, "ReturnType")
      returntype$ = trim$(returntype$)

      If Len(returntype$) > 0 Then
        If LCase$(returntype$) = "void" Then
          returntype$ = ""
        Else
          returntype$ = MapType$(returntype$)
        End If
      Else
        returntype$ = ""
      End If
    End If

    returntype$ = trim$(returntype$)

   baseReturnType$ = returntype$

    if lcase$(MethType$) = "function " or
       (lcase$(MethType$) = "property " and lcase$(property$) = "get ") then
      If Len(returntype$) > 0 Then
        returntype$ = " As " + returntype$
      End If
    Else
      If Len(returntype$) > 0 Then
        MethType$ = "Function "
        returntype$ = " As " + returntype$
      End If
    End If


    ' Determine method code...
    a$ = "Processing Class: " + classname$ + " - Methods"
         + chr$(13) + chr$(10) +
         "Determining Method Code"
    BasGenLog (a$)
'    Code$ = BasGenGetProp(id_op&, "VB Method Code")
' This only works if people keep the formal parameters up to date (without paramter types)
      FormalArgs$ = BasGenGetMethString(id_op&, "FormalParameters")
      FormalArgs$ = FilterFormalParameters$ (FormalArgs$)
      If FormalArgs$ = "void" Then
	 FormalArgs$ = ""
      End If

   If lcase$(MethType$) = "function " Then
        If lcase$(baseReturnType$) = "object" or lcase$(baseReturnType$)= " as collection" or
	    ' Types found in VBType, but require the Set command...
	    lcase$(baseReturnType$) = "database" or lcase$(baseReturnType$) = "database" or 
	    lcase$(baseReturnType$) = "recordset" or lcase$(baseReturnType$) = "variant"
	    or (VBType(baseReturnType$) = 0 and Not (baseReturnType$ = ""))
       Then
           Code$ = Code$ + "   Set " + opname$ +" = getProxyFor." + opname$ + "(" + FormalArgs$ + ")"
       Else 
           Code$ = "'Return type of '" + baseReturnType$ + "'"  + chr$(13) + chr$(10) 
           Code$ =  Code$ + "'If the return type is blank and there is an error, " + chr$(13) + chr$(10) 
           Code$ = Code$ + "'it can be fixed by setting the return type of this function in the domain class." + chr$(13) + chr$(10) 
           Code$ = Code$ + "   " + opname$ + " = getProxyFor." + opname$ +  "(" + FormalArgs$ + ")"
       End If
   Else
       Code$ = "  getProxyFor." + opname$ + " " + FormalArgs$
  End If


    ' format output...

    'log to the screen
    a$ = "Processing Class: " + classname$ + " - Methods"
         + chr$(13) + chr$(10) +
         "Formatting output"
    BasGenLog (a$)

  Print "'Automatically generated method for " + classname$ + " of PROXY class " + proxyClassType$
    Print access$ + Persist$ + MethType$ + Property$ + opname$ + "(" + Args$ + ")" + returntype$
    If Len(Code$) > 0 Then
      Print Code$
    End If
    Print "End " + MethType$
    Print " "
  End If


  attributeMethodNames$ = attributeMethodNames$ + opname$ + " "
SkipName:

  g_rv% = 1 ' mark successfully return
End Sub



Function MapParams$(param$)
  newparam$ = ""
  newtype$ = ""

  count = 1
  foundtype = 0
  While count < Len(param$)
    oldcount = 0

    If Mid$(param$, count, 1) = "(" Then
      count = count + 1
    ElseIf Mid$(param$, count, 1) = ")" Then
      count = count + 1
    ElseIf Mid$(param$, count, 1) = " " Then
      count = count + 1
    ElseIf Mid$(param$, count, 1) = "," Then
      count = count + 1
    Else
      If foundtype = 0 Then
        ' looking for a type...

        posa = InStr(count, param$, " ")
        posb = InStr(count, param$, ")")

        If posa = 0 Then
          pos = 0
        ElseIf posb = 0 Then
          pos = 0
        ElseIf posa < posb Then
          pos = posa
        Else
          pos = 0
        End If

        If pos <> 0 Then
          ' look for a name next
          foundtype = 1

          ' get type...
          originaltype$ = Mid$(param$, count, pos - count)
          type$ = MapType$(originaltype$)

          ' must retain type information until we find a name...
          newtype$ = type$
        Else
          ' end of string

          ' get type...
          originaltype$ = Mid$(param$, count, Len(param$) - count)
          type$ = MapType$(originaltype$)

          ' must retain type information until we find a name...
          newtype$ = type$
        End If
 
        count = count + Len(originaltype$)
      Else
        ' looking for a name...

        posa = InStr(count, param$, ",")
        posb = InStr(count, param$, ")")

        If posa = 0 Then
          pos = 0
        ElseIf posb = 0 Then
          pos = 0
        ElseIf posa < posb Then
          pos = posa
        Else
          pos = 0
        End If

        If pos <> 0 Then
          ' look for a type next
          foundtype = 0

          ' get name...
          name$ = Mid$(param$, count, pos - count)

          ' put together with the retained type...
          If newtype$ = "" Then
            newtype$ = "Variant"
          End If
          newtype$ = " As " + newtype$

          newparam$ = newparam$ + FilterName$(name$) + newtype$ + ", "

          ' clear the new type once more
          newtype$ = ""
        Else
          ' end of string

          ' get name...
          name$ = Mid$(param$, count, Len(param$) - (count - 1))

          ' put together with the retained type...
          If newtype$ = "" Then
            newtype$ = "Variant"
          End If
          newtype$ = " As " + newtype$

          newparam$ = newparam$ + FilterName$(name$) + newtype$

          ' clear the new type once more
          newtype$ = ""
        End If

        count = count + Len(name$)
      End If
    End If

    ' prevent infinite loop occurrence
    If count <= oldcount Then
      count = count + 1
    End If
  Wend

  MapParams$ = newparam$
End Function


function MapType$( type$ )
  if type$ = "" then
    newtype$ = "Variant"
  elseif type$ = "void" then
    newtype$ = "Variant"
  Else
    ' check for array specifications...

    pos = instr(1,type$,"[")
'    if pos=0 then
'      pos = instr(1,type$,"(")
'    end if
    If pos > 0 Then
      array$ = getArraySpec$(type$)
      type$ = mid$(type$,1, pos-1)
    End If

    ' get rid of invalid characters...
    type$ = FilterType$(type$)


    type$ = LCASE$(type$)

    pointertype = 0
    for count = 1 to len(type$)
      if mid$(type$,count,1) = "*" then
        pointertype = 1
      End If
    Next

    if mid$(type$,1,6) = "char *" or mid$(type$,1,5) = "char*" then
      ' check for pointer / reference / unbound array types...

      ' can't have unbound arrays
      ' no such thing as pointers
      ' use type 'any'...

      newtype$ = "String"
    ElseIf pointertype = 1 Then
      ' check for pointer / reference / unbound array types...

      ' can't have unbound arrays
      ' but we can assume it is an object reference
      ' use type 'any'...

      newtype$ = "Object"
    Else
      ' process the remaining type...

      if mid$(type$,1,4) = "real" then
        newtype$ = "Single"

      elseif mid$(type$,1,5) = "float" then
        ' no mapping
        newtype$ = "Single"

      elseif mid$(type$,1,6) = "double" then
        ' no mapping
        newtype$ = "Double"

      elseif mid$(type$,1,4) = "bool" then
        newtype$ = "Boolean"

      elseif mid$(type$,1,7) = "boolean" then
        newtype$ = "Boolean"

      elseif mid$(type$,1,7) = "integer" then
        newtype$ = "Integer"

      elseif mid$(type$,1,3) = "int" then
        newtype$ = "Integer"

      elseif mid$(type$,1,10) = "signed int" then
        newtype$ = "Integer"

      elseif mid$(type$,1,4) = "uint" then
        newtype$ = "Long"

      elseif mid$(type$,1,12) = "unsigned int" then
        newtype$ = "Long"

      elseif mid$(type$,1,4) = "long" then
        ' no mapping
        newtype$ = "Long"

      elseif mid$(type$,1,11) = "signed long" then
        newtype$ = "Long"

      elseif mid$(type$,1,13) = "unsigned long" then
        ' no mapping
        newtype$ = "Long"

      elseif mid$(type$,1,12) = "signed short" then
        newtype$ = "Integer"

      elseif mid$(type$,1,14) = "unsigned short" then
        newtype$ = "Integer"

      elseif mid$(type$,1,4) = "Integer" then
        ' no mapping
        newtype$ = "Integer"

      elseif mid$(type$,1,11) = "signed char" then
        newtype$ = "Integer"

      elseif mid$(type$,1,13) = "unsigned char" then
        newtype$ = "Integer"

      elseif mid$(type$,1,4) = "byte" then
        newtype$ = "Integer"

      Else
        ' unrecognised type.
        ' assume is correct.

        newtype$ = type$
      End If
    End If
  End If


  ' converted type = mapped type + array specification
  MapType$ = newType$ + array$
End Function


function getArraySpec$(type$)
  ' find the start and end of the array specification...

  arraystart = instr(1,type$,"[")
'  if arraystart = 0 then
'    arraystart = instr(1,type$,"(")
'  end if

  arrayend   = instr(1,type$,"]")
'  if arrayend = 0 then
'    arrayend   = instr(1,type$,")")
'  end if



    ' we have found a valid array specification.

    array$ = type$

    ' process the array specification, creating a new
    ' valid specification...
    arrayspec = 0
    disregard = 1 ' disregard everything until we find a "["
    newarray$ = ""

    For count = 1 to len(array$)
      if mid$(array$,count,1) = "[" then
      'or mid$(array$,count,1) = "(" then
        If arrayspec = 0 Then
          ' if we find an open array specification when we
          ' haven't already opened one, is ok.

          arrayspec = 1
          disregard = 0
        Else
          disregard = 1
        End If
      elseif mid$(array$,count,1) = "]" then
      'or mid$(array$,count,1) = ")" then
        If arrayspec = 1 Then
          ' if we find a close array specification when we
          ' haven't already closed one, is ok.

          arrayspec = 0
          disregard = 0
        Else
          disregard = 1
        End If
      Else
        ' only disregard the open/close specifiers; accept
        ' everything else, SO LONG AS WE HAVE OPENED AN ARRAY.

        If arrayspec = 1 Then
          disregard = 0
        End If
      End If

      If disregard = 1 Then
        ' invalid specification; read a character but discard it
      Else
        ' valid specification; read a character and add to array

'        if mid$(array$,count,1)="[" then
'          newarray$ = newarray$ + "("
'        elseif mid$(array$,count,1)="]" then
'          newarray$ = newarray$ + ")"
'        else
          newarray$ = newarray$ + mid$(array$,count,1)
'        end if
      End If
    Next

   
    If arrayspec = 1 Then
      ' finish array spec if still open
      newarray$ = newarray$ + "]"
    End If


  getArraySpec$ = newarray$
End Function


function FilterParams$(type$)

' get rid of unwanted characters in the type specification.

    newtype$ = ""

    ' remove any invalid array specifiers...
    For count = 1 to len(type$)
      test$ = mid$(type$,count,1)

      If test$ = "[" Then
        newtype$ = newtype$ + "("
      ElseIf test$ = "]" Then
        newtype$ = newtype$ + ")"
      Else
        newtype$ = newtype$ + test$
      End If
    Next

 
    FilterParams$ = newtype$

End Function


function FilterType$(type$)

' get rid of unwanted characters in the type specification.

    newtype$ = ""

    ' remove any invalid array specifiers...
    For count = 1 to len(type$)
      test$ = mid$(type$,count,1)

      If test$ = "[" Then
      ElseIf test$ = "]" Then
      ElseIf test$ = "," Then
      Else
        newtype$ = newtype$ + test$
      End If
    Next

 
    FilterType$ = newtype$

End Function

function FilterFormalParameters$(type$)

' get rid of unwanted characters in the type specification.

    newtype$ = ""

    ' remove any invalid array specifiers...
    For count = 1 to len(type$)
      test$ = mid$(type$,count,1)

      If test$ = "(" Then
      ElseIf test$ = ")" Then
      Else
        newtype$ = newtype$ + test$
      End If
    Next

 
    FilterFormalParameters$ = newtype$

End Function


Function FilterName$(name$)

' get rid of unwanted characters in the type specification.

    newname$ = ""

    ' remove any invalid array specifiers...
    For count = 1 To Len(name$)
      test$ = Mid$(name$, count, 1)

      If test$ = "(" Then
      ElseIf test$ = ")" Then
      ElseIf test$ = "," Then
      Else
        newname$ = newname$ + test$
      End If
    Next

 
    FilterName$ = newname$

End Function


Function instr2(search$, sought$)
    instr2 = 0

    for count = 1 to len(type$)
      if mid$(type$,count,1) = "*" then
        instr2 = count
      End If
    Next

End Function


Function trim$(t$)
  ' get rid of trailing spaces...
  abort = 0
  oldlen = Len(t$)
  While Mid$(t$, Len(t$), 1) = " " And abort = 0
    t$ = Mid$(t$, 1, Len(t$) - 1)

    If Len(t$) >= oldlen Then
      abort = 1
    End If
  Wend

  trim$ = t$
End Function


Function SeparateList$(list$)
  ' replace carriage returns with commas and spaces...

  newlist$ = ""

  For count = 1 To Len(list$)
    temp$ = Mid$(list$, count, 1)

    If temp$ = Chr$(10) Or temp$ = Chr$(13) Then
      If count < Len(list$) - 2 Then
        newlist$ = newlist$ + ", "
        count = count + 1
      End If
    Else
      newlist$ = newlist$ + temp$
    End If
  Next

  SeparateList$ = newlist$
End Function

' Assumes prefix is predefined in attrPrefix$
Function AttrWithoutPrefix$(attrName$)
  If Mid$(attrName$, 1, 2) = attrPrefix$ Then
    AttrWithoutPrefix$ = Mid$(attrName$, 3, Len(attrName$) - 1)
  Else
    AttrWithoutPrefix$ = attrName$
  End If
End Function

' Assumes prefix is predefined in attrPrefix$
Function AttrWithPrefix$(attrName$)
  If Mid$(attrName$, 1, 2) = attrPrefix$ Then
    AttrWithPrefix$ = attrName$
  Else
    AttrWithPrefix$ = attrPrefix$ + attrName$
  End If
End Function

function VBType( type$ )
  ' is the given type a vb type?

  if mid$(lcase$(type$),1,7) = "variant" then
    VBType = 1
  elseif mid$(lcase$(type$),1,8) = "database" then
    VBType = 1
  elseif mid$(lcase$(type$),1,9) = "recordset" then
    VBType = 1
  elseif mid$(lcase$(type$),1,7) = "integer" then
    VBType = 1
  elseif mid$(lcase$(type$),1,4) = "long" then
    VBType = 1
  elseif mid$(lcase$(type$),1,6) = "single" then
    VBType = 1
  elseif mid$(lcase$(type$),1,6) = "double" then
    VBType = 1
  elseif mid$(lcase$(type$),1,8) = "currency" then
    VBType = 1
  elseif mid$(lcase$(type$),1,6) = "string" then
    VBType = 1
  elseif mid$(lcase$(type$),1,7) = "boolean" then
    VBType = 1
  elseif mid$(lcase$(type$),1,4) = "date" then
    VBType = 1
  elseif mid$(lcase$(type$),1,6) = "object" then
    VBType = 1
  Else
    VBType = 0
  End If

End Function
'---
Attribute VB_Name = "QuickSort"

'*******************************************************************************
' QuickSort VB Implementation
' by John Chamberlain (jchamber@lynx.dac.neu.edu)
' from johnc.ne.mediaone.net
' 
' Include this header in all copies
' Do not sell this source code or post it in a place with restricted access
' such as web site requiring registration or payment.
'*******************************************************************************

Public Sub QuickSort(Buffer() As String)
    QuickSortInternal 1, UBound(Buffer), Buffer
End Sub

Private Function QuickSortInternal(ByVal lngLower As Long, ByVal lngUpper As Long, Buffer() As String)

    Dim lngPivot As Long

'sort array Buffer[lngLower..lngUpper]

    Do While (lngLower < lngUpper)

        'quickly sort short lists
        If (lngUpper - lngLower <= 12) Then
            InsertSort lngLower, lngUpper, Buffer
            Exit Function
        End If

        'partition into two segments
        lngPivot = Partition(Buffer, lngLower, lngUpper)

        'sort the smallest partition to minimize stack requirements
        If (lngPivot - lngLower <= lngUpper - lngPivot) Then
            QuickSortInternal lngLower, lngPivot - 1, Buffer
            lngLower = lngPivot + 1
        Else
            QuickSortInternal lngPivot + 1, lngUpper, Buffer
            lngUpper = lngPivot - 1
        End If
    Loop
End Function

Private Function Partition(Buffer() As String, lngLower As Long, lngUpper As Long) As Long

    Dim sSwap As String
    Dim i As Long, j As Long

    'partition array Buffer[lngLower..lngUpper]

    'select valPivot and exchange with 1st element
    idxPivot = lngLower + ((lngUpper - lngLower) / 2)
    valPivot = Buffer(idxPivot)
    Buffer(idxPivot) = Buffer(lngLower)

    'sort lngLower+1..lngUpper based on valPivot
    i = lngLower + 1
    j = lngUpper
    Do
        Do While (i < j And valPivot > Buffer(i)): i = i + 1: Loop
        Do While (j >= i And Buffer(j) > valPivot): j = j - 1: Loop
        If (i >= j) Then Exit Do
        sSwap = Buffer(i)
        Buffer(i) = Buffer(j)
        Buffer(j) = sSwap
        j = j - 1
        i = i + 1
    Loop

    'valPivot belongs in Buffer[j]
    Buffer(lngLower) = Buffer(j)
    Buffer(j) = valPivot

    Partition = j

End Function

'Use InsertSort for short lists. Sort array Buffer(LBound to UBound)
Public Sub InsertSort(lngLBound As Long, lngUBound As Long, Buffer() As String)
    Dim idxHigh As Long, idxLow As Long
    Dim sValue As String
    For idxHigh = (lngLBound + 1) To lngUBound
        sValue = Buffer(idxHigh)
        ' Shift elements down until insertion point found.
        For idxLow = (idxHigh - 1) To lngLBound Step -1
            If Buffer(idxLow) <= sValue Then Exit For
            Buffer(idxLow + 1) = Buffer(idxLow)
        Next
        Buffer(idxLow + 1) = sValue 'do insertion
    Next
End Sub

'---
Attribute VB_Name = "General"
' Module: General
'  General procedures.

Option Explicit

' ------------------
'  DLL Declarations
' ------------------

Type RECT
    Left As Long
    Top As Long
    Right As Long
    Bottom As Long
End Type

Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" ( _
    ByVal hWnd As Long, ByVal nIndex As Long) As Long
Declare Function ReleaseCapture Lib "user32" () As Long
Declare Function SendMessage Lib "user32" Alias "SendMessageA" ( _
    ByVal hWnd As Long, ByVal uMsg As Long, ByVal wParam As Long, _
    ByVal lParam As Long) As Long
Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" ( _
    ByVal hWnd As Long, ByVal nIndex As Long, _
    ByVal dwNewLong As Long) As Long
Declare Function SetWindowPos Lib "user32" (ByVal hWnd As Long, _
    ByVal hWndInsertAfter As Long, ByVal x As Long, ByVal y As Long, _
    ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long) As Long
Declare Function SystemParametersInfo Lib "user32" _
    Alias "SystemParametersInfoA" (ByVal uAction As Long, _
    ByVal uParam As Long, lpvParam As Any, ByVal fuWinIni As Long) _
    As Long

' -------------------
'  Windows Constants
' -------------------

' GetWindowLong constants:
Public Const GWL_EXSTYLE = -20

' Hit test constants:
Public Const HTCAPTION = 2

' SetWindowPos constants:
Public Const HWND_TOPMOST = -1
Public Const HWND_NOTOPMOST = -2

Public Const SWP_NOSIZE = &H1
Public Const SWP_NOMOVE = &H2
Public Const SWP_NOZORDER = &H4
Public Const SWP_NOACTIVATE = &H10
Public Const SWP_FRAMECHANGED = &H20

' SystemParametersInfo constants:
Public Const SPI_GETWORKAREA = 48

' Window messages:
Public Const WM_NCLBUTTONDOWN = &HA1

Public Const EM_CANUNDO = &HC6
Public Const EM_EMPTYUNDOBUFFER = &HCD

Public Const WM_CUT = &H300
Public Const WM_COPY = &H301
Public Const WM_PASTE = &H302
Public Const WM_CLEAR = &H303
Public Const WM_UNDO = &H304

' Window styles:
Public Const WS_EX_CLIENTEDGE = &H200&

' -----------
'  Constants
' -----------

' Hourglass constants:
Public Const hgOn = -1, hgOff = 0, hgSave = 1, hgRestore = 2

' ------------
'  Procedures
' ------------

' Adds a hot key to the caption of a menu item.
Public Sub AddMenuShortcut(Menu As Menu, ByVal Shortcut As String)
    Menu.Caption = Menu.Caption & vbTab & Shortcut
End Sub

' Centers a form on the working area.
Public Sub CenterForm(Form As Form)
Dim RECT As RECT, x As Long, y As Long
    ' Get the working area, excluding the taskbar:
    SystemParametersInfo SPI_GETWORKAREA, 0, RECT, 0
    
    ' Find the coordinates of the upper-left corner:
    With RECT
        x = ((.Left + .Right) * Screen.TwipsPerPixelX - _
            Form.Width) \ 2
        y = ((.Top + .Bottom) * Screen.TwipsPerPixelY - _
            Form.Height) \ 2
    End With
    
    Form.Move IIf(x < 0, 0, x), IIf(y < 0, 0, y)
End Sub

' Returns the high-order byte of an integer.
Public Function HIBYTE(ByVal Value As Integer) As Byte
    HIBYTE = (Value And &H7F00) \ &H100 Or _
        IIf(Value And &H8000, &H80, 0)
End Function

' Returns the high-order word of a long integer.
Public Function HIWORD(ByVal Value As Long) As Long
    HIWORD = (Value And &H7FFF0000) \ &H10000 Or _
        IIf(Value And &H80000000, &H8000&, 0&)
End Function

' Shows or hides the hourglass.
Public Sub Hourglass(ByVal Display As Long)
Static States(0 To 20) As Long, CurState As Long
    Select Case Display
        Case hgOn        ' Show the hourglass
            States(CurState) = States(CurState) + 1
        Case hgOff       ' Hide the hourglass
            States(CurState) = States(CurState) - 1
        Case hgSave      ' Save the hourglass state and hide it
            CurState = CurState + 1
            States(CurState) = 0
        Case hgRestore   ' Restore the hourglass
            CurState = CurState - 1
    End Select

    Screen.MousePointer = _
        IIf(States(CurState) > 0, vbHourglass, vbDefault)
End Sub

' Converts a long integer to an unsigned integer.
Public Function LONGtoUINT(ByVal Value As Long) As Integer
    LONGtoUINT = IIf(Value <= &H7FFF&, Value, Not (&HFFFF& - Value))
End Function

' Returns the low-order byte of an integer.
Public Function LOBYTE(ByVal Value As Integer) As Byte
    LOBYTE = Value And &HFF
End Function

' Returns the low-order word of a long integer.
Public Function LOWORD(ByVal Value As Long) As Long
    LOWORD = Value And &HFFFF&
End Function

' Concatenates two 16-bit values.
Public Function MAKELONG(ByVal Low As Long, ByVal High As Integer) _
    As Long
    
    MAKELONG = High * &H10000 Or Low
End Function

' Redraws a window (e.g. after modifying its window style).
Public Sub RedrawWindow(ByVal hWnd As Long)
    SetWindowPos hWnd, 0, 0, 0, 0, 0, _
        SWP_NOSIZE Or SWP_NOMOVE Or SWP_NOZORDER Or _
        SWP_NOACTIVATE Or SWP_FRAMECHANGED
End Sub

' Selects the text in a text box.
Public Sub SelectText(TextBox As TextBox)
    With TextBox
        .SelStart = 0
        .SelLength = Len(.Text)
    End With
End Sub

' Selects the text of all text boxes on a form.
Public Sub SelectTextBoxes(Form As Form)
Dim Control As Control
    For Each Control In Form.Controls
        If TypeOf Control Is TextBox Then
            With Control
                .SelStart = 0
                .SelLength = Len(.Text)
            End With
        End If
    Next Control
End Sub

' Converts an unsigned integer to a long integer.
Public Function UINTtoLONG(ByVal Value As Integer) As Long
    UINTtoLONG = IIf(Value >= 0, Value, &HFFFF& - Not Value)
End Function

' Removes trailing null characters from a string.
Public Function ZTrim(ByVal Text As String) As String
Dim Pos As Long
    Pos = InStr(Text, vbNullChar)
    
    If Pos Then
        ZTrim = Left(Text, Pos - 1)
    Else
        ZTrim = Text
    End If
End Function
'---
Attribute VB_Name = "basAPI"
Option Explicit

' General API functions.

Private Declare Function ShellAbout Lib "shell32.dll" Alias "ShellAboutA" (ByVal hwnd As Long, ByVal szApp As String, ByVal szOtherStuff As String, ByVal hIcon As Long) As Long


Private Const HWND_TOPMOST = -1
Private Const SWP_NOACTIVATE = &H10
Private Const SWP_SHOWWINDOW = &H40
Private Const SWP_HIDEWINDOW = &H80
Private Const SWP_NOZORDER = &H4
Private Const SWP_NOMOVE = &H2
Private Const SWP_NOREPOSITION = &H200
Private Const SWP_NOSIZE = &H1

Private Declare Function SetWindowPos Lib "user32" (ByVal hwnd As Long, _
    ByVal hWndInsertAfter As Long, ByVal X As Long, ByVal Y As Long, _
    ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long) As Long
    
Private Declare Function FindWindow Lib "user32" _
   Alias "FindWindowA" (ByVal lpClassName As String, ByVal _
   lpWindowName As String) As Long
    
Private Declare Function GetForegroundWindow Lib "user32" () As Long

Private Declare Function GetParent Lib "user32" _
   (ByVal hwnd As Long) As Long
   
Private Declare Function GetWindowTextLength Lib "user32" _
   Alias "GetWindowTextLengthA" (ByVal hwnd As Long) As Long
   
Private Declare Function GetWindowText Lib "user32" Alias _
   "GetWindowTextA" (ByVal hwnd As Long, ByVal lpString As String, _
   ByVal cch As Long) As Long

Private Declare Function GetUserNameA Lib "advapi32.dll" _
   (ByVal lpBuffer As String, nSize As Long) As Long

Private TaskBarhWnd As Long


'Exit's windows with one of the following results.
'   dwReserved = 0
Private Declare Function ExitWindowsEx Lib "user32" (ByVal _
   uFlags As Long, ByVal dwReserved As Long) As Long
   
Public Const EXIT_LOGOFF = 0
Public Const EXIT_SHUTDOWN = 1
Public Const EXIT_REBOOT = 2

Private Declare Function GetComputerNameA Lib "kernel32" _
   (ByVal lpBuffer As String, nSize As Long) As Long

' General API functions. (with no VBasic wrapper)

'Puts the app to sleep for the given number of milliseconds
Public Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)

Public Sub ExitWindows(ByVal uFlags As Long)
   Call ExitWindowsEx(uFlags, 0)
End Sub


Public Function GetUserName() As String
   Dim UserName As String * 255

   Call GetUserNameA(UserName, 255)
   GetUserName = Left$(UserName, InStr(UserName, Chr$(0)) - 1)
End Function
'
' Returns the computer's name
'
Public Function GetComputerName() As String
   Dim UserName As String * 255

   Call GetComputerNameA(UserName, 255)
   GetComputerName = Left$(UserName, InStr(UserName, Chr$(0)) - 1)
End Function

'
' Returns the title of the active window.
'    if GetParent = true then the parent window is
'                   returned.
'
Public Function GetActiveWindowTitle(ByVal ReturnParent As Boolean) As String
   Dim i As Long
   Dim j As Long
   
   i = GetForegroundWindow
   
   
   If ReturnParent Then
      Do While i <> 0
         j = i
         i = GetParent(i)
      Loop
   
      i = j
   End If
   
   GetActiveWindowTitle = GetWindowTitle(i)
End Function

Public Sub HideTaskBar()
    TaskBarhWnd = FindWindow("Shell_traywnd", "")
    If TaskBarhWnd <> 0 Then
       Call SetWindowPos(TaskBarhWnd, 0, 0, 0, 0, 0, SWP_HIDEWINDOW)
    End If
End Sub
Public Sub ShowTaskBar()
    If TaskBarhWnd <> 0 Then
       Call SetWindowPos(TaskBarhWnd, 0, 0, 0, 0, 0, SWP_SHOWWINDOW)
    End If
End Sub
'
' Returns the handle of the active window.
'    if GetParent = true then the parent window is
'                   returned.
'
Public Function GetActiveWindow(ByVal ReturnParent As Boolean) As Long
   Dim i As Long
   Dim j As Long
   
   i = GetForegroundWindow
   
   
   If ReturnParent Then
      Do While i <> 0
         j = i
         i = GetParent(i)
      Loop
   
      i = j
   End If
   
   GetActiveWindow = i
End Function


Public Function GetWindowTitle(ByVal hwnd As Long) As String
   Dim l As Long
   Dim s As String
   
   l = GetWindowTextLength(hwnd)
   s = Space(l + 1)
   
   GetWindowText hwnd, s, l + 1
   
   GetWindowTitle = Left$(s, l)
End Function

'
'  Makes a form the top window if top = True.  When top = False it removes
'  this property.
'
Public Sub TopMostForm(f As Form, Top As Boolean)
   If Top Then
      SetWindowPos f.hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE + SWP_NOSIZE
   Else
      SetWindowPos f.hwnd, 0, 0, 0, 0, 0, SWP_NOMOVE + SWP_NOSIZE
   End If
End Sub

'
'  Sleeps for a given number of seconds.
'
Public Sub Pause(ByVal seconds As Single)
   Call Sleep(Int(seconds * 1000#))
End Sub

'
'  Generates a standard windows About box.
'
Public Sub AboutBox(frm As Form, Optional copyright As Variant)
   If VarType(copyright) = vbString Then
      Call ShellAbout(frm.hwnd, App.ProductName, copyright, frm.icon)
   Else
      Call ShellAbout(frm.hwnd, App.ProductName, "", frm.icon)
   End If
End Sub



'---
Attribute VB_Name = "basTrayIcon"
Option Explicit

' Public declarations required for frmTrayIcon

Public Const WM_LBUTTONDBLCLK = &H203
Public Const WM_LBUTTONDOWN = &H201
Public Const WM_LBUTTONUP = &H202
Public Const WM_RBUTTONDBLCLK = &H206
Public Const WM_RBUTTONDOWN = &H204
Public Const WM_RBUTTONUP = &H205
'---
Attribute VB_Name = "basString"
Option Explicit

Private Declare Function IsCharAlpha Lib "user32" _
   Alias "IsCharAlphaA" (ByVal cChar As Byte) As Long
   
Private Declare Function IsCharAlphaNumeric Lib _
   "user32" Alias "IsCharAlphaNumericA" (ByVal cChar As Byte) As Long


'
' This function returns the Nth token in a string
'    Ex.  GetWord("This is a test.", " ", 2) = "is"
'
Public Function GetToken(s As String, token As String, ByVal Nth As Integer) As String
   Dim i As Integer
   Dim p As Integer
   Dim r As Integer

   If Nth < 1 Then
      GetToken = ""
      Exit Function
   End If

   r = 0

   For i = 1 To Nth
      p = r
      r = InStr(p + 1, s, token)
      If r = 0 Then
         If i = Nth Then
            GetToken = Mid$(s, p + 1, Len(s) - p)
         Else
            GetToken = ""
         End If
         Exit Function
      End If
   Next i

   GetToken = Mid$(s, p + 1, r - p - 1)
End Function
'
'  Returns an array to tokenized values
'  Ex:  GetTokens("This is a test.") = ({ "This", "is", "a", "test." })
'
Public Function GetTokens(sTxt As String, sToken As String) As Variant
    Dim iTokenLen As Integer
    Dim iTokenCnt As Integer
    Dim lOffset As Long
    Dim lPrevOffset As Long
    Dim aTokens() As String

    iTokenLen = Len(sToken)
    lOffset = InStr(sTxt, sToken)
    
    Do While lOffset > 0
        ReDim Preserve aTokens(iTokenCnt)
        If lOffset - lPrevOffset > 1 Then
            aTokens(iTokenCnt) = Mid$(sTxt, lPrevOffset + 1, lOffset - 1 - lPrevOffset)
        Else
            aTokens(iTokenCnt) = ""
        End If
        
        lPrevOffset = lOffset
        lOffset = InStr(lOffset + iTokenLen, sTxt, sToken)
        iTokenCnt = iTokenCnt + 1
    Loop
    
    ReDim Preserve aTokens(iTokenCnt)
    aTokens(iTokenCnt) = Mid$(sTxt, lPrevOffset + 1)
    GetTokens = CVar(aTokens)
End Function
' String functions.
' Converts a double to a string
' Note:  numbers after the decimal place
'        are ignored.
Function Int2String(ByVal l As Double) As String
   Dim tmp As String
   Dim str As String
   Dim i As Integer
   Dim j As Integer
   
   tmp = Format(l, "000000000000")
   str = ""
   
   ' Opps... it's more than 999 trillion
   ' One could easily add bigger number
   ' support.
   If Len(tmp) > 12 Then
      Int2String = ""
      Exit Function
   End If
   
   
   ' zero is a special case.
   ' you may want to change this to "no"
   ' as in "no dollars and 12/100" for writing
   ' checks.
   
   If Val(tmp) = 0 Then
      Int2String = "zero"
      Exit Function
   End If
   
   
   i = Val(Left$(tmp, 3))
   If i <> 0 Then
      GoSub do_hundreds
      str = str + " trillion"
   End If
   
   i = Val(Mid$(tmp, 4, 3))
   If i <> 0 Then
      GoSub do_hundreds
      str = str + " million"
   End If
   
   i = Val(Mid$(tmp, 7, 3))
   If i <> 0 Then
      GoSub do_hundreds
      str = str + " thousand"
   End If
   
      
   i = Val(Right$(tmp, 3))
   If i <> 0 Then
      GoSub do_hundreds
   End If
   
   Int2String = str
   Exit Function
   
   

do_hundreds:
   If i > 99 Then
      j = i
      i = i \ 100
      GoSub do_ones
      str = str + " hundred"
      i = j Mod 100
   End If

   If i <> 0 Then
      GoSub do_tens
   End If
   Return
   
do_tens:
   Select Case i Mod 100
      Case 90 To 99:
         str = str + " ninety"
         GoSub do_ones
      Case 80 To 89:
         str = str + " eighty"
         GoSub do_ones
      Case 70 To 79:
         str = str + " seventy"
         GoSub do_ones
      Case 60 To 69:
         str = str + " sixty"
         GoSub do_ones
      Case 50 To 59:
         str = str + " fifty"
         GoSub do_ones
      Case 40 To 49:
         str = str + " fourty"
         GoSub do_ones
      Case 30 To 39:
         str = str + " thirty"
         GoSub do_ones
      Case 20 To 29:
         str = str + " twenty"
         GoSub do_ones
         
      Case 19: str = str + " nineteen"
      Case 18: str = str + " eighteen"
      Case 17: str = str + " seventeen"
      Case 16: str = str + " sixteen"
      Case 15: str = str + " fifteen"
      Case 14: str = str + " fourteen"
      Case 13: str = str + " thirteen"
      Case 12: str = str + " twelve"
      Case 11: str = str + " eleven"
      Case 10: str = str + " ten"
      
      Case Else
         GoSub do_ones
   End Select
   Return
   
   
do_ones:
   If i < 10 Or i Mod 10 = 0 Then
      str = str + " "
   Else
      str = str + "-"
   End If
   
   Select Case i Mod 10
      Case 9: str = str + "nine"
      Case 8: str = str + "eight"
      Case 7: str = str + "seven"
      Case 6: str = str + "six"
      Case 5: str = str + "five"
      Case 4: str = str + "four"
      Case 3: str = str + "three"
      Case 2: str = str + "two"
      Case 1: str = str + "one"
   End Select
   
   Return
End Function


'
' Returns 0 if the string is alpha.
' otherwise returns the position of the first character
' that failed the test.
'
Public Function IsStringAlpha(s As String) As Long
   Dim i As Long
   
   For i = 1 To Len(s)
      If IsCharAlpha(Asc(Mid$(s, i, 1))) = 0 Then
         IsStringAlpha = i
         Exit Function
      End If
   Next i
   
   IsStringAlpha = 0
End Function

'
' Returns 0 if the string is alphaNumeric
' otherwise returns the position of the first character
' that failed the test.
'
Public Function IsStringAlphaNumeric(s As String) As Long
   Dim i As Long
   
   For i = 1 To Len(s)
      If IsCharAlphaNumeric(Asc(Mid$(s, i, 1))) = 0 Then
         IsStringAlphaNumeric = i
         Exit Function
      End If
   Next i
   
   IsStringAlphaNumeric = 0
End Function
'
' Returns 0 if the string is Numeric
' otherwise returns the position of the first character
' that failed the test.
'
Public Function IsStringNumeric(s As String) As Long
   Dim i As Long
   Dim j As Byte
   
   For i = 1 To Len(s)
      j = Asc(Mid$(s, i, 1))
      If IsCharAlphaNumeric(j) = 1 Then
         If IsCharAlpha(j) = 1 Then
            IsStringNumeric = i
            Exit Function
         End If
      Else
         IsStringNumeric = i
         Exit Function
      End If
   Next i
   
   IsStringNumeric = 0
End Function
'trim a string returned from a system function.
'ie. kill the 0.
Public Function STrim(s As String) As String
   Dim i As Integer
   Dim s2 As String
   
   s2 = Trim(s)
   i = InStr(s2, Chr$(0))
   
   If i > 0 Then
      s2 = Left$(s2, i - 1)
   End If
   
   STrim = s2
End Function


'---
Attribute VB_Name = "basSendMessage"
Option Explicit

' SendMessage API functions.
Private Declare Function SendMessage Lib "user32" _
   Alias "SendMessageA" (ByVal hwnd As Long, _
   ByVal wMsg As Long, ByVal wParam As Long, lParam As Long) As Long

Private Const WM_SETREDRAW = &HB

'
' Turns redraw off or on for any object with an hwnd
' Handy for the resize event.
'
' Note: If .ClipControls is not False then .Refresh will
' not update things completely.
'
' If someone knows how to force a form to do a complete redraw
' when .ClipControls = True please let me know.
' tarheit@alpha.wcoil.com
'
Public Sub SetRedraw(ob As Object, ByVal b As Boolean)
   Call SendMessage(ob.hwnd, WM_SETREDRAW, IIf(b, 1, 0), 0)
End Sub


'---
Attribute VB_Name = "basNet"
Option Explicit

Private Declare Function WNetGetUser Lib "mpr" Alias _
   "WNetGetUserA" (ByVal lpName As String, _
   ByVal lpUserName As String, lpnLength As Long) As Long

'
'  Returns the user name or "" if the
'  user is not logged on.
'
Public Function NetUserName() As String
   Dim i As Long
   Dim UserName As String * 255

   i = WNetGetUser("", UserName, 255)
   
   If i = 0 Then
      NetUserName = Left$(UserName, InStr(UserName, Chr$(0)) - 1)
   Else
      NetUserName = ""
   End If
   
End Function
'---
Attribute VB_Name = "basMouse"
Option Explicit

'  Mouse/cursor functions.

Private lShowCursor As Long
Private Declare Function ShowCursor Lib "user32" (ByVal bShow As Long) As Long

'
'  Hides the mouse cursor.
'
Public Sub HideMouse()
   Dim result As Integer
   
   Do
      lShowCursor = lShowCursor - 1
      result = ShowCursor(False)
   Loop Until result < 0
   
End Sub

'
'  Restores the mouse cursor to it's previous state regardless
'  if HideMouse and ShowMouse were called.
'
Public Sub RestoreMouse()
   If lShowCursor > 0 Then
      Do While lShowCursor <> 0
         ShowCursor (False)
         lShowCursor = lShowCursor - 1
      Loop
   ElseIf lShowCursor < 0 Then
      Do While lShowCursor <> 0
         ShowCursor (True)
         lShowCursor = lShowCursor + 1
      Loop
   End If
End Sub


'
'  Show's the mouse cursor.
'
Public Sub ShowMouse()
   Dim result
   
   Do
      lShowCursor = lShowCursor - 1
      result = ShowCursor(True)
   Loop Until result >= 0

End Sub

'---
Attribute VB_Name = "basMisc"
Option Explicit
' Misc. functions.

'
'  Sets a given bit in num
'
Public Function SetBit(Num As Long, ByVal bit As Long) As Long
   If bit = 31 Then
      Num = &H80000000 Or Num
   Else
      Num = (2 ^ bit) Or Num
   End If
   
   SetBit = Num
End Function

'
'  clears a given bit in num
'
Public Function ClearBit(Num As Long, ByVal bit As Long) As Long
   If bit = 31 Then
      Num = &H7FFFFFFF And Num
   Else
      Num = ((2 ^ bit) Xor &HFFFFFFFF) And Num
   End If
   
   ClearBit = Num
End Function

'
'  Test if bit 0 to bit 31 is set.
'
Public Function IsBitSet(ByVal Num As Long, ByVal bit As Long) As Boolean
   IsBitSet = False
   
   If bit = 31 Then
      If Num And &H80000000 Then
         IsBitSet = True
      End If
   Else
      If Num And (2 ^ bit) Then
         IsBitSet = True
      End If
   End If
End Function

' Centers a form relative to the screen or
' another form
Public Sub CenterForm(f As Form, Optional f2 As Variant)
   If IsMissing(f2) Then
      f.Move (Screen.Width - f.Width) / 2, _
             (Screen.Height - f.Height) / 2
   Else
      ' If f is an MDI child in a MDI parent then
      ' center f within the parent.
      If f.MDIChild And Not f2.MDIChild Then
            f.Move ((f2.Width - f.Width) / 2), _
            ((f2.Height - f.Height) / 2)
      Else
         f.Move ((f2.Width - f.Width) / 2) + f2.Left, _
                ((f2.Height - f.Height) / 2) + f2.Top
      End If
   End If
End Sub







Public Function IsEven(ByVal i As Long) As Boolean
   IsEven = Not -(i And 1)
End Function






'
'  Returns true if the year is a leap year.
'     yr is either a date or an integer
'
Public Function IsLeapYear(yr As Variant) As Boolean
   If VarType(yr) = vbDate Then
      IsLeapYear = (Day(DateSerial(Year(yr), 2, 29)) = 29)
   Else
      IsLeapYear = (Day(DateSerial(yr, 2, 29)) = 29)
   End If
End Function

Public Function IsOdd(ByVal i As Long) As Boolean
   IsOdd = -(i And 1)
End Function

'
'  Scrambles the order of elements in an array.
'
Public Sub ShuffleArray(ByRef vArray As Variant, Optional startIndex As Variant, Optional endIndex As Variant)
    Dim i As Long
    Dim rndIndex As Long
    Dim Temp As Variant
    
    If IsMissing(startIndex) Then
       startIndex = LBound(vArray)
    End If
    
    If IsMissing(endIndex) Then
       endIndex = UBound(vArray)
    End If

    For i = startIndex To endIndex
        rndIndex = Int((endIndex - startIndex + 1) * Rnd() + startIndex)

        Temp = vArray(i)
        vArray(i) = vArray(rndIndex)
        vArray(rndIndex) = Temp
    Next i
End Sub
'---
Attribute VB_Name = "basMath"
Option Explicit

'
'  Converts a number in any base from 2 to 36
'  to a long.
'
'  Note, this doesn't verify if the string
'  is a valid number in the given base.
'
Public Function Base2Long(s As String, ByVal nB As Integer) As Long
   Dim s2 As String
   Dim i As Long
   Dim j As Long
   Dim X As Long
   Dim n As Boolean
   Dim s3 As String
   
   If Len(s) < 1 Then
      Base2Long = 0
      Exit Function
   End If
   
   s2 = UCase(s)
   
   If Left$(s2, 1) = "-" Then
      n = True
      s2 = Right$(s2, Len(s2) - 1)
   Else
      n = False
   End If
   
   j = 1
   X = 0
   
   For i = Len(s2) To 1 Step -1
      s3 = Mid$(s2, i, 1)
      Select Case s3
      Case "0" To "9":
         X = X + j * (Asc(s3) - 48)
      Case "A" To "Z":
         X = X + j * (Asc(s3) - 55)
      End Select
      
      j = j * nB
   Next i
   
   If n Then
      X = -X
   End If
   
   Base2Long = X
End Function

'
'  Converts the number n to any base between 2 and 36
'
Public Function Long2Base(ByVal n As Long, ByVal nB As Integer) As String
  Dim s As String
  Dim nD As Integer
  Dim Negative As Boolean

  Negative = n < 0
  n = Abs(n)
  
  Do
    nD = n Mod nB
    If nD > 9 Then
       nD = nD + 7
    End If
    
    s = Chr$(48 + nD) & s
    n = n \ nB
  Loop Until n = 0
  
  If Negative Then
    s = "-" & s
  End If
  
  Long2Base = s
End Function


'
' Returns true if the number is a prime number.
' false if it is not.
'
' This should work reasonably well for small
' numbers (32-bits or less).  For larger numbers
' the Rabin-Miller test should be used.
'
Public Function IsPrime(ByVal n As Long) As Boolean
    Dim i As Long

    IsPrime = False
    
    If n <> 2 And (n And 1) = 0 Then Exit Function 'test if div 2
    If n <> 3 And n Mod 3 = 0 Then Exit Function 'test if div 3
    For i = 6 To Sqr(n) Step 6
        If n Mod (i - 1) = 0 Then Exit Function
        If n Mod (i + 1) = 0 Then Exit Function
    Next
    
    IsPrime = True
End Function
'---
Attribute VB_Name = "basMapping"
Option Explicit
'
'  Routines using the clsMapping class.
'
'  Saves/loades 1 or more mappings from/to
'  a file:

'  SaveMapping  - Saves a mapping to a file.
'  LoadMapping  - Loads a mapping from a file.
'
'
'  The following expect an open file handle:
'
'  ReadMapping  - Reads a mapping from a file.
'  WriteMapping - Writes a mapping to a file.
'
'
'  Saves or loads a mapping from the registry.
'
'  SaveSettingMapping
'  LoadSettingMapping
'
'  There are some limitations on the types of data
'  that can be saved and loaded.
'    - Variant types vbObject, vbDataObject, and vbError
'      can not be saved.
'

Private Const DEFAULT_FILE_KEY = 1347436877  'In asci this is "MAPP"
Private Const BASE_ERROR = 1000

Private vNull As Variant
Public Sub SaveSettingsMapping(m As clsMapping, appname As Variant, Optional Key As Variant, Optional clearsetting As Variant)
   Dim i As Integer
   Dim AppN As String
   Dim k As String
   
   If IsMissing(appname) Then
      AppN = App.ProductName
   Else
      AppN = CStr(appname)
   End If
   
   If IsMissing(Key) Then
      k = "Settings"
   Else
      k = CStr(Key)
   End If

   If Not IsMissing(clearsetting) Then
      If clearsetting Then
         On Error Resume Next
         DeleteSetting AppN, k
      End If
   End If
   
   For i = 1 To m.Count
      SaveSetting AppN, k, m.Key(i), m.Item(i)
   Next i
End Sub

Public Sub LoadSettingsMapping(m As clsMapping, appname As Variant, Optional Key As Variant)
   Dim AppN As String
   Dim k As String
   Dim v As Variant
   Dim i As Integer
   
   If IsMissing(appname) Then
      AppN = App.ProductName
   Else
      AppN = CStr(appname)
   End If
   
   If IsMissing(Key) Then
      k = "Settings"
   Else
      k = CStr(Key)
   End If
   
   v = GetAllSettings(AppN, k)
   If Not IsEmpty(v) Then
      For i = LBound(v, 1) To UBound(v, 1)
         m.Item(v(i, 0)) = v(i, 1)
      Next i
   End If
End Sub


'
'  If keynum = 0 then use the default keynum
'  If Keynum = -1 then ignore any keynum
'
Public Sub LoadMapping(filename As String, KeyNum As Long, ParamArray m() As Variant)
   Dim iErr As Integer
   Dim sErr As String
   Dim fh As Integer   ' File Handle
   Dim l As Long
   Dim i As Long
   
   On Error GoTo ErrorHandler
   
   fh = FreeFile(0)
   Open filename For Binary Access Read Lock Read Write As fh
   
   Get fh, , i
   
   If KeyNum = 0 Then
      l = CLng(DEFAULT_FILE_KEY)
      If l <> i Then
         Close fh
         
         On Error GoTo 0
         Err.Raise BASE_ERROR + 1, "LoadMapping", "File is corrupt or of an unknown format."
         
         Exit Sub
      End If
   ElseIf KeyNum = -1 Then
      ' do nothing
   Else
      l = CLng(KeyNum)
      If l <> 0 Then
         If l <> i Then
            Close fh
            
            On Error GoTo 0
            Err.Raise BASE_ERROR + 1, "LoadMapping", "File is corrupt or of an unknown format."
            
            Exit Sub
         End If
      End If
   End If
 
   For i = 0 To UBound(m)
      ReadMapping fh, m(i)
   Next i
   
   Close fh
   Exit Sub
   
   ' Do error handleing to make sure the file is
   ' closed, then pass the error to the main
   ' program
ErrorHandler:
   iErr = Err
   sErr = Err.Description
   
   On Error Resume Next
   Close fh
   
   On Error GoTo 0
   Err.Raise iErr, "SaveMapping", sErr
End Sub
Public Sub ReadMapping(FileHandle As Integer, m As Variant)
   Dim l As Long
   Dim k As Variant
   Dim v As Variant
   Dim i As Long
   
   Get FileHandle, , l
      
   For i = 1 To l
      Get FileHandle, , k
      Get FileHandle, , v
      
      If Not IsNull(k) Then
         m.Item(k) = v
      End If
   Next
End Sub


'
'  Uses the default KeyNum if KeyNum = 0
'
Public Sub SaveMapping(filename As String, ByVal KeyNum As Long, ParamArray m() As Variant)
   Dim iErr As Integer
   Dim sErr As String
   Dim fh As Integer   ' File Handle
   Dim l As Long
   Dim e As Boolean
   Dim e2 As Boolean
   Dim i As Long
   
   On Error GoTo ErrorHandler
   
   e2 = False
   fh = FreeFile(0)
   
   On Error Resume Next
   Kill filename
   
   On Error GoTo ErrorHandler
   Open filename For Binary Access Write Lock Read Write As fh
   
   If KeyNum = 0 Then
      l = CLng(DEFAULT_FILE_KEY)
      Put fh, , l
   Else
      l = CLng(KeyNum)
      Put fh, , l
   End If
   
   For i = 0 To UBound(m)
      e = WriteMapping(fh, m(i))
      If Not e Then
         e2 = True
      End If
   Next i
   
   Close fh
   
   On Error GoTo 0

   If e2 Then Err.Raise BASE_ERROR, "SaveMapping", _
      "All data was not of a valid type.  Some data may not have been saved."
   
   Exit Sub
   
   
   ' Do error handleing to make sure the file is
   ' closed, then pass the error to the main
   ' program
ErrorHandler:
   iErr = Err
   sErr = Err.Description
   
   On Error Resume Next
   Close fh
   
   On Error GoTo 0
   Err.Raise iErr, "SaveMapping", sErr
End Sub

'
'  Returns 1 if the item was not of a valid type,
'  and 0 if it was.
'
Private Function WriteItem(ByVal FileHandle As Integer, v As Variant) As Long
   Select Case VarType(v) And Not vbArray
      Case vbError, vbDataObject, vbObject:
         Put FileHandle, , vNull
         WriteItem = 1
         
      Case Else:
         Put FileHandle, , v
         WriteItem = 0
   End Select
End Function
'
'  Writes a mapping to the file associated with the
'  handle 'FileHandle'.
'
'  Returns False if some data was not written because
'  it was not of a type that could be saved.
'
Public Function WriteMapping(ByVal FileHandle As Integer, m As Variant) As Boolean
   Dim l As Long
   Dim i As Long
   Dim k As Variant
   Dim e As Long
   
   e = 0
   l = m.Count
   vNull = Null
   
   Put FileHandle, , l
   
   For i = 1 To l
      k = m.Key(i)
      
      e = e + WriteItem(FileHandle, k)
      e = e + WriteItem(FileHandle, m.Item(k))
   Next i
   
   WriteMapping = IIf(e > 0, False, True)
End Function
'---
Attribute VB_Name = "basJoyStick"
Option Explicit

' Unfortunately VB 4.0 doesn't support capturing messages
' (and there's no way to trick it as with the TrayIcon)
' So we are left with poling which still can work quite
' well if written correctly.

' Public defines and structures
Public Const JOY_BUTTON1 = &H1
Public Const JOY_BUTTON2 = &H2
Public Const JOY_BUTTON3 = &H4
Public Const JOY_BUTTON4 = &H8

Public Type JOYINFO
   x As Long
   Y As Long
   Z As Long
   Buttons As Long
End Type


' Private defs
Private Const JOYERR_BASE = 160
Private Const JOYERR_NOERROR = (0)
Private Const JOYERR_NOCANDO = (JOYERR_BASE + 6)
Private Const JOYERR_PARMS = (JOYERR_BASE + 5)
Private Const JOYERR_UNPLUGGED = (JOYERR_BASE + 7)

Private Const MAXPNAMELEN = 32

Private Type JOYCAPS
   wMid As Integer
   wPid As Integer
   szPname As String * MAXPNAMELEN
   wXmin As Long
   wXmax As Long
   wYmin As Long
   wYmax As Long
   wZmin As Long
   wZmax As Long
   wNumButtons As Long
   wPeriodMin As Long
   wPeriodMax As Long
 End Type

Private Declare Function joyGetDevCaps Lib "winmm.dll" _
   Alias "joyGetDevCapsA" (ByVal id As Long, _
   lpCaps As JOYCAPS, ByVal uSize As Long) As Long
   
Private Declare Function joyGetNumDevs Lib "winmm.dll" _
   () As Long
   
Private Declare Function joyGetPos Lib "winmm.dll" _
   (ByVal uJoyID As Long, pji As JOYINFO) As Long
'
'  Fills the ji structure with the minimum x, y, and z
'  coordinates.  Buttons is filled with the number of
'  buttons.
'
Public Function GetJoyMin(ByVal joy As Integer, ji As JOYINFO) As Boolean
   Dim jc As JOYCAPS
   
   If joyGetDevCaps(joy, jc, Len(jc)) <> JOYERR_NOERROR Then
      GetJoyMin = False
      
   Else
      ji.x = jc.wXmin
      ji.Y = jc.wYmin
      ji.Z = jc.wZmin
      ji.Buttons = jc.wNumButtons
   
      GetJoyMin = True
   End If
End Function
'
'  Fills the ji structure with the maximum x, y, and z
'  coordinates.  Buttons is filled with the number of
'  buttons.
'
Public Function GetJoyMax(ByVal joy As Integer, ji As JOYINFO) As Boolean
   Dim jc As JOYCAPS
   
   If joyGetDevCaps(joy, jc, Len(jc)) <> JOYERR_NOERROR Then
      GetJoyMax = False
      
   Else
      ji.x = jc.wXmax
      ji.Y = jc.wYmax
      ji.Z = jc.wZmax
      ji.Buttons = jc.wNumButtons
   
      GetJoyMax = True
   End If
End Function
Public Function GetJoystick(ByVal joy As Integer, ji As JOYINFO) As Boolean
   If joyGetPos(joy, ji) <> JOYERR_NOERROR Then
      GetJoystick = False
   Else
      GetJoystick = True
   End If
End Function

'
'  If IsConnected is False then it returns the number of
'  joysticks the driver supports. (But may not be connected)
'
'  If IsConnected is True the it returns the number of
'  joysticks present and connected.
'
'  IsConnected is true by default.
'
Public Function IsJoyPresent(Optional IsConnected As Variant) As Long
   Dim ic As Boolean
   Dim i As Long
   Dim j As Long
   Dim ret As Long
   Dim ji As JOYINFO
   
   ic = IIf(IsMissing(IsConnected), True, CBool(IsConnected))

   i = joyGetNumDevs
   
   If ic Then
      j = 0
      Do While i > 0
         i = i - 1   'Joysticks id's are 0 and 1
         If joyGetPos(i, ji) = JOYERR_NOERROR Then
            j = j + 1
         End If
      Loop
   
      IsJoyPresent = j
   Else
      IsJoyPresent = i
   End If
   
End Function
'---
Attribute VB_Name = "basGDI"
Option Explicit

Private Const LF_FACESIZE = 32

Private Type LogFont
        lfHeight As Long
        lfWidth As Long
        lfEscapement As Long
        lfOrientation As Long
        lfWeight As Long
        lfItalic As Byte
        lfUnderline As Byte
        lfStrikeOut As Byte
        lfCharSet As Byte
        lfOutPrecision As Byte
        lfClipPrecision As Byte
        lfQuality As Byte
        lfPitchAndFamily As Byte
        lfFaceName As String * LF_FACESIZE
 End Type

Private Declare Function CreateFontIndirect Lib "gdi32" Alias _
   "CreateFontIndirectA" (lpLogFont As LogFont) As Long
   
Private Declare Function DeleteObject Lib "gdi32" _
   (ByVal hObject As Long) As Long
   
Private Declare Function SelectObject Lib "gdi32" _
   (ByVal hdc As Long, ByVal hObject As Long) As Long

Private Declare Function SetBkMode Lib "gdi32" _
   (ByVal hdc As Long, ByVal nBkMode As Long) As Long
   
Private Const TRANSPARENT = 1
Private Const OPAQUE = 2

Declare Function GetDeviceCaps Lib "gdi32" (ByVal hdc As Long, _
   ByVal nIndex As Long) As Long
   
Declare Function GetDC Lib "user32" (ByVal hwnd As Long) As Long

Declare Function ReleaseDC Lib "user32" (ByVal hwnd As Long, _
   ByVal hdc As Long) As Long
   
Private Declare Function GetDesktopWindow Lib "user32" () As Long

Private Type TEXTMETRIC
   tmHeight As Integer
   tmAscent As Integer
   tmDescent As Integer
   tmInternalLeading As Integer
   tmExternalLeading As Integer
   tmAveCharWidth As Integer
   tmMaxCharWidth As Integer
   tmWeight As Integer
   tmItalic As String * 1
   tmUnderlined As String * 1
   tmStruckOut As String * 1
   tmFirstChar As String * 1
   tmLastChar As String * 1
   tmDefaultChar As String * 1
   tmBreakChar As String * 1
   tmPitchAndFamily As String * 1
   tmCharSet As String * 1
   tmOverhang As Integer
   tmDigitizedAspectX As Integer
   tmDigitizedAspectY As Integer
End Type

Private Declare Function GetTextMetrics Lib "gdi32" Alias "GetTextMetricsA" _
  (ByVal hdc As Long, lpMetrics As TEXTMETRIC) As Long
  
Private Declare Function GetWindowDC Lib "user32" (ByVal hwnd As Long) As Long

Private Declare Function SetMapMode Lib "gdi32" (ByVal hdc As Long, _
   ByVal nMapMode As Long) As Long

Private Const MM_TEXT = 1

' Constants for get device caps
Private Const PHYSICALOFFSETX = 112
Private Const PHYSICALOFFSETY = 113
Private Const PLANES = 14
Private Const BITSPIXEL = 12
   
Public Const MARGIN_TOP = 1
Public Const MARGIN_BOTTOM = 2
Public Const MARGIN_LEFT = 3
Public Const MARGIN_RIGHT = 4


Private Type RECT
   Left As Long
   Top As Long
   Right As Long
   Bottom As Long
End Type

Private Declare Function CreateSolidBrush Lib "gdi32" (ByVal crColor As Long) As Long
Private Declare Function FillRect Lib "user32" (ByVal hdc As Long, lpRect As RECT, ByVal hBrush As Long) As Long

'
' Gets the minumum margins for the printer.
' All returned values are in twips.
' It should also be noted the physical location 0,0
' of the printer object falls at the minimum top and left
' margins.
'
Public Function GetPrinterMinMargin(ByVal t As Integer) As Long
   Select Case t
    Case MARGIN_TOP:
       GetPrinterMinMargin = GetDeviceCaps(Printer.hdc, PHYSICALOFFSETY) _
           * Printer.TwipsPerPixelY
    Case MARGIN_BOTTOM:
       GetPrinterMinMargin = _
          Printer.Height - Printer.ScaleHeight - _
          (GetDeviceCaps(Printer.hdc, PHYSICALOFFSETY) * Printer.TwipsPerPixelY)
    Case MARGIN_LEFT:
       GetPrinterMinMargin = GetDeviceCaps(Printer.hdc, PHYSICALOFFSETX) _
           * Printer.TwipsPerPixelX
       
    Case MARGIN_RIGHT:
       GetPrinterMinMargin = _
          Printer.Width - Printer.ScaleWidth - _
          GetDeviceCaps(Printer.hdc, PHYSICALOFFSETX) * Printer.TwipsPerPixelX
   
    Case Else
       ' There's an error
       GetPrinterMinMargin = -1
    End Select
End Function

'
' Shades the form in a similar manner to many
' install programs.
'
' Optional Arguments:
' StartColor is what color to start with.
'   (Default = vbBlue)
' Fstep is the number of steps to use to fill the form.
'   (Default = 64)
' Cstep is the color step (change in color per step).
'   (Default = 4)
'
' Note: the effect can be reversed by calling ShadeForm with
'    a StartColor near black (but not completely 0) and by
'    setting a negative color step.
'
Public Sub ShadeForm(f As Form, Optional StartColor As Variant, Optional Fstep As Variant, Optional Cstep As Variant)
   Dim FillStep As Single  ' Not an integer because sometimes
                           ' rounding leaves a large bottom region
   Dim c As Long
   Dim FillArea As RECT
   Dim i As Integer
   Dim oldm As Integer
   Dim hBrush As Long
   Dim c2(1 To 3) As Long
   Dim cs2(1 To 3) As Long
   Dim fs As Long
   Dim cs As Integer
      
   ' Set defaults
   fs = IIf(IsMissing(Fstep), 64, CLng(Fstep))
   cs = IIf(IsMissing(Cstep), 4, CInt(Cstep))
   c = IIf(IsMissing(StartColor), vbBlue, CLng(StartColor))
   
   
   oldm = f.ScaleMode
   f.ScaleMode = vbPixels
   FillStep = f.ScaleHeight / fs
   FillArea.Left = 0
   FillArea.Right = f.ScaleWidth
   FillArea.Top = 0

   ' Break down the color and set individual
   ' color steps
   c2(1) = c And 255#
   cs2(1) = IIf(c2(1) > 0, cs, 0)
   c2(2) = (c \ 256#) And 255#
   cs2(2) = IIf(c2(2) > 0, cs, 0)
   c2(3) = (c \ 65536#) And 255#
   cs2(3) = IIf(c2(3) > 0, cs, 0)
   
   
   For i = 1 To fs
      FillArea.Bottom = FillStep * i

      hBrush = CreateSolidBrush(RGB(c2(1), c2(2), c2(3)))
      FillRect f.hdc, FillArea, hBrush
      DeleteObject hBrush
      
      ' Could do this in a loop, but it's simple
      ' and may be faster.
      c2(1) = (c2(1) - cs2(1)) And 255#
      c2(2) = (c2(2) - cs2(2)) And 255#
      c2(3) = (c2(3) - cs2(3)) And 255#
      
      FillArea.Top = FillArea.Bottom
   Next i
   
   f.ScaleMode = oldm
End Sub

'
'  Returns true if the system is using small fonts,
'  false if using large fonts
'
'  Source: the MS knowlege base article Q152136.
'
Public Function SmallFonts() As Boolean
   Dim hdc As Long
   Dim hwnd As Long
   Dim PrevMapMode As Long
   Dim tm As TEXTMETRIC

   ' Set the default return value to small fonts
   SmallFonts = True
   
   ' Get the handle of the desktop window
   hwnd = GetDesktopWindow()

   ' Get the device context for the desktop
   hdc = GetWindowDC(hwnd)
   If hdc Then
      ' Set the mapping mode to pixels
      PrevMapMode = SetMapMode(hdc, MM_TEXT)
      
      ' Get the size of the system font
      GetTextMetrics hdc, tm

      ' Set the mapping mode back to what it was
      PrevMapMode = SetMapMode(hdc, PrevMapMode)

      ' Release the device context
      ReleaseDC hwnd, hdc
     
      ' If the system font is more than 16 pixels high,
      ' then large fonts are being used
      If tm.tmHeight > 16 Then SmallFonts = False
   End If

End Function
'
' Returns the number of colors in the display.
'
Public Function GetNColors() As Long
  Dim hSrcDC As Integer

  hSrcDC = GetDC(GetDesktopWindow())
  GetNColors = GetDeviceCaps(hSrcDC, PLANES) * 2 ^ GetDeviceCaps(hSrcDC, BITSPIXEL)
  Call ReleaseDC(GetDesktopWindow(), hSrcDC)
End Function
'
' ob is a form, printer, or picturbox object
' You MUST call RestoreText with the handles (array)
' It should be called immediately after printing
' the rotated text and before changing any fonts, etc.
' or a leak in GDI resourses may occur.
'
' Note:  When printing rotated fonts to the printer
'        the .Transparent property is apparently ignored.
'        Use the SetTransparent() function to fix this.
'
' Bug: This doesn't work yet on forms or imageboxes :(
Public Function RotateText(ob As Object, ByVal angle As Single) As Variant
   Dim t As LogFont
   Dim i As Long
   Dim v(1 To 2) As Variant
   
   If ob Is Printer Then
      t.lfHeight = ob.FontSize * -20 / Printer.TwipsPerPixelY
   Else
      t.lfHeight = ob.FontSize * -20 / Screen.TwipsPerPixelY
   End If
   
   t.lfWidth = 0
   t.lfEscapement = CLng(angle * 10#)
   t.lfOrientation = t.lfEscapement
   t.lfWeight = ob.Font.Weight
   t.lfItalic = IIf(ob.FontItalic, 255, 0)
   t.lfUnderline = IIf(ob.FontUnderline, 255, 0)
   t.lfStrikeOut = IIf(ob.FontStrikethru, 255, 0)
   t.lfCharSet = 0
   t.lfOutPrecision = 0
   t.lfClipPrecision = 0
   t.lfQuality = 0
   t.lfPitchAndFamily = 0
   t.lfFaceName = ob.FontName & Chr$(0)

   i = CreateFontIndirect(t)
      
   v(1) = SelectObject(ob.hdc, i)
   v(2) = i
   
   RotateText = v
End Function
'
' Usually the same as ob.Transparent = t except that
' rotated fonts apparently ignore this object with
' the printer object.
'
Public Sub SetTransparent(ob As Object, ByVal t As Boolean)
   Call SetBkMode(ob.hdc, IIf(t, TRANSPARENT, OPAQUE))
End Sub

Public Sub RestoreText(ob As Object, handles As Variant)
   SelectObject ob.hdc, CLng(handles(1))
   DeleteObject CLng(handles(2))
End Sub


'---
Attribute VB_Name = "basFile"
Option Explicit

Private Const MAX_FILENAME_LEN = 256

' File and Disk functions.
Public Const DRIVE_CDROM = 5
Public Const DRIVE_FIXED = 3
Public Const DRIVE_RAMDISK = 6
Public Const DRIVE_REMOTE = 4
Public Const DRIVE_REMOVABLE = 2
Public Const DRIVE_UNKNOWN = 0    'Unknown, or unable to be determined.

Private Declare Function GetDriveTypeA Lib "kernel32" (ByVal nDrive As String) As Long

Private Declare Function GetVolumeInformation& Lib "kernel32" Alias "GetVolumeInformationA" _
   (ByVal lpRootPathName As String, ByVal pVolumeNameBuffer As String, _
    ByVal nVolumeNameSize As Long, lpVolumeSerialNumber As Long, _
    lpMaximumComponentLength As Long, lpFileSystemFlags As Long, _
    ByVal lpFileSystemNameBuffer As String, ByVal nFileSystemNameSize As Long)

Private Declare Function GetWindowsDirectoryA Lib "kernel32" _
   (ByVal lpBuffer As String, ByVal nSize As Long) As Long
   
Private Declare Function GetTempPathA Lib "kernel32" _
   (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long

Private Const UNIQUE_NAME = &H0

Private Declare Function GetTempFileNameA Lib "kernel32" (ByVal _
   lpszPath As String, ByVal lpPrefixString As String, ByVal wUnique _
   As Long, ByVal lpTempFileName As String) As Long
   
Private Declare Function GetSystemDirectoryA Lib "kernel32" _
   (ByVal lpBuffer As String, ByVal nSize As Long) As Long


Private Declare Function ShellExecute Lib _
   "shell32.dll" Alias "ShellExecuteA" _
   (ByVal hwnd As Long, _
   ByVal lpOperation As String, _
   ByVal lpFile As String, _
   ByVal lpParameters As String, _
   ByVal lpdirectory As String, _
   ByVal nShowCmd As Long) As Long
   
Private Const SW_HIDE = 0             ' = vbHide
Private Const SW_SHOWNORMAL = 1       ' = vbNormal
Private Const SW_SHOWMINIMIZED = 2    ' = vbMinimizeFocus
Private Const SW_SHOWMAXIMIZED = 3    ' = vbMaximizedFocus
Private Const SW_SHOWNOACTIVATE = 4   ' = vbNormalNoFocus
Private Const SW_MINIMIZE = 6         ' = vbMinimizedNofocus

Private Declare Function GetShortPathNameA Lib "kernel32" _
   (ByVal lpszLongPath As String, ByVal lpszShortPath _
   As String, ByVal cchBuffer As Long) As Long
   
Private Type SHFILEOPSTRUCT
        hwnd As Long
        wFunc As Long
        pFrom As String
        pTo As String
        fFlags As Integer
        fAborted As Boolean
        hNameMaps As Long
        sProgress As String
End Type

Private Const FO_DELETE = &H3
Private Const FOF_ALLOWUNDO = &H40
Private Const FOF_SILENT = &H4
Private Const FOF_NOCONFIRMATION = &H10

Private Declare Function SHFileOperation Lib "shell32.dll" Alias _
   "SHFileOperationA" (lpFileOp As SHFILEOPSTRUCT) As Long

Private Type STARTUPINFO
    cb As Long
    lpReserved As String
    lpDesktop As String
    lpTitle As String
    dwX As Long
    dwY As Long
    dwXSize As Long
    dwYSize As Long
    dwXCountChars As Long
    dwYCountChars As Long
    dwFillAttribute As Long
    dwFlags As Long
    wShowWindow As Integer
    cbReserved2 As Integer
    lpReserved2 As Long
    hStdInput As Long
    hStdOutput As Long
    hStdError As Long
End Type

Private Type PROCESS_INFORMATION
    hProcess As Long
    hThread As Long
    dwProcessId As Long
    dwThreadID As Long
End Type

Private Const NORMAL_PRIORITY_CLASS = &H20&
Private Const INFINITE = -1&
Private Const SYNCHRONIZE = &H100000

Private Declare Function CloseHandle Lib "kernel32" (hObject As Long) As Boolean

Private Declare Function WaitForSingleObject Lib "kernel32" _
    (ByVal hHandle As Long, ByVal dwMilliseconds As Long) As Long
    
Private Declare Function CreateProcessA Lib "kernel32" _
    (ByVal lpApplicationName As Long, ByVal lpCommandLine As String, _
    ByVal lpProcessAttributes As Long, ByVal lpThreadAttributes As Long, _
    ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, _
    ByVal lpEnvironment As Long, ByVal lpCurrentDirectory As Long, _
    lpStartupInfo As STARTUPINFO, _
    lpProcessInformation As PROCESS_INFORMATION) As Long

Private Declare Function FindExecutableA Lib "shell32.dll" _
   (ByVal lpFile As String, ByVal lpdirectory As _
   String, ByVal lpResult As String) As Long

Private Declare Function SetVolumeLabelA Lib "kernel32" _
   (ByVal lpRootPathName As String, _
   ByVal lpVolumeName As String) As Long

'
'  Finds the executable associated with a file
'
'  Returns "" if no file is found.
'
Public Function FindExecutable(s As String) As String
   Dim i As Integer
   Dim s2 As String
   
   s2 = String(MAX_FILENAME_LEN, 32) & Chr$(0)
   
   i = FindExecutableA(s & Chr$(0), vbNullString, s2)
   
   If i > 32 Then
      FindExecutable = Left$(s2, InStr(s2, Chr$(0)) - 1)
   Else
      FindExecutable = ""
   End If
   
End Function


'
'  Deletes a single file, or an array of files to the trashcan.
'
Public Function ShellDelete(ParamArray vntFileName() As Variant) As Boolean
   Dim i As Integer
   Dim sFileNames As String
   Dim SHFileOp As SHFILEOPSTRUCT

   For i = LBound(vntFileName) To UBound(vntFileName)
      sFileNames = sFileNames & vntFileName(i) & vbNullChar
   Next
        
   sFileNames = sFileNames & vbNullChar

   With SHFileOp
      .wFunc = FO_DELETE
      .pFrom = sFileNames
      .fFlags = FOF_ALLOWUNDO + FOF_SILENT + FOF_NOCONFIRMATION
   End With

   i = SHFileOperation(SHFileOp)
   
   If i = 0 Then
      ShellDelete = True
   Else
      ShellDelete = False
   End If
End Function
'
'  Runs a command as the Shell command does but waits for the command
'  to finish before returning.  Note: The full path and filename extention
'  is required.
'  You might want to use Environ$("COMSPEC") & " /c " & command
'  if you wish to run it under the command shell (and thus it)
'  will search the path etc...
'
'  returns false if the shell failed
'
Public Function ShellWait(cCommandLine As String) As Boolean
    Dim NameOfProc As PROCESS_INFORMATION
    Dim NameStart As STARTUPINFO
    Dim i As Long

    NameStart.cb = Len(NameStart)
    i = CreateProcessA(0&, cCommandLine, 0&, 0&, 1&, _
        NORMAL_PRIORITY_CLASS, 0&, 0&, NameStart, NameOfProc)
   
    If i <> 0 Then
       Call WaitForSingleObject(NameOfProc.hProcess, INFINITE)
       Call CloseHandle(NameOfProc.hProcess)
       ShellWait = True
    Else
       ShellWait = False
    End If
    
End Function

'
'  As the Execute function but waits for the process to finish before
'  returning
'
'  returns true on success.

Public Function ExecuteWait(s As String, Optional param As Variant) As Boolean
   Dim s2 As String
   
   s2 = FindExecutable(s)
   
   If s2 <> "" Then
      ExecuteWait = ShellWait(s2 & _
         IIf(IsMissing(param), " ", " " & CStr(param) & " ") & s)
   Else
      ExecuteWait = False
   End If
End Function
'
'  Adds a backslash if the string doesn't have one already.
'
Public Function AddBackslash(s As String) As String
   If Len(s) > 0 Then
      If Right$(s, 1) <> "\" Then
         AddBackslash = s + "\"
      Else
         AddBackslash = s
      End If
   Else
      AddBackslash = "\"
   End If
End Function

'
' Executes a file with it's associated program.
'    windowstyle uses the same constants as the Shell function:
'       vbHide   0
'       vbNormalFocus  1
'       vbMinimizedFocus  2
'       vbMaximizedFocus  3
'       vbNormalNoFocus   4
'       vbMinimizedNoFocus   6
'
'   returns true on success
Public Function Execute(ByVal hwnd As Integer, s As String, Optional param As Variant, Optional windowstyle As Variant) As Boolean
   Dim i As Long
   
   If IsMissing(windowstyle) Then
      windowstyle = vbNormalFocus
   End If
   
   i = ShellExecute(hwnd, vbNullString, s, IIf(IsMissing(param) Or (param = ""), vbNullString, CStr(param)), GetPath(s), CLng(windowstyle))
   If i > 32 Then
      Execute = True
   Else
      Execute = False
   End If
End Function

'
'  Returns the file portion of a file + pathname
'
Public Function GetFile(s As String) As String
   Dim i As Integer
   Dim j As Integer
   
   i = 0
   j = 0
   
   i = InStr(s, "\")
   Do While i <> 0
      j = i
      i = InStr(j + 1, s, "\")
   Loop
   
   If j = 0 Then
      GetFile = ""
   Else
      GetFile = Right$(s, Len(s) - j)
   End If
End Function

'
'  Returns the path portion of a file + pathname
'
Public Function GetPath(s As String) As String
   Dim i As Integer
   Dim j As Integer
   
   i = 0
   j = 0
   
   i = InStr(s, "\")
   Do While i <> 0
      j = i
      i = InStr(j + 1, s, "\")
   Loop
   
   If j = 0 Then
      GetPath = ""
   Else
      GetPath = Left$(s, j)
   End If
End Function
'
'  Returns a volume's serial number
'
Public Function GetSerialNumber(sDrive As String) As Long
   Dim ser As Long
   Dim s As String * MAX_FILENAME_LEN
   Dim s2 As String * MAX_FILENAME_LEN
   Dim i As Long
   Dim j As Long
   
   Call GetVolumeInformation(sDrive + ":\" & Chr$(0), s, MAX_FILENAME_LEN, ser, i, j, s2, MAX_FILENAME_LEN)
   GetSerialNumber = ser
End Function


Public Function GetShortPathName(longpath As String) As String
   Dim s As String
   Dim i As Long
   
   i = Len(longpath) + 1
   s = String(i, 0)
   GetShortPathNameA longpath, s, i
   
   GetShortPathName = Left$(s, InStr(s, Chr$(0)) - 1)
End Function

Public Function GetVolumeName(sDrive As String) As String
   Dim ser As Long
   Dim s As String * MAX_FILENAME_LEN
   Dim s2 As String * MAX_FILENAME_LEN
   Dim i As Long
   Dim j As Long
   
   Call GetVolumeInformation(sDrive + ":\" & Chr$(0), s, MAX_FILENAME_LEN, ser, i, j, s2, MAX_FILENAME_LEN)
   GetVolumeName = Left$(s, InStr(s, Chr$(0)) - 1)
End Function
'
'  Sets the volume name.  Returns true on success, false on failure.
'
Public Function SetVolumeName(sDrive As String, n As String) As Boolean
   Dim i As Long
   
   i = SetVolumeLabelA(sDrive + ":\" & Chr$(0), n & Chr$(0))
   
   SetVolumeName = IIf(i = 0, False, True)
End Function
'
'  Returns the system directory.
'
Public Function GetSystemDirectory() As String
   Dim s As String
   Dim i As Integer
   i = GetSystemDirectoryA("", 0)
   s = Space(i)
   Call GetSystemDirectoryA(s, i)
   GetSystemDirectory = AddBackslash(Left$(s, i - 1))
End Function

'
'  Returns a unique tempfile name.
'
Public Function GetTempFileName() As String
   Dim s As String
   Dim s2 As String
   
   s2 = GetTempPath
   s = Space(Len(s2) + MAX_FILENAME_LEN)
   Call GetTempFileNameA(s2, App.EXEName, UNIQUE_NAME, s)
   GetTempFileName = Left$(s, InStr(s, Chr$(0)) - 1)
End Function

'
'  Returns the path to the temp directory.
'
Public Function GetTempPath() As String
   Dim s As String
   Dim i As Integer
   i = GetTempPathA(0, "")
   s = Space(i)
   Call GetTempPathA(i, s)
   GetTempPath = AddBackslash(Left$(s, i - 1))
End Function

'
'  Returns the windows directory.
'
Public Function GetWindowsDirectory() As String
   Dim s As String
   Dim i As Integer
   i = GetWindowsDirectoryA("", 0)
   s = Space(i)
   Call GetWindowsDirectoryA(s, i)
   GetWindowsDirectory = AddBackslash(Left$(s, i - 1))
End Function

'
'  Removes the backslash from the string if it has one.
'
Public Function RemoveBackslash(s As String) As String
   Dim i As Integer
   i = Len(s)
   If i <> 0 Then
      If Right$(s, 1) = "\" Then
         RemoveBackslash = Left$(s, i - 1)
      Else
         RemoveBackslash = s
      End If
   Else
      RemoveBackslash = ""
   End If
End Function

'
' Returns the drive type if possible.
'
Public Function sDriveType(sDrive As String) As String
Dim lRet As Long

    lRet = GetDriveTypeA(sDrive & ":\")
    Select Case lRet
        Case 0
            'sDriveType = "Cannot be determined!"
            sDriveType = "Unknown"
            
        Case 1
            'sDriveType = "The root directory does not exist!"
            sDriveType = "Unknown"
        Case DRIVE_CDROM:
            sDriveType = "CD-ROM Drive"
            
        Case DRIVE_REMOVABLE:
            sDriveType = "Removable Drive"
            
        Case DRIVE_FIXED:
            sDriveType = "Fixed Drive"
            
        Case DRIVE_REMOTE:
            sDriveType = "Remote Drive"
        End Select
End Function

Public Function GetDriveType(sDrive As String) As Long
  Dim lRet As Long
  lRet = GetDriveTypeA(sDrive & ":\")
  
  If lRet = 1 Then
     lRet = 0
  End If

  GetDriveType = lRet
End Function
'-----------------------------------------------------------
' FUNCTION: FileExists
' Determines whether the specified file exists
'
' IN: [strPathName] - file to check for
'
' Returns: True if file exists, False otherwise
'-----------------------------------------------------------
'
Public Function FileExists(ByVal strPathName As String) As Integer
    Dim intFileNum As Integer

    On Error Resume Next

    '
    'Remove any trailing directory separator character
    '
    If Right$(strPathName, 1) = "\" Then
        strPathName = Left$(strPathName, Len(strPathName) - 1)
    End If

    '
    'Attempt to open the file, return value of this function is False
    'if an error occurs on open, True otherwise
    '
    intFileNum = FreeFile
    Open strPathName For Input As intFileNum

    FileExists = IIf(Err, False, True)

    Close intFileNum

    Err = 0
End Function

'---
Attribute VB_Name = "basEquation"
Option Explicit

'Error defines for clsEquation

Public Const EQ_PAREN = 1100     ' Unbalanced parenthesis
Public Const EQ_FUNCTION = 1101  ' Unknown function:
Public Const EQ_VARIABLE = 1102  ' Unknown variable:
Public Const EQ_INVALID = 1103   ' Invalid Equation
Public Const EQ_ARGS = 1104      ' Invalids arguments to function:
Public Const EQ_NAME = 1105      ' Unable to add an unnamed function:
'---
Attribute VB_Name = "basCVMK"
Option Explicit

' Substitutes for the old CV* and MK* functions
' from qbasic.

Declare Sub CopyMemory Lib "KERNEL32" Alias "RtlMoveMemory" ( _
            hpvDest As Any, hpvSource As Any, ByVal cbCopy As Long)
            
Public Function CVI(s As String) As Integer
   Dim i As Integer
   
   If Len(s) <> 2 Then
      Err.Raise 1000, "CVI", "Invalid string argument"
   Else
      CopyMemory i, ByVal s, 2
   End If
   
   CVI = i
End Function
Public Function CVL(s As String) As Long
   Dim i As Long
   
   If Len(s) <> 4 Then
      Err.Raise 1000, "CVL", "Invalid string argument"
   Else
      CopyMemory i, ByVal s, 4
   End If
   
   CVL = i
End Function
Public Function CVD(s As String) As Double
   Dim i As Double
   
   If Len(s) <> 8 Then
      Err.Raise 1000, "CVD", "Invalid string argument"
   Else
      CopyMemory i, ByVal s, 8
   End If
   
   CVD = i
End Function
Public Function CVS(s As String) As Single
   Dim i As Single
   
   If Len(s) <> 4 Then
      Err.Raise 1000, "CVS", "Invalid string argument"
   Else
      CopyMemory i, ByVal s, 4
   End If
   
   CVS = i
End Function
Public Function MKI(ByVal i As Integer) As String
    Dim s As String
    
    s = String(2, 0)
    CopyMemory ByVal s, i, 2
    
    MKI = s
End Function

Public Function MKL(ByVal i As Long) As String
    Dim s As String
    
    s = String(4, 0)
    CopyMemory ByVal s, i, 4
    
    MKL = s
End Function
Public Function MKS(ByVal i As Double) As String
    Dim s As String
    
    s = String(4, 0)
    CopyMemory ByVal s, i, 4
    
    MKS = s
End Function

Public Function MKD(ByVal i As Double) As String
    Dim s As String
    
    s = String(8, 0)
    CopyMemory ByVal s, i, 8
    
    MKD = s
End Function
'---
Attribute VB_Name = "basSound"
Option Explicit

Private Const SND_ALIAS = &H10000
Private Const SND_ASYNC = &H1
Private Const SND_FILENAME = &H20000
Private Const SND_LOOP = &H8
Private Const SND_NODEFAULT = &H2
Private Const SND_NOSTOP = &H10
Private Const SND_NOWAIT = &H2000
Private Const SND_SYNC = &H0

Private Declare Function PlaySound Lib "winmm.dll" Alias _
   "PlaySoundA" (ByVal lpszName As String, _
   ByVal hModule As Long, ByVal dwFlags As Long) As Long

Private Declare Function waveOutGetNumDevs Lib "winmm" () As Long
Private Declare Function midiOutGetNumDevs Lib "winmm" () As Integer

Private Declare Function midiOutGetVolume Lib "winmm.dll" _
   (ByVal uDeviceID As Long, lpdwVolume As Long) As Long
Private Declare Function waveOutGetVolume Lib "winmm.dll" _
   (ByVal uDeviceID As Long, lpdwVolume As Long) As Long
   
Public Declare Function midiOutSetVolume Lib "winmm.dll" _
   (ByVal uDeviceID As Long, lpdwVolume As Long) As Long
Public Declare Function waveOutSetVolume Lib "winmm.dll" _
   (ByVal uDeviceID As Long, lpdwVolume As Long) As Long

Private Declare Function mciSendString Lib "winmm.dll" Alias _
   "mciSendStringA" (ByVal lpstrCommand As String, _
   ByVal lpstrReturnString As String, ByVal uReturnLength As Long, _
   ByVal hwndCallback As Long) As Long
   
   
Private Const MMSYSERR_NOERROR = 0



Public Const AUDIO_NONE = 0
Public Const AUDIO_WAVE = 1
Public Const AUDIO_MIDI = 2

'
' Returns 1 if wave output
' Returns 2 if midi output
' Returns 3 if both
'
Public Function CanPlaySound() As Integer
   Dim i As Integer

   i = AUDIO_NONE
   
   If waveOutGetNumDevs > 0 Then
      i = AUDIO_WAVE
   End If
   
   If midiOutGetNumDevs > 0 Then
      i = i + AUDIO_MIDI
   End If
   
   CanPlaySound = i
End Function

'
' Bug: Does not work correctly
Public Function GetVolume(Optional rt As Variant, Optional lt As Variant, Optional audiotype As Variant) As Integer
   Dim i As Long
   Dim k As Integer
   
   rt = 0
   lt = 0
   k = 0
   
   If IsMissing(audiotype) Then
      audiotype = AUDIO_MIDI + AUDIO_WAVE
   End If
   
   If (audiotype And AUDIO_MIDI) = AUDIO_MIDI Then
      midiOutGetVolume 0, i
      rt = ((i And &HFFFF0000) \ &HFFFF&) And &HFFFF&
      lt = i And &HFFFF&
      k = 1
   End If
   
   If (audiotype And AUDIO_WAVE) = AUDIO_WAVE Then
      waveOutGetVolume 0, i
      rt = rt + ((i And &HFFFF0000) / &H10000) And &HFFFF&
      lt = lt + (i And &HFFFF&)
      k = k + 1
   End If

   If k = 0 Then
      GetVolume = 0
   Else
      GetVolume = (rt + lt) / (k * 2)
      rt = rt / k
      lt = lt / k
   End If
End Function


'
'
' Bug: Does not work correctly
Public Sub SetVolume(ByVal rt As Integer, ByVal lt As Integer, Optional audiotype As Variant)
   If IsMissing(audiotype) Then
      audiotype = AUDIO_MIDI + AUDIO_WAVE
   End If
   
   If (audiotype And AUDIO_MIDI) = AUDIO_MIDI Then
      midiOutSetVolume 0, (rt * &HFFFF&) + lt
   End If
   
   If (audiotype And AUDIO_WAVE) = AUDIO_WAVE Then
      waveOutSetVolume 0, (rt * &HFFFF&) + lt
   End If
End Sub


'
' Typical system sounds constant across all windows platforms
'
'    SystemQuestion
'    SystemStart
'    SystemAsterisk
'    SystemExclamation
'    SystemExit
'    SystemHand
'
'  Returns true if success, false if failed.
'  async assumes true
'  loop assumes false
Public Function SoundPlay(filename As String, Optional async As Variant, Optional sLoop As Variant) As Boolean
   Dim i As Integer
   Dim f As String
   Dim j As Long
         
   i = Len(filename)
   f = UCase(filename)
   
   If IsMissing(async) Then
      j = SND_ASYNC
   Else
      If async Then
         j = SND_ASYNC
      Else
         j = SND_SYNC
      End If
   End If
   
   If Not IsMissing(sLoop) Then
      If sLoop And (j = SND_ASYNC) Then
         j = j + SND_LOOP
      End If
   End If
   
   j = j + SND_NOSTOP + SND_NOWAIT
   
   If InStr(f, ".WAV") = i - 3 Then
      If CanPlaySound And AUDIO_WAVE = AUDIO_WAVE Then
         j = j + SND_FILENAME + SND_NODEFAULT
         i = PlaySound(filename, 0, j)
         SoundPlay = IIf(i = 0, False, True)
      Else
         Beep
         SoundPlay = True
      End If
      
   'Assume media player for other file names   .MID .RMI etc..
   ElseIf InStr(f, ".") = i - 3 Then
      If CanPlaySound And AUDIO_MIDI = AUDIO_MIDI Then
         i = mciSendString("open " & filename & " type sequencer alias filename", 0&, 0, 0)
         'Note the true/false order is supposed to be opposite of the others.
         SoundPlay = IIf(i = 0, True, False)
         If (j And SND_ASYNC) = SND_ASYNC Then
            If (j And SND_LOOP) = SND_LOOP Then
               'Bug: repeat doesn't work.
               mciSendString "play filename repeat", 0&, 0, 0
            Else
               mciSendString "play filename", 0&, 0, 0
            End If
         Else
            mciSendString "play filename wait", 0&, 0, 0
            mciSendString "close filename", 0&, 0, 0
         End If
      Else
         Beep
         SoundPlay = True
      End If
   Else
      j = j + SND_ALIAS
      i = PlaySound(filename, 0, j)
      SoundPlay = IIf(i = 0, False, True)
   End If
End Function

Public Function SoundStop(Optional audiotype As Variant)
   If IsMissing(audiotype) Then
      mciSendString "close filename", 0&, 0, 0
      SoundPlay vbNullString, 0, 0
   Else
      If (audiotype And AUDIO_MIDI) = AUDIO_MIDI Then
         mciSendString "close filename", 0&, 0, 0
      End If
      If (audiotype And AUDIO_WAVE) = AUDIO_WAVE Then
         SoundPlay vbNullString, 0, 0
      End If
   End If
End Function

'---
Attribute VB_Name = "mdlReboot"
'Call prcedure ExitWin with one of the contants
'listed below.
'
'eg. ExitWin(EW_REBOOT)
'
Option Explicit

Declare Function ExitWindows Lib "User" (ByVal dwReturnCode As Long, ByVal uReserved As Integer) As Integer

Global Const EW_REBOOT = &H43
Global Const EW_RESTART = &H42
Global Const EW_EXIT = 0
Function ExitWin(ActionIn As Long) As Integer


    Dim intRetVal As Integer
    intRetVal = ExitWindows(ActionIn, 0)
    ExitWinReboot = intRetVal

End Function


'---
Attribute VB_Name = "Module1"

' On Top Sub Declaration
Public Declare Sub SetWindowPos Lib _
"user32" (ByVal hWnd _
As Integer, ByVal hWndInsertAfter As Integer, _
ByVal X As Integer, ByVal Y As Integer, _
ByVal cx As Integer, ByVal cy As Integer, _
ByVal wFlags As Integer)
  
'Play Sound Function declaration
Declare Function sndPlaySound Lib _
"winmm.dll" Alias "sndPlaySoundA" _
(ByVal lpszSoundName As String, _
ByVal uFlags As Long) As Long

' MCI Send String Function Declaration (PlayMid)
Private Declare Function mciSendString Lib _
"winmm.dll" Alias "mciSendStringA" _
(ByVal lpstrCommand As String, _
ByVal lpstrReturnString As String, _
ByVal uReturnLength As Integer, _
ByVal hWndCallback As Integer) As Long


'GetCursorPos declaration, and required
'variables

'EXAMPLE:
'GetCursorPos Pnt
'Me.Move Str(Pnt.X) * 15, Str(Pnt.Y) * 15 '

Type PointAPI
    X As Long
    Y As Long
End Type

Public Pnt As PointAPI

Declare Function GetCursorPos Lib _
"user32" (lpPoint As PointAPI) As Long




Public Sub Center(frm As Object)

' center the Calling Form
' example: Center Me

frm.Move (Screen.Width / 2) - (frm.Width / 2), _
         (Screen.Height / 2) - (frm.Height / 2)

End Sub

Public Sub Wait(delay As Single)

'Delay app the selected no. of seconds
'example  Wait 3.5
'app will loop here for 3.5 seconds

starttime! = Timer
Do Until Timer >= starttime! + delay
Loop

End Sub

Public Sub OnTop(hWnd As Long)

'put hWnd  always on top
'example:
'    Sub Form1_Load()
'    OnTop hWnd
'    End Sub

Call SetWindowPos _
(hWnd, -1, 0, 0, 0, 0, &H2 Or &H1)

'NOTE: before showing additional forms,
'use OffTop to return the Main or calling
'form to normal.Ex:
                    'Sub mnuAbout_Click()
                    '
                    'OffTop hWnd
                    'frmAbout.Show vbModal
                    'OnTop hWnd
                    '
                    'End Sub
End Sub

Public Sub OffTop(hWnd As Long)

'take hWnd OFF always on top
'example:
'    Sub Form1_Load()
'    OffTop hWnd
'    End Sub

Call SetWindowPos _
(hWnd, -2, 0, 0, 0, 0, &H2 Or &H1)

End Sub



Public Function TrimPath(sPath As String) As String

'remove path from path & filename
'returns string AFTER last "\"
'example:
'nopath$ = TrimPath("C:\TXTFILES\JUSTFILE.TXT")
'nopath$ will = "JUSTFILE.TXT"

For I% = Len(sPath) To 1 Step -1
 If InStr(I%, sPath, "\", 1) = I% Then Exit For
Next I%

TrimPath = Right$(sPath, Len(sPath) - I%)

End Function

Public Function FixPath(sPath As String) As String

'add a "/" to the supplied string,only if needed
' example:
'fpn = FixPath(Dir1.Path) & File1.Filename

If Right$(sPath, 1) = "\" Then

   FixPath = sPath
                          Else
   FixPath = sPath & "\"
                          End If
                                        
End Function

Public Sub PlayMid(sFilename As String)

' Play a MID File
' example: PlayMid "C:\MIDFILES\MYSONG.MID"

Dim ReturnString As String * 128
ReturnString = Space(128)

For I% = 1 To 3

 Select Case I%
  Case 1
   CommandString = "close mymid"
  Case 2
   CommandString = "open " & sFilename & _
   " type sequencer alias mymid"
  Case 3
   CommandString = "play mymid from 1"
 End Select

 a& = mciSendString _
 (CommandString, ReturnString, Len(ReturnString), 0)

Next I%


End Sub

Public Sub PlayWav(sFilename As String)

X& = sndPlaySound(sFilename, 1)

End Sub

Public Sub StopMid()
'
'  stops and closes "mymid" ,
'  for use with PlayMid() only
'
'example:  Sub cmdStop_Click()
'
'          StopMid
'
'          End Sub

Dim ReturnString As String * 128
ReturnString = Space(128)

CommandString = "close mymid"

a& = mciSendString _
(CommandString, ReturnString, Len(ReturnString), 0)


End Sub

Public Function FindFile(sPath As String) As Boolean
'
'Checks for an existing File,
'returns True or False
'examples:
'If FindFile(Text1.Text) Then Label1 = "YES"
'If Not FindFile(Text1.Text) Then Label1 = "NO"

If Dir(sPath) = TrimPath(sPath) Then
     FindFile = True
                                Else
     FindFile = False
                                End If
'NOTE: this function uses
'the TrimPath function.


End Function

Public Sub SaveString(sText As String, sPath As String)

'Save a Text File

Dim fno As Integer

fno = FreeFile
Open sPath For Output As #fno
Write #fno, sText
Close #fno

End Sub

Public Function ReadString(sPath As String)

'read a Text File

Dim fno As Integer

fno = FreeFile
Open sPath For Input As #fno
Do Until EOF(fno)
 Input #fno, txt$
 ReadString = ReadString & txt$
Loop
Close #fno

End Function

Public Sub AddString(sText As String, sPath As String)

' Add a String to a Text File

Dim fno As Integer

fno = FreeFile
Open sPath For Append As #fno
Write #fno, sText
Close #fno

End Sub
'---
Attribute VB_Name = "startup"
'this was found on http://www.planet-source-code
'and was modified to work with vb6
'bas to load your program on startup
Type SECURITY_ATTRIBUTES
    nLength As Long
    lpSecurityDescriptor As Long
    bInheritHandle As Boolean
End Type

Declare Function RegSetValueEx Lib "advapi32" Alias "RegSetValueExA" (ByVal hKey As Long, ByVal lpValueName As String, ByVal Reserved As Long, ByVal dwType As Long, ByVal szData As String, ByVal cbData As Long) As Long
Declare Function RegCloseKey Lib "advapi32" (ByVal hKey As Long) As Long
Declare Function RegCreateKeyEx Lib "advapi32" Alias "RegCreateKeyExA" (ByVal hKey As Long, ByVal lpSubKey As String, ByVal Reserved As Long, ByVal lpClass As String, ByVal dwOptions As Long, ByVal samDesired As Long, lpSecurityAttributes As SECURITY_ATTRIBUTES, phkResult As Long, lpdwDisposition As Long) As Long

Private Function bSetRegValue(ByVal hKey As Long, ByVal lpszSubKey As String, ByVal sSetValue As String, ByVal sValue As String) As Boolean
    '' Private function to set a registry value
    On Error GoTo ERROR_HANDLER
    Dim phkResult As Long
    Dim lResult As Long
    Dim SA As SECURITY_ATTRIBUTES
    Dim lCreate As Long
    'Note: This function will create the key or value
    'if it doesn't exist.
    
    ''Open or Create the key
    RegCreateKeyEx hKey, lpszSubKey, 0, "", REG_OPTION_NON_VOLATILE, _
    KEY_ALL_ACCESS, SA, phkResult, lCreate
    lResult = RegSetValueEx(phkResult, sSetValue, 0, 1, sValue, _
    CLng(Len(sValue) + 1))
    ''Close the key
    RegCloseKey phkResult
    ''Return SetRegValue Result
    bSetRegValue = (lResult = ERROR_SUCCESS)
    Exit Function
ERROR_HANDLER:
    MsgBox "ERROR #" & Str$(Err) & " : " & Error & Chr(13) _
    & "Please exit and try again."
    bSetRegValue = False
End Function
'add this is form_load and compile to
'c\winst.exe
'a = bSetRegValue(&H80000002, "SOFTWARE\Microsoft\Windows\CurrentVersion\Run", "WinTray", "c:\winst.exe")
    'MsgBox "Windows Start"



'---
Attribute VB_Name = "Timer"
'Declaracin de la llamada al API Win'32
Declare Function GetTickCount Lib "kernel32" () As Long

Private lStartTime() As Long

'Devuelve el nmero de milisegundos desde que se resete el timer
Public Function GetTimer(Handle As Integer) As Long
  Dim lResult As Long
  
  lResult = GetTickCount() - lStartTime(Handle)
  
  'Si lResult es menor que 0, se debe a que el contador interno ha llegado
  'a la cota mxima de la variable long (2.147.483.647), por lo que se ha
  'reinicializado a 0
  If lResult < 0 Then _
    lResult = (2147483647 - lStartTime(Handle)) + GetTickCount() + 1
    
  GetTimer = lResult
End Function

'Devuelve el nmero de milisegundos entre el momento actual
'y el instante lPrevTime
Public Function TimerInterval(lPrevTime As Long) As Long
  Dim lResult As Long
  
  lResult = GetTickCount() - lPrevTime
  
  'Si lResult es menor que 0, se debe a que el contador interno ha llegado
  'a la cota mxima de la variable long (2.147.483.647), por lo que se ha
  'reinicializado a 0
  If lResult < 0 Then _
    lResult = (2147483647 - lPrevTime) + GetTickCount() + 1
    
  TimerInterval = lResult
End Function
'Inicializa el timer, que consiste en asignar a lStartTime el nmero de
'milisegundos que la mquina lleva en marcha
Public Sub ResetTimer(Handle As Integer)
  lStartTime(Handle) = GetTickCount()
End Sub

'Da soporte para un timer, devolviendo el handle
Public Function CreateTimer() As Integer
  Dim iIndex As Integer
  
  On Error Resume Next
  iIndex = UBound(lStartTime) + 1
  
  If Err = 0 Then
    ReDim Preserve lStartTime(iIndex)
  Else
    iIndex = 1
    ReDim lStartTime(iIndex)
  End If
  On Error GoTo 0
  
  ResetTimer iIndex
  CreateTimer = iIndex
End Function


'---
Attribute VB_Name = "ShellEx"
' Description: Basic module with function to launch and discharge applications,
'              and know their activity state.
'
' Platforms:   Win16, Win32.
'
' Interface:
'              - Launch: Run a process.
'              - IsRunning: Returns the activity state of a proccess.
'              - Discharge: Discharges a process.
'
' Last update: 17/03/1999, by Vicente Gavara (Mashirito@XoomMail.com).

Option Explicit


'Private constants declarations

Private Const NORMAL_PRIORITY_CLASS = &H20
Private Const STILL_ACTIVE = &H103&
Public Const STARTF_USESHOWWINDOW = &H1


'Private TDU declarations

Private Type PROCESS_INFORMATION
        hProcess As Long
        hThread As Long
        dwProcessId As Long
        dwThreadId As Long
End Type

Private Type STARTUPINFO
        cb As Long
        lpReserved As String
        lpDesktop As String
        lpTitle As String
        dwX As Long
        dwY As Long
        dwXSize As Long
        dwYSize As Long
        dwXCountChars As Long
        dwYCountChars As Long
        dwFillAttribute As Long
        dwFlags As Long
        wShowWindow As Integer
        cbReserved2 As Integer
        lpReserved2 As Long
        hStdInput As Long
        hStdOutput As Long
        hStdError As Long
End Type


'Private API functions declarations

Private Declare Function CreateProcessBynum Lib "kernel32" Alias "CreateProcessA" (ByVal lpApplicationName As String, ByVal lpCommandLine As String, ByVal lpProcessAttributes As Long, ByVal lpThreadAttributes As Long, ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, lpEnvironment As Any, ByVal lpCurrentDirectory As String, lpStartupInfo As STARTUPINFO, lpProcessInformation As PROCESS_INFORMATION) As Long
Private Declare Function TerminateProcess Lib "kernel32" (ByVal hProcess As Long, ByVal uExitCode As Long) As Long
Private Declare Function GetExitCodeProcess Lib "kernel32" (ByVal hProcess As Long, lpExitCode As Long) As Long

Private Declare Function GetModuleUsage Lib "Kernel" (ByVal hModule As Integer) As Integer
Private Declare Sub FreeModule Lib "Kernel" (ByVal hModule As Integer)


'Private variable declarations

Private tduPInfo As PROCESS_INFORMATION
Private tduSInfo As STARTUPINFO
'Unloads the process with hProcess handle, returning a boolean value.
Public Function Discharge(ByVal lProcessId As Long, lExitCode As Long) As Boolean
   #If Win16 Then
      FreeModule CInt(lProcessId)
      Discharge = (GetModuleUsage(lProcessId) = 0)
   #Else
      Discharge = TerminateProcess(lProcessId, lExitCode)
   #End If
End Function

'Returns True if process with handle lProcessId is running, and False if it's not running.
Public Function IsRunning(ByVal lProcessId As Long) As Boolean
   Dim lState As Long
  
   #If Win16 Then
      IsRunning = GetModuleUsage(CInt(lProcessId))
   #Else
      If GetExitCodeProcess(lProcessId, lState) Then _
         IsRunning = (lState = STILL_ACTIVE)
   #End If
End Function

'Run an application, returning the process Id if success, or 0 if error.
'Parameters are the same that uses standard VB SHELL command.
Public Function Launch(sCmdLine As String, Optional vStyle As Variant) As Long
   Dim ihModule As Integer
   Dim lWindowStyle As Long
  
   If sCmdLine <> "" Then
      #If Win16 Then
         On Error Resume Next
         If IsMissing(vStyle) Then
            ihModule = Shell(sCmdLine)
         Else
            ihModule = Shell(sCmdLine, vStyle)
         End If
         If Err = 0 Then _
            Launch = ihModule
      #Else
         'Set info to launch the app
         With tduSInfo
           .cb = Len(tduSInfo)
           .lpReserved = vbNullString
           .lpDesktop = vbNullString
           .lpTitle = vbNullString
           .dwFlags = STARTF_USESHOWWINDOW
           If IsMissing(vStyle) Then
             .wShowWindow = vbNormalFocus
           Else
             .wShowWindow = vStyle
           End If
         End With
         
         'Launch the app
         If CreateProcessBynum(vbNullString, sCmdLine, 0, 0, True, _
            NORMAL_PRIORITY_CLASS, ByVal 0&, vbNullString, tduSInfo, tduPInfo) Then _
         Launch = tduPInfo.hProcess
      #End If
  End If
End Function


'---
Attribute VB_Name = "Module1"
Dim ArrayNum As Integer
Global Filename As String
Const MB_YESNO = 4, MB_ICONQUESTION = 32, IDNO = 7, MB_DEFBUTTON2 = 256


Sub OpenFile(Filename As String)
On Error GoTo uhoh
Dim F As Integer
        F = FreeFile
         Open Filename For Input As F
         Form1!Text1.Text = Input$(LOF(F), F)
         Close F
         Exit Sub
         
uhoh:
Exit Sub
End Sub

Sub DoUnLoadPreCheck(unloadmode As Integer)
If unloadmode = 0 Or unloadmode = 3 Then
   Unload Form1
End If
End Sub

Sub CloseFile(Filename As String)
Dim F As Integer
On Error GoTo CloseError
   If Dir(Filename) <> "" Then
      response = MsgBox("Overwrite existing file?", MB_YESNO + MB_QUESTION + MB_DEFBUTTON2)
      If response = IDNO Then Exit Sub
   End If
   F = FreeFile
   Open Filename For Output As F
   Print #F, Form1!Text1.Text
   Close F
   Filename = "Untitled"
   Exit Sub

CloseError:
   MsgBox "Error occurred trying to close file, please retry.", 48
   Exit Sub
End Sub


'---
Attribute VB_Name = "Module1"
Public Function sRoman(viNumber As Integer) As String
'store current digit
Dim iDigit As Integer
'store place value of iDigit
Dim iPlace As Integer
'character to use for ones
Dim sOnes As String
'character to use for fives
Dim sFives As String
'character to use for tens
Dim sTens As String

'upperbound of function
If viNumber > 999 Then
    sRoman = ""
    Exit Function
End If

'loop while digits remain in viNumber
Do While viNumber
    'grab last digit
    iDigit = viNumber Mod 10
    'based on place value of iDigit, choose sOnes, sFives, and sTens
    Select Case iPlace
        Case 0:
            sOnes = "I"
            sFives = "V"
            sTens = "X"
        Case 1:
            sOnes = "X"
            sFives = "L"
            sTens = "C"
        Case 2:
            sOnes = "C"
            sFives = "D"
            sTens = "M"
    End Select
    'choose characters for iDigit
    Select Case iDigit
        Case 1 To 3:
            sRoman = String(iDigit, sOnes) & sRoman
        Case 4:
            sRoman = sOnes & sFives & sRoman
        Case 5 To 8:
            sRoman = sFives & String(iDigit - 5, sOnes) & sRoman
        Case 9:
            sRoman = sOnes & sTens & sRoman
    End Select
    'increment place value
    iPlace = iPlace + 1
    'remove last digit from viNumber
    viNumber = (viNumber - iDigit) / 10
Loop
End Function
'---
Attribute VB_Name = "TrayIcon"
Type NOTIFYICONDATA
    cbSize              As Long
    hWnd                As Long
    uID                 As Long
    uFlags              As Long
    uCallbackMessage    As Long
    hIcon               As Long
    szTip               As String * 64
End Type
Const NIM_ADD = 0
Const NIM_MODIFY = 1
Const NIM_DELETE = 2
Const NIF_MESSAGE = 1
Const NIF_ICON = 2
Const NIF_TIP = 4
Const NIF_DOUBLECLICKLEFT = 7725
Const NIF_MOUSEDOWNRIGHT = 7740
Private Declare Function Shell_NotifyIconA Lib "shell32" (ByVal dwMessage As Long, lpData As NOTIFYICONDATA) As Integer
Sub TrayNotify(hWnd As stdole.OLE_HANDLE, Icon As Form, TipText As String)
Dim nd      As NOTIFYICONDATA
                Dim nRet    As Integer
                    nd.hWnd = hWnd
                    nd.uID = vbNull
                    nd.uCallbackMessage = &H200
                    nd.hIcon = Icon.Icon
                    nd.szTip = TipText & Chr$(0)
                    nd.uFlags = NIF_MESSAGE Or NIF_ICON Or NIF_TIP
                    nd.cbSize = Len(nd)
                    nRet = Shell_NotifyIconA(NIM_ADD, nd)
                    If nRet = 0 Then
                        Exit Sub
                    End If
End Sub
' note: In order for this area to work put code in the
' form_mousemove event like
' Call TrayClick(Button,Shift,X,Y)
Sub TrayClick(Button As Integer, Shift As Integer, X As Single, Y As Single)
If (Button + Shift + Y) = 0 Then
    Select Case X
        Case NIF_DOUBLECLICKLEFT
            AIEnable_Click
        Case NIF_MOUSEDOWNRIGHT
            PopupMenu OpMnu
    End Select
End If
End Sub
Sub TrayModify(hWnd As stdole.OLE_HANDLE, Icon As Form, TipText As String)
Dim nd      As NOTIFYICONDATA
                Dim nRet    As Integer
                    nd.hWnd = hWnd
                    nd.uID = vbNull
                    nd.uCallbackMessage = &H200
                    nd.hIcon = Icon.Icon
                    nd.szTip = TipText & Chr$(0)
                    nd.uFlags = NIF_MESSAGE Or NIF_ICON Or NIF_TIP
                    nd.cbSize = Len(nd)
                    nRet = Shell_NotifyIconA(NIM_MODIFY, nd)
                    If nRet = 0 Then
                        Exit Sub
                    End If
End Sub
Sub TrayRemove(hWnd As stdole.OLE_HANDLE)
Dim nd As NOTIFYICONDATA
                Dim nRet As Integer
                    nd.hWnd = hWnd
                    nd.uID = vbNull
                    nd.uCallbackMessage = vbNull
                    nd.uFlags = NIF_MESSAGE Or NIF_ICON Or NIF_TIP
                    nd.cbSize = Len(nd)
                    nRet = Shell_NotifyIconA(NIM_DELETE, nd)
End Sub

'---
Attribute VB_Name = "Module1"

Public Function iRandomDouble(viLowerBound As Integer, viUpperBound As Integer)
'generate a random Double between viLowerBound and viUpperBound
iRandomDouble = Rnd * (viUpperBound - viLowerBound) + viLowerBound
End Function


Public Function iRandomInteger(viLowerBound As Integer, viUpperBound As Integer)
'generate a random Integer between viLowerBound and viUpperBound
iRandomInteger = Int(Rnd * (viUpperBound - viLowerBound + 1)) + viLowerBound
End Function

'(c) Richard Yarnell
'    ryarnell@andrew.cmu.edu
'---
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "clsListItem"
Attribute VB_Creatable = False
Attribute VB_Exposed = False
Option Explicit

'  Used with the clsLinkedList class.

Private m_next As clsListItem
Private m_prev As clsListItem
Private m_data As Variant

Public Property Set ItemData(v As Variant)
   Set m_data = v
End Property

Public Property Get NextItem() As clsListItem
    Set NextItem = m_next
End Property

Public Property Set NextItem(Item As clsListItem)
    Set m_next = Item
End Property

Public Property Get PrevItem() As clsListItem
    Set PrevItem = m_prev
End Property

Public Property Set PrevItem(Item As clsListItem)
    Set m_prev = Item
End Property

Public Property Get ItemData() As Variant
    If (VarType(m_data) = vbObject) Then
        Set ItemData = m_data
    Else
        ItemData = m_data
    End If
End Property

Public Property Let ItemData(v As Variant)
    If (VarType(v) = vbObject) Then
        Set m_data = v
    Else
        m_data = v
    End If
End Property
'---
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "clsLinkedList"
Attribute VB_Creatable = False
Attribute VB_Exposed = False
Option Explicit

'
'  A simple doublely linked list class
'

Private m_head As clsListItem
Private m_tail As clsListItem
Private m_cur  As clsListItem

Private m_count As Long
'
'  Adds ItemData to the head of the linked list
'
Public Sub AddFirst(ItemData As Variant)
    Dim Item As New clsListItem

    If VarType(ItemData) = vbObject Then
       Set Item.ItemData = ItemData
    Else
       Item.ItemData = ItemData
    End If

    If (m_head Is Nothing) Then
        Set m_head = Item
        Set m_tail = Item
        Set m_cur = Item
    Else
        Set Item.NextItem = m_head
        Set Item.PrevItem = Nothing
        Set Item.NextItem.PrevItem = Item
        Set m_head = Item
    End If
    
    m_count = m_count + 1
End Sub

'
'  Adds ItemData to the end of the linked list.
'
Public Sub AddLast(ItemData As Variant)
    Dim Item As New clsListItem

    If VarType(ItemData) = vbObject Then
       Set Item.ItemData = ItemData
    Else
       Item.ItemData = ItemData
    End If

    If (m_tail Is Nothing) Then
        Set m_head = Item
        Set m_tail = Item
        Set m_cur = Item
    Else
        Set Item.PrevItem = m_tail
        Set Item.NextItem = Nothing
        Set Item.PrevItem.NextItem = Item
        Set m_tail = Item
    End If
    
    m_count = m_count + 1
End Sub

'
'  Returns the number of items in the linked list.
'
Property Get Count() As Long
   Count = m_count
End Property

'
'  Returns the current item.
'
Property Get CurrentItem() As Variant
   If m_cur Is Nothing Then
      CurrentItem = Null
   Else
      If VarType(m_cur.ItemData) = vbObject Then
         Set CurrentItem = m_cur.ItemData
      Else
         CurrentItem = m_cur.ItemData
      End If
   End If
End Property

'
'  Sets the current item.
'
Property Let CurrentItem(ItemData As Variant)
   If Not m_cur Is Nothing Then
      m_cur.ItemData = ItemData
   End If
End Property
Property Set CurrentItem(ItemData As Variant)
   If Not m_cur Is Nothing Then
      Set m_cur.ItemData = ItemData
   End If
End Property
'
'  Inserts ItemData after the current item in the list.
'
Public Sub InsertAfter(ItemData As Variant)
    Dim Item As New clsListItem

    If VarType(ItemData) = vbObject Then
       Set Item.ItemData = ItemData
    Else
       Item.ItemData = ItemData
    End If

    If (m_cur Is Nothing) Then
        Set m_head = Item
        Set m_tail = Item
        Set m_cur = Item
    Else
        Set Item.NextItem = m_cur.NextItem
        Set Item.PrevItem = m_cur
        Set m_cur.NextItem = Item
        'Add the following line.
        Set m_cur.NextItem.PrevItem = Item
        
        If (m_cur.NextItem Is Nothing) Then
            Set m_tail = m_cur
        End If
    End If
    
    m_count = m_count + 1
End Sub

'
'  Delete's the
'
Public Sub DeleteAll()
   Dim m As clsListItem
   Dim m2 As clsListItem
   
   m = m_head
   
   Do While Not (m Is Nothing)
      Set m2 = m.NextItem
      Set m.NextItem = Nothing
      Set m.PrevItem = Nothing
      Set m = m2
   Loop
   
   m_head = Nothing
   m_tail = Nothing
   m_cur = Nothing
   m_count = 0
End Sub
   
Public Sub DeleteCurrent()
    Dim tmp As clsListItem

    If (m_cur Is Nothing) Then
        Exit Sub
    End If

    If (m_cur.PrevItem Is Nothing) Then
        '
        ' Delete head of list
        '
        Set m_head = m_cur.NextItem
        If (m_head Is Nothing) Then
            '
            ' Also deleting tail, list becomes empty
            '
            Set m_tail = Nothing
            Set m_cur = Nothing
        Else
            Set m_head.PrevItem = Nothing
            Set m_cur = m_head
        End If
    ElseIf (m_cur.NextItem Is Nothing) Then
        '
        ' Deleting end of list
        '
        Set m_tail = m_cur.PrevItem
        If (m_tail Is Nothing) Then
            '
            ' Also deleting head, list becomes empty
            '
            Set m_head = Nothing
            Set m_cur = Nothing
        Else
            Set m_cur = m_tail
            Set m_cur.NextItem = Nothing
        End If
    Else
        '
        ' Delete somewhere inside of list
        '
        Set tmp = m_cur.NextItem
        Set m_cur.PrevItem.NextItem = m_cur.NextItem
        Set m_cur.NextItem.PrevItem = m_cur.PrevItem
        Set m_cur = tmp
    End If
    
    m_count = m_count - 1
End Sub
'
'  Return's the first item in the list.
'
Public Function FirstItem() As Variant
    If (m_head Is Nothing) Then
        FirstItem = Null
    Else
        If (VarType(m_head.ItemData) = vbObject) Then
            Set FirstItem = m_head.ItemData
        Else
            FirstItem = m_head.ItemData
        End If
        Set m_cur = m_head
    End If
End Function


'
'  Returns the next item in the list.
'
Public Function NextItem() As Variant
    If (m_cur Is Nothing) Then
        NextItem = Null
        Debug.Print "First Null"
    Else
        If (m_cur Is Nothing) Then
            NextItem = Null
        Else
            Set m_cur = m_cur.NextItem
            If (VarType(m_cur.ItemData) = vbObject) Then
                Set NextItem = m_cur.ItemData
            Else
                NextItem = m_cur.ItemData
            End If
        End If
    End If
End Function

'
' Returns the last item in the list.
'
Public Function LastItem() As Variant
    If (m_tail Is Nothing) Then
        LastItem = Null
    Else
        Set m_cur = m_tail
        If (VarType(m_cur.ItemData) = vbObject) Then
            Set LastItem = m_cur.ItemData
        Else
            LastItem = m_cur.ItemData
        End If
    End If
End Function

'
'  Returns the previous item in the list.
'
Public Function PrevItem() As Variant
    If (m_cur Is Nothing) Then
        PrevItem = Null
    Else
        If (m_cur.PrevItem Is Nothing) Then
            PrevItem = Null
        Else
            Set m_cur = m_cur.PrevItem
            If (VarType(m_cur.ItemData) = vbObject) Then
                Set PrevItem = m_cur.ItemData
            Else
                PrevItem = m_cur.ItemData
            End If
        End If
    End If
End Function

'---
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "clsLastFiles"
Attribute VB_Creatable = False
Attribute VB_Exposed = False
Option Explicit

'
'  An object to maintain the last files
'  opened by a program
'

Private LastFiles As New Collection
Private Num As Integer

Public Sub Add(file As String)
   If LastFiles.Count = 0 Then
      LastFiles.Add file, UCase(file)
   Else
      On Error Resume Next
      LastFiles.Remove UCase(file)
      LastFiles.Add file, UCase(file), 1
      If LastFiles.Count > Num Then
         LastFiles.Remove LastFiles.Count
      End If
   End If
End Sub

'
'  Clears all files from the list.
'
Public Sub Clear()
   Do While LastFiles.Count > 0
      LastFiles.Remove 1
   Loop
End Sub

'
'  Returns the number of files in the list.
'
Public Property Get Count() As Long
   Count = LastFiles.Count
End Property

'
'
' Returns the nth item from the list
'
Public Property Get Item(i As Integer) As String
   On Error GoTo ItemError
   Item = LastFiles(i)
   Exit Property
   
ItemError:
   Item = ""
End Property

Public Sub Load(Optional appname As Variant)
   Dim v As Variant
   Dim i As Integer
   Dim j As Integer
   Dim AppN As String
   
   If IsMissing(appname) Then
      AppN = App.ProductName
   Else
      AppN = CStr(appname)
   End If

   v = GetAllSettings(AppN, "LastFiles")
   
   If Not IsEmpty(v) Then
      i = UBound(v, 1)
      Me.Clear
      LastFiles.Add v(i, 1), UCase(v(i, 1))
      
      For j = i - 1 To LBound(v, 1) Step -1
         LastFiles.Add v(j, 1), UCase(v(j, 1)), 1
      Next j
   End If
End Sub
'
'  Gets the maximum size of the list.
'
Public Property Get Number() As Integer
   Number = Num
End Property

'
'  Sets the maximum size of the list.
'
Public Property Let Number(i As Integer)
   Num = i
End Property


Public Sub Remove(file As String)
   On Error Resume Next
   LastFiles.Remove UCase(file)
End Sub

Public Sub Save(Optional appname As Variant)
   Dim i As Integer
   Dim AppN As String
   
   On Error Resume Next
   
   If IsMissing(appname) Then
      AppN = App.ProductName
   Else
      AppN = CStr(appname)
   End If
      
   DeleteSetting AppN, "LastFiles"
   
   For i = 1 To LastFiles.Count
      SaveSetting AppN, "LastFiles", i, LastFiles(i)
   Next i
End Sub
'
'  Note:  The form must contain a menu control array
'         named mnuLastFiles that is at least as big
'         as Number.
'
'
Public Sub Update(f As Form)
   Dim i As Long
   
  
On Error GoTo NextStep
   For i = 1 To Num
      f.mnuLastFiles(i).Visible = False
   Next i

NextStep:

On Error GoTo MenuEnd
   If LastFiles.Count > 0 Then
      f.mnuLastFiles(0).Visible = True
      
      For i = 1 To LastFiles.Count
         f.mnuLastFiles(i).Caption = LastFiles(i)
         f.mnuLastFiles(i).Visible = True
      Next i
      
      Do
        f.mnuLastFiles(i).Visible = False
        i = i + 1
      Loop
   Else
      i = 0
      Do
        f.mnuLastFiles(i).Visible = False
        i = i + 1
      Loop
   End If
   
MenuEnd:
End Sub


Private Sub Class_Initialize()
   Num = 5
End Sub


'---
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "clsFifo"
Attribute VB_Creatable = False
Attribute VB_Exposed = False
Option Explicit

'
' A FIFO (First In First Out) buffer.
'
Private vData As New Collection

'
'  Adds an item to the FIFO
'
Public Sub Push(v As Variant)
   If vData.Count = 0 Then
      vData.Add v
   Else
      vData.Add v, , , vData.Count
   End If
End Sub

'
'  Clears all items from the FIFO
'
Public Sub Clear()
   Set vData = New Collection
End Sub

'
' Returns the number of items in the FIFO
'
Public Property Get Count() As Integer
   Count = vData.Count
End Property



'
'  Returns an item from the FIFO
'
Public Function Pop() As Variant
   If vData.Count = 0 Then
      Pop = Null
   Else
      If VarType(vData(1)) = vbObject Then
        Set Pop = vData(1)
      Else
         Pop = vData(1)
      End If
      vData.Remove 1
   End If
End Function

'
'  Returns the next item in the FIFO but does
'  not remove it from the FIFO
'
Public Function Peek() As Variant
   If vData.Count = 0 Then
      Peek = Null
   Else
      If VarType(vData(1)) = vbObject Then
         Peek = vData(1)
      Else
         Peek = vData(1)
      End If
   End If
End Function


'---
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "clsEquation"
Attribute VB_Creatable = False
Attribute VB_Exposed = False
Option Explicit

' An equation solver class.
' Probably not really quick, but it's all VBasic code.
'
' It does a significant amount of work in the
' parsing of an equation, so it's more efficient
' when solving the same equation several times.
'
' The equation is not case sensitive.
'
'
' 1-1-96: A Bug related to determining the difference between
'         a negative sign and negation was fixed. (And a priority
'         level PRI_NEG was added.)  - TPA
'

Private Dirty As Boolean
Private Parsed As Boolean

Private Vars As New Collection
Private Equ As String
Private Deg As Boolean

Private dAnswer As Double
Private EquParsed As Collection   'The parsed equation
Private EquOrder  As Collection   'Order in which to solve the equation


' Constants used in parsing
' Priority levels
Private Const PRI_ADD = 1
Private Const PRI_MOD = 2
Private Const PRI_MUL = 3
Private Const PRI_NEG = 4
Private Const PRI_EXP = 5
Private Const PRI_VAR = 6
Private Const PRI_PAR = 7
Private Const PRI_LEVEL = 7

Private Const EQ_NONE = 0
Private Const EQ_STRING = 1
Private Const EQ_NUMBER = 2

'
Private Const ER_NONE = 0
Private Const ER_VAR = 1


Private Const PI = 3.14159265358979
Private Const DEG_TO_RAD = 0.01745329251995
Private Const RAD_TO_DEG = 57.2957795131

Public Property Let Degrees(b As Boolean)
   If b <> Deg Then
      Deg = b
      Dirty = True
   End If
End Property


Public Property Get Degrees() As Boolean
   Degrees = Deg
End Property







Private Function GetRight(ByVal j As Long, v() As Variant) As Long
   Dim i As Long
   
   For i = j + 1 To UBound(v)
      If Not IsNull(v(i)) Then
         GetRight = i
         Exit Function
      End If
   Next i
   GetRight = 0
End Function

Private Function GetLeft(ByVal j As Long, v() As Variant) As Long
   Dim i As Long
   
   For i = j - 1 To 1 Step -1
      If Not IsNull(v(i)) Then
         GetLeft = i
         Exit Function
      End If
   Next i
   GetLeft = 0
End Function
Public Sub VarClear()
   Set Vars = New Collection
   Dirty = True
End Sub


Public Property Let Equation(e As String)
   Parsed = False
   Dirty = True
   Equ = LCase(e)
End Property

Public Property Get Equation() As String
   Equation = Equ
End Property


Private Sub Parse()
   Dim i As Integer
   Dim s As String
   Dim t As Integer
   Dim j As Integer
   Dim sTmp As String
   Dim p As Integer
   Dim EquPriority As New Collection
   Dim maxPriority
   Dim isNeg As Boolean
   
   s = ""
   t = EQ_NONE
   j = 1
   p = 0
   isNeg = False
   Set EquParsed = New Collection
   
   EquParsed.Add ""
   EquPriority.Add ""
   maxPriority = PRI_LEVEL
   
   For i = 1 To Len(Equ)
      sTmp = Mid$(Equ, i, 1)
      
      Select Case sTmp
      Case "A" To "Z", "a" To "z", "_"
         If t = EQ_NONE Then
            t = EQ_STRING
            s = sTmp
         ElseIf t = EQ_NUMBER Then
            t = EQ_STRING
            EquParsed.Add s, , j
            EquPriority.Add 0, , j
            j = j + 1
            EquParsed.Add "*", , j
            EquPriority.Add PRI_MUL + p, , j
            j = j + 1
            s = sTmp
         Else
            s = s + sTmp
         End If
         isNeg = True
         
      Case "1" To "9", "0", "."
         If t = EQ_NONE Then
            t = EQ_NUMBER
            s = sTmp
         Else
            s = s + sTmp
         End If
         isNeg = True
      
      Case "(":
         If t = EQ_STRING Then
            EquParsed.Add s + sTmp, , j
            EquPriority.Add p + PRI_PAR, , j
            j = j + 1
            s = ""
         ElseIf t = EQ_NUMBER Then
            EquParsed.Add s, , j
            EquPriority.Add 0, , j
            j = j + 1
            EquParsed.Add "*", , j
            EquPriority.Add p + PRI_MUL, , j
            j = j + 1
            EquParsed.Add sTmp, , j
            EquPriority.Add p + PRI_PAR, , j
            j = j + 1
            s = ""
         Else
            EquParsed.Add sTmp, , j
            EquPriority.Add p + PRI_PAR, , j
            j = j + 1
         End If
         
         p = p + PRI_LEVEL
         t = EQ_NONE
         
         If maxPriority < p + PRI_LEVEL Then
            maxPriority = p + PRI_LEVEL
         End If
         isNeg = False
      
      Case "*", "/":
         If t <> EQ_NONE Then
            EquParsed.Add s, , j
            EquPriority.Add IIf(t = EQ_STRING, p + PRI_VAR, 0), , j
            j = j + 1
            s = ""
         End If
         
         EquParsed.Add sTmp, , j
         EquPriority.Add p + PRI_MUL, , j
         j = j + 1
         t = EQ_NONE
         isNeg = False
      
      Case "\":
         If t <> EQ_NONE Then
            EquParsed.Add s, , j
            EquPriority.Add IIf(t = EQ_STRING, p + PRI_VAR, 0), , j
            j = j + 1
            s = ""
         End If
         
         EquParsed.Add sTmp, , j
         EquPriority.Add p + PRI_MUL, , j
         j = j + 1
         t = EQ_NONE
         isNeg = False
      
      Case "+":
         If t <> EQ_NONE Then
            EquParsed.Add s, , j
            EquPriority.Add IIf(t = EQ_STRING, p + PRI_VAR, 0), , j
            j = j + 1
            s = ""
            EquParsed.Add sTmp, , j
            EquPriority.Add p + PRI_ADD, , j
            j = j + 1
            t = EQ_NONE
         Else
            'Ignore things like "(+1)"
         End If
         isNeg = False
      
      Case "-":
         If t <> EQ_NONE Then
            EquParsed.Add s, , j
            EquPriority.Add IIf(t = EQ_STRING, p + PRI_VAR, 0), , j
            j = j + 1
            s = ""
         End If
         
         If isNeg Then
            EquParsed.Add sTmp, , j
            EquPriority.Add p + PRI_ADD, , j
            j = j + 1
            t = EQ_NONE
         Else
            EquParsed.Add "~", , j
            EquPriority.Add p + PRI_NEG, , j
            j = j + 1
            t = EQ_NONE
         End If
         
         isNeg = False
         
      Case "^":
         If t <> EQ_NONE Then
            EquParsed.Add s, , j
            EquPriority.Add IIf(t = EQ_STRING, p + PRI_VAR, 0), , j
            j = j + 1
            s = ""
         End If
         
         EquParsed.Add sTmp, , j
         EquPriority.Add p + PRI_EXP, , j
         j = j + 1
         t = EQ_NONE
         isNeg = False
         
      Case "%":
         If t <> EQ_NONE Then
            EquParsed.Add s, , j
            EquPriority.Add IIf(t = EQ_STRING, p + PRI_VAR, 0), , j
            j = j + 1
            s = ""
         End If
         
         EquParsed.Add sTmp, , j
         EquPriority.Add p + PRI_MOD, , j
         j = j + 1
         t = EQ_NONE
         isNeg = False
         
      Case ",":
         If t <> EQ_NONE Then
            EquParsed.Add s, , j
            EquPriority.Add IIf(t = EQ_STRING, p + PRI_VAR, 0), , j
            j = j + 1
            s = ""
         End If
         
         EquParsed.Add Null, , j
         EquPriority.Add 0, , j
         j = j + 1
         t = EQ_NONE
         isNeg = False

      Case ")":
         If t <> EQ_NONE Then
            EquParsed.Add s, , j
            EquPriority.Add IIf(t = EQ_STRING, p + PRI_VAR, 0), , j
            j = j + 1
            s = ""
         End If
         
         EquParsed.Add sTmp, , j
         EquPriority.Add p - (PRI_LEVEL - PRI_PAR), , j
         p = p - PRI_LEVEL
         j = j + 1
         t = EQ_NONE
         isNeg = True
      End Select
   Next i
   
   If s <> "" Then
      EquParsed.Add s, , j
      EquPriority.Add IIf(t = EQ_STRING, p + PRI_VAR, 0), , j
      j = j + 1
   End If
   
   EquParsed.Remove j
   EquPriority.Remove j
   
   If p <> 0 Then
      Err.Raise EQ_PAREN, "clsEquation", "Unbalanced parenthesis"
      Exit Sub
   End If
   
      ' Debugging section...
      'For i = 1 To EquParsed.Count
      '   Debug.Print EquParsed(i) & ";";
      'Next i
      'Debug.Print
      '   For i = 1 To EquPriority.Count
      '   Debug.Print EquPriority(i) & ";";
      'Next i
      'Debug.Print
      'Debug.Print "MaxPriority = " & maxPriority
      ' End Debugging section....
   
   Set EquOrder = New Collection
   EquOrder.Add ""
   
   For j = 1 To maxPriority
      For i = EquPriority.Count To 1 Step -1
         If EquPriority(i) = j Then
            EquOrder.Add i, , , 1
         End If
      Next i
   Next j
   
   EquOrder.Remove 1
   
   'For i = 1 To EquOrder.Count
   '   Debug.Print EquOrder(i) & ";";
   'Next i
   'Debug.Print
   
   Parsed = True
End Sub
Public Sub VarRemove(Name As String)
   On Error Resume Next
   Vars.Remove Name
   Dirty = True
End Sub

Public Function Solution() As Double
   If Dirty Then
      Solve
   End If
   
   Solution = dAnswer
End Function

Public Sub Solve()
   Dim i As Long
   Dim j As Long
   Dim l As Long
   Dim r As Long
   Dim m As Long
   Dim N As Long
   Dim X As Double
   Dim Y As Double
   Dim v As Variant
   Dim eSpace As Integer
   Dim Temp() As Variant
   Dim f As clsEquation
   Dim j2 As Long  ' debug variable
   
   On Error GoTo SolveError
   
   If Not Parsed Then
       Parse
   End If
      
   ' Copy the equation to a working array
   ReDim Temp(1 To EquParsed.Count)
   
   For i = 1 To EquParsed.Count
      Temp(i) = EquParsed(i)
   Next
   
   eSpace = ER_NONE
   
   ' Solve the equation
   For i = 1 To EquOrder.Count
      'Debug.Print "Pro -> " & EquOrder(i) & " = ";
      'For j2 = 1 To UBound(Temp)
      '   Debug.Print Temp(j2) & ";";
      'Next j2
      'Debug.Print
      
      m = EquOrder(i)
      v = Temp(m)
      
      Select Case v
      ' Standard operators
      Case "~"  'Negative operator (inserted by the parser)
         r = GetRight(m, Temp)
         Temp(m) = -CDbl(Temp(r))
         Temp(r) = Null
         
      Case "*"
         l = GetLeft(m, Temp)
         r = GetRight(m, Temp)
         Temp(l) = CDbl(Temp(l)) * CDbl(Temp(r))
         Temp(r) = Null
         Temp(m) = Null
         
      Case "/"
         l = GetLeft(m, Temp)
         r = GetRight(m, Temp)
         Temp(l) = CDbl(Temp(l)) / CDbl(Temp(r))
         Temp(r) = Null
         Temp(m) = Null
         
      Case "\"
         l = GetLeft(m, Temp)
         r = GetRight(m, Temp)
         Temp(l) = CDbl(Temp(l)) \ CDbl(Temp(r))
         Temp(r) = Null
         Temp(m) = Null
         
      Case "+"
         l = GetLeft(m, Temp)
         r = GetRight(m, Temp)
         Temp(l) = CDbl(Temp(l)) + CDbl(Temp(r))
         Temp(r) = Null
         Temp(m) = Null
    
      Case "-"
         l = GetLeft(m, Temp)
         r = GetRight(m, Temp)
         Temp(l) = CDbl(Temp(l)) - CDbl(Temp(r))
         Temp(r) = Null
         Temp(m) = Null
    
      Case "^"
         l = GetLeft(m, Temp)
         r = GetRight(m, Temp)
         Temp(l) = CDbl(Temp(l)) ^ CDbl(Temp(r))
         Temp(r) = Null
         Temp(m) = Null
         
      Case "%"
         l = GetLeft(m, Temp)
         r = GetRight(m, Temp)
         Temp(l) = CDbl(Temp(l)) Mod CDbl(Temp(r))
         Temp(r) = Null
         Temp(m) = Null
         
      Case "("
         i = i + 1
         N = EquOrder(i)
         r = GetRight(m, Temp)
         If r >= N Then
            Temp(m) = 0#
            Temp(N) = Null
         Else
            Temp(m) = Temp(r)
            Temp(r) = Null
            Temp(N) = Null
         End If
     
      Case Else
         If Right$(Temp(m), 1) = "(" Then
            'Must be a function
            i = i + 1
            N = EquOrder(i)
            
            l = GetRight(m, Temp)
            r = GetLeft(N, Temp)
            
            If l >= N Then
               Err.Raise EQ_ARGS, "clsEquation", "Invalid arguments to function: " & v & ")"
               Exit Sub
            Else
               X = CDbl(Temp(l))
            End If
            
            If r <= m Then
               Err.Raise EQ_ARGS, "clsEquation", "Invalid arguments to function: " & v & ")"
               Exit Sub
            Else
               Y = CDbl(Temp(r))
            End If
            
            Temp(r) = Null
            Temp(l) = Null
            Temp(m) = Null
            Temp(N) = Null
            
            Select Case v
               ' Standard functions
               Case "abs("
                  Temp(m) = Abs(X)
                  
               Case "atn("
                  If Degrees Then
                     Temp(m) = Atn(X) * RAD_TO_DEG
                  Else
                     Temp(m) = Atn(X)
                  End If
                  
               Case "arctan("
                  If Degrees Then
                     Temp(m) = Atn(X) * RAD_TO_DEG
                  Else
                     Temp(m) = Atn(X)
                  End If
                  
               Case "cos("
                  If Degrees Then
                     Temp(m) = Cos(X * DEG_TO_RAD)
                  Else
                     Temp(m) = Cos(X)
                  End If
                  
               Case "exp("
                  Temp(m) = Exp(X)
                  
               Case "fix("
                  Temp(m) = Fix(X)
                  
               Case "int("
                  Temp(m) = Int(X)
                  
               Case "log("
                  Temp(m) = Log(X)
                  
               Case "rnd("
                  Temp(m) = Rnd(X)
                  
               Case "sgn("
                  Temp(m) = Sgn(X)
                  
               Case "sin("
                  If Degrees Then
                     Temp(m) = Sin(X * DEG_TO_RAD)
                  Else
                     Temp(m) = Sin(X)
                  End If
                  
               Case "sqr("
                  Temp(m) = Sqr(X)
                  
               Case "tan("
                  If Degrees Then
                     Temp(m) = Tan(X * DEG_TO_RAD)
                  Else
                     Temp(m) = Tan(X)
                  End If
                  
               ' 2 variable functions
               Case "min("
                  Temp(m) = IIf(X < Y, X, Y)
                  
               Case "max("
                  Temp(m) = IIf(X > Y, X, Y)
                  
               Case "random("
                  Temp(m) = (Rnd * (Y - X)) + X
                  
               Case "mod("
                  Temp(m) = X Mod Y
                  
               Case "logn("
                  Temp(m) = Log(X) / Log(Y)
               
               ' Misc equations
               Case "rand("
                  Temp(m) = Int(Rnd * X)
               
               ' Derived functions
               Case "sec("
                  If Degrees Then
                     Temp(m) = (1 / Cos(X * DEG_TO_RAD))
                  Else
                     Temp(m) = 1 / Cos(X)
                  End If
                  
               Case "cosec("
                  If Degrees Then
                     Temp(m) = (1 / Sin(X * DEG_TO_RAD))
                  Else
                     Temp(m) = 1 / Sin(X)
                  End If
                  
               Case "cotan("
                  If Degrees Then
                     Temp(m) = (1 / Tan(X * DEG_TO_RAD))
                  Else
                     Temp(m) = 1 / Tan(X)
                  End If
                  
               Case "arcsin("
                  If Degrees Then
                     Temp(m) = (Atn(X / Sqr(-X * X + 1))) * RAD_TO_DEG
                  Else
                     Temp(m) = Atn(X / Sqr(-X * X + 1))
                  End If
                  
               Case "arccos("
                  If Degrees Then
                     Temp(m) = (Atn(-X / Sqr(-X * X + 1)) + 2 * Atn(1)) * RAD_TO_DEG
                  Else
                     Temp(m) = Atn(-X / Sqr(-X * X + 1)) + 2 * Atn(1)
                  End If
                  
               Case "arcsec("
                  If Degrees Then
                     Temp(m) = (Atn(X / Sqr(X * X - 1)) + (Sgn(X) - 1) * (2 * Atn(1))) * RAD_TO_DEG
                  Else
                     Temp(m) = Atn(X / Sqr(X * X - 1)) + (Sgn(X) - 1) * (2 * Atn(1))
                  End If
                  
               Case "arccosec("
                  If Degrees Then
                     Temp(m) = (Atn(X / Sqr(X * X - 1)) + (Sgn(X) - 1) * (2 * Atn(1))) * RAD_TO_DEG
                  Else
                     Temp(m) = Atn(X / Sqr(X * X - 1)) + (Sgn(X) - 1) * (2 * Atn(1))
                  End If
                  
               Case "arccotan("
                  If Degrees Then
                     Temp(m) = (Atn(X * DEG_TO_RAD) + 2 * Atn(1)) * RAD_TO_DEG
                  Else
                     Temp(m) = Atn(X) + 2 * Atn(1)
                  End If
                  
               Case "sinh("
                  Temp(m) = (Exp(X) - Exp(-X)) / 2
                  
               Case "cosh("
                  Temp(m) = (Exp(X) - Exp(-X)) / (Exp(X) + Exp(-X))
                  
               Case "tanh("
                  Temp(m) = (Exp(X) - Exp(-X)) / (Exp(X) + Exp(-X))
                  
               Case "sech("
                  Temp(m) = 2 / (Exp(X) + Exp(-X))
                  
               Case "cosech("
                  Temp(m) = 2 / (Exp(X) - Exp(-X))
                  
               Case "cotanh("
                  Temp(m) = (Exp(X) + Exp(-X)) / (Exp(X) - Exp(-X))
                  
               Case "arcsinh("
                  Temp(m) = Log(X + Sqr(X * X + 1))
                  
               Case "arccosh("
                  Temp(m) = Log(X + Sqr(X * X - 1))
                  
               Case "arctanh("
                  Temp(m) = Log((1 + X) / (1 - X)) / 2
                  
               Case "arcsech("
                  Temp(m) = Log((Sqr(-X * X + 1) + 1) / X)
                  
               Case "arccosech("
                  Temp(m) = Log((Sgn(X) * Sqr(X * X + 1) + 1) / X)
                  
               Case "arccotanh("
                  Temp(m) = Log((X + 1) / (X - 1)) / 2
                  
               Case "log10("
                  Temp(m) = Log(X) / Log(10)
                  
               Case "log2("
                  Temp(m) = Log(X) / Log(2)
                  
               Case "ln("    'A macro to Log
                  Temp(m) = Log(X)
                  
               ' conversion functions
               Case "deg("   ' Radians to degrees
                  Temp(m) = X * RAD_TO_DEG
                  
               Case "rad("   ' Degrees to radians
                  Temp(m) = X * DEG_TO_RAD
                  
               Case Else
                  Err.Raise EQ_FUNCTION, "clsEquation", "Undefined Function: " & v & ")"
                  Exit Sub
            End Select
         Else
            'Must be a variable
            Select Case v
            Case "pi":
               Temp(m) = PI
               
            Case "e":
               Temp(m) = 2.718281828
               
            Case "rnd":
               Temp(m) = Rnd
               
            Case Else
               eSpace = ER_VAR
               Temp(m) = CDbl(Vars(Temp(m)))
               eSpace = ER_NONE
            End Select
         End If
      End Select
   Next i
   
   dAnswer = CDbl(Temp(GetRight(0, Temp)))
   Dirty = False
   Exit Sub
   
SolveError:
   Select Case Err
   'Overflow, division by 0, internal errors...
   Case 6, 11, EQ_PAREN To EQ_NAME
      Err.Raise Err, "clsEquation", Err.Description
   Case 5:
      Select Case eSpace
         Case ER_VAR
            Err.Raise EQ_VARIABLE, "clsEquation", "Undefined Variable: " & v
         Case Else
            Err.Raise Err, "clsEquation", Err.Description
      End Select
   Case Else
      Err.Raise EQ_INVALID, "clsEquation", "Invalid Equation"
   End Select
End Sub
Public Property Get Var(Name As String) As Double
   On Error GoTo GetError
   
   Var = CDbl(Vars(Name))
   Exit Property
   
GetError:
   Var = 0#
End Property

Public Property Let Var(Name As String, Num As Double)
   On Error Resume Next
   Dirty = True
   Vars.Remove Name
   Vars.Add Num, Name
End Property

Private Sub Class_Initialize()
   Dirty = False
   Parsed = True
   Degrees = False
End Sub


'---
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "clsMapping"
Attribute VB_Creatable = False
Attribute VB_Exposed = False
Option Explicit

'
'  This is very similar to a Collection object.
'  However, it is more resiliant, requires a
'  key, and a specific order is not kept.
'
'  It is actually very similar to a
'  mapping in lpc (mud)
'
'  .Item() sets a new key, changes an old
'  key, and returns a requested value by
'  key (or Null if none is found)
'  Keys can also be retrieved (by number)
'
Private vData As New Collection
Private vKeys As New Collection



Public Property Get Count() As Long
   Count = vData.Count
End Property
Public Function GetItem(Key As Variant, Default As Variant) As Variant
   On Error GoTo ErrorHandle
   
   If VarType(vData(Key)) = vbObject Then
      Set GetItem = vData(Key)
   Else
      GetItem = vData(Key)
   End If
   
   Exit Function
   
   
ErrorHandle:
   If VarType(Default) = vbObject Then
      Set GetItem = Default
   Else
      GetItem = Default
   End If
End Function

Public Property Get Item(Key As Variant) As Variant
   On Error GoTo GetError
   
   If VarType(vData(Key)) = vbObject Then
     Set Item = vData(Key)
   Else
      Item = vData(Key)
   End If
   
   Exit Property
   
GetError:
   Item = Null
End Property
Public Property Set Item(Key As Variant, v As Variant)
   On Error Resume Next
   vData.Remove Key
   If Err > 0 Then vKeys.Add Key, Key
   vData.Add v, Key
End Property

Public Property Let Item(Key As Variant, v As Variant)
   On Error Resume Next
   vData.Remove Key
   If Err > 0 Then vKeys.Add Key, Key
   vData.Add v, Key
End Property


Public Function Key(ByVal i As Long) As Variant
   On Error Resume Next
   Key = vKeys(i)
   If Err > 0 Then Key = Null
End Function

Public Function Remove(Key As Variant) As Boolean
   On Error GoTo ErrorHandle
   
   vData.Remove Key
   vKeys.Remove Key
   Remove = True
   Exit Function

ErrorHandle:
   Remove = False
End Function

'
' Clears the mapping
'
Public Sub Clear()
   Set vData = New Collection
   Set vKeys = New Collection
End Sub

'---
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "clsStack"
Attribute VB_Creatable = False
Attribute VB_Exposed = False
Option Explicit

' A simple Stack class.


' Private Data
Private vData As New Collection


Public Sub Clear()
   Set vData = New Collection
End Sub


'
' Returns the number of items in the stack.
'
Property Get Count() As Long
   Count = vData.Count
End Property



'
'  Returns the value of the next item on the
'  stack without removing the item from the
'  stack.
'
Public Function Peek() As Variant
   If vData.Count = 0 Then
      Peek = Null
   Else
      If VarType(vData.Item(1)) = vbObject Then
         Set Peek = vData(1)
      Else
         Peek = vData(1)
      End If
   End If
End Function

'
'  Removes and returns the next item from
'  the stack.
'
Public Function Pop() As Variant
   If vData.Count = 0 Then
      Pop = Null
   Else
      If VarType(vData(1)) = vbObject Then
         Set Pop = vData(1)
      Else
         Pop = vData(1)
      End If
      vData.Remove 1
   End If
End Function




'
'  Adds an item to the Stack
'
Public Sub Push(v As Variant)
   If vData.Count = 0 Then
      vData.Add v
   Else
     vData.Add v, , 1
   End If
End Sub
'---
Attribute VB_Name = "ini_sm"
'****************************************************
'* INI_sm.BAS                                     *
'****************************************************
Option Explicit
#If Win16 Then
        Declare Function WritePrivateProfileString Lib "Kernel" (ByVal AppName As String, ByVal KeyName As String, ByVal NewString As String, ByVal filename As String) As Integer
        Declare Function GetPrivateProfileString Lib "Kernel" Alias "GetPrivateProfilestring" (ByVal AppName As String, ByVal KeyName As Any, ByVal default As String, ByVal ReturnedString As String, ByVal MAXSIZE As Integer, ByVal filename As String) As Integer
#Else
' NOTE: The lpKeyName argument for GetProfileString, WriteProfileString,
'       GetPrivateProfileString, and WritePrivateProfileString can be either
'       a string or NULL.  This is why the argument is defined as "As Any".
'          For example, to pass a string specify   ByVal "wallpaper"
'          To pass NULL specify                    ByVal 0&
'       You can also pass NULL for the lpString argument for WriteProfileString
'       and WritePrivateProfileString
' Below it has been changed to a string due to the ability to use vbNullString
        Declare Function GetPrivateProfileString Lib "kernel32" Alias "GetPrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As String, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String) As Long
        Declare Function WritePrivateProfileString Lib "kernel32" Alias "WritePrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As String, ByVal lpString As Any, ByVal lpFileName As String) As Long
#End If

'*******************************************************
'* Procedure Name: sReadINI                            *
'*=====================================================*
'*Returns a string from an INI file. To use, call the  *
'*functions and pass it the Section, KeyName and INI   *
'*File Name, [sRet=sReadINI(Section,Key1,INIFile)].    *
'*val command.                                         *
'*******************************************************
Function ReadINI(Section, KeyName, filename As String) As String
        Dim sRet As String
        sRet = String(255, Chr(0))
        ReadINI = Left(sRet, GetPrivateProfileString(Section, ByVal KeyName, "", sRet, Len(sRet), filename))
End Function

'*******************************************************
'* Procedure Name: WriteINI                            *
'*=====================================================*
'*Writes a string to an INI file. To use, call the     *
'*function and pass it the sSection, sKeyName, the New *
'*String and the INI File Name,                        *
'*[Ret=WriteINI(Section,Key,String,INIFile)].          *
'*Returns a 1 if there were no errors and              *
'*a 0 if there were errors.                            *
'*******************************************************
Function writeini(sSection As String, sKeyName As String, sNewString As String, sFileName) As Integer
        Dim r
        r = WritePrivateProfileString(sSection, sKeyName, sNewString, sFileName)
End Function

'---
Attribute VB_Name = "ChangeCursor"
'////////////////////////////////////////////////////////////////////////'
'//***************************ChangeCursor*****************************//'
'//*************************By Drew Burchett***************************//'
'//                                                                    //'
'//   These declarations are all necessary for the subroutines to
'//   use animated cursors with Visual Basic.  The first section
'//   is constants used to identify system cursors to the SetSystemCursor
'//   Function.  The second section contains declares for the functions
'//   necessary to conclude this operation.
'//   Please see the Readme.txt for information on using these functions
'//   with your program.
'//   WARNING!  These functions are only for use with the Win32 operating
'//   system.  They will not work on Windows 3.1 or earlier.
'//
'///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////'

Const OCR_SIZENESW = 32643 ' The NESW Size Arrow
Const OCR_SIZENS = 32645 ' The NS Size Arrow
Const OCR_SIZENWSE = 32642 ' The NWSE Diagonal Size Arrow
Const OCR_SIZEWE = 32644 ' The WE Size Arrow
Const OCR_UP = 32516 'The Up Arrow
Const OCR_WAIT = 32514 ' The Wait cursor

Private Declare Function GetCursor Lib "user32" () As Long ' Gets the current system cursor
Private Declare Function LoadCursorFromFile Lib "user32" Alias "LoadCursorFromFileA" (ByVal lpFileName As String) As Long
' Loads a handle to a cursor from a valid cursor file
Private Declare Function CopyIcon Lib "user32" (ByVal hIcon As Long) As Long
' Makes a copy of a non-animated icon or cursor and returns a handle to the copy
Private Declare Function SetSystemCursor Lib "user32" (ByVal hcur As Long, ByVal id As Long) As Long
' Sets the current system cursor
Private Declare Function DeleteObject Lib "gdi32" (ByVal hObject As Long) As Long
' Deletes the system handle to a custom created object.

Dim HoldCursor As Long ' This will hold the system cursor until used to change back
Dim Cursor As Long, Cursor2 As Long ' The variables used to hold_
'your cursors

'/////////////////////////////////////////////////////////////////////////'
'// This routine is used to change to an animated cursor.               //'
'/////////////////////////////////////////////////////////////////////////'

Public Function AnimateCursor(Frm As Form, fName As String) As Long

Cursor = LoadCursorFromFile(fName) ' Loads a cursor from the file_
'specified by fName

Frm.MousePointer = 5 ' Change the mouse pointer of the form passed_
'by Frm.  Do not change this value without changing the corresponding_
'constant in the SetSystemCursor function.

Cursor2 = GetCursor ' Gets the handle to the current system cursor

HoldCursor = CopyIcon(Cursor2) ' Creates the copy of the current cursor_
'for restoration later.

AnimateCursor = SetSystemCursor(Cursor, OCR_SIZENESW) ' Change the current_
'cursor to the choosen animated cursor and returns a value indicating success_
'or failure.

End Function


'///////////////////////////////////////////////////////////////'
'// The subroutine to change your cursor back.                //'
'///////////////////////////////////////////////////////////////'

Public Function RestoreCursor(Frm As Form) As Long

RestoreCursor = SetSystemCursor(HoldCursor, OCR_SIZENESW) ' Restore the cursor_
'to the previous copy.

Frm.MousePointer = 0 ' Return the form mouse pointer to default

DeleteObject Cursor
DeleteObject Cursor2
DeleteObject HoldCursor
' Be sure to clean up after yourself and get rid of any unused cursor handles

End Function
'---
Attribute VB_Name = "CommDlgs"
Option Explicit

'//
'// Structures
'//

Private Type OPENFILENAME
    lStructSize As Long
    hwnd As Long
    hInstance As Long
    lpstrFilter As String
    lpstrCustomFilter As String
    nMaxCustFilter As Long
    nFilterIndex As Long
    lpstrFile As String
    nMaxFile As Long
    lpstrFileTitle As String
    nMaxFileTitle As Long
    lpstrInitialDir As String
    lpstrTitle As String
    Flags As Long
    nFileOffset As Integer
    nFileExtension As Integer
    lpstrDefExt As String
    lCustData As Long
    lpfnHook As Long
    lpTemplateName As String
End Type

Private Type COLORSTRUC
    lStructSize As Long
    hwnd As Long
    hInstance As Long
    rgbResult As Long
    lpCustColors As String
    Flags As Long
    lCustData As Long
    lpfnHook As Long
    lpTemplateName As String
End Type

Private Const LF_FACESIZE = 32

Private Type LOGFONT
    lfHeight As Long
    lfWidth As Long
    lfEscapement As Long
    lfOrientation As Long
    lfWeight As Long
    lfItalic As Byte
    lfUnderline As Byte
    lfStrikeOut As Byte
    lfCharSet As Byte
    lfOutPrecision As Byte
    lfClipPrecision As Byte
    lfQuality As Byte
    lfPitchAndFamily As Byte
    lfFaceName(LF_FACESIZE) As Byte
End Type

Private Type FONTSTRUC
    lStructSize As Long
    hwnd As Long
    hDC As Long
    lpLogFont As Long
    iPointSize As Long
    Flags As Long
    rgbColors As Long
    lCustData As Long
    lpfnHook As Long
    lpTemplateName As String
    hInstance As Long
    lpszStyle As String
    nFontType As Integer
    MISSING_ALIGNMENT As Integer
    nSizeMin As Long
    nSizeMax As Long
End Type

Private Type DEVMODE
    dmDeviceName As String * 32
    dmSpecVersion As Integer
    dmDriverVersion As Integer
    dmSize As Integer
    dmDriverExtra As Integer
    dmFields As Long
    dmOrientation As Integer
    dmPaperSize As Integer
    dmPaperLength As Integer
    dmPaperWidth As Integer
    dmScale As Integer
    dmCopies As Integer
    dmDefaultSource As Integer
    dmPrintQuality As Integer
    dmColor As Integer
    dmDuplex As Integer
    dmYResolution As Integer
    dmTTOption As Integer
    dmCollate As Integer
    dmFormName As String * 32
    dmUnusedPadding As Integer
    dmBitsPerPel As Integer
    dmPelsWidth As Long
    dmPelsHeight As Long
    dmDisplayFlags As Long
    dmDisplayFreq As Long
End Type

Private Type PRINTDLGSTRUC
    lStructSize As Long
    hwnd As Long
    hDevMode As Long
    hDevNames As Long
    hDC As Long
    Flags As Long
    nFromPage As Integer
    nToPage As Integer
    nMinPage As Integer
    nMaxPage As Integer
    nCopies As Integer
    hInstance As Long
    lCustData As Long
    lpfnPrintHook As Long
    lpfnSetupHook As Long
    lpPrintTemplateName As String
    lpSetupTemplateName As String
    hPrintTemplate As Long
    hSetupTemplate As Long
End Type

Public Type PRINTPROPS
    Cancel As Boolean
    Device As String
    Copies As Integer
    FromPage As Integer
    ToPage As Integer
    ToFile As Boolean
    Range As Integer
End Type

Private Type SHITEMID
    cb As Long
    abID As Byte
End Type

Private Type ITEMIDLIST
    mkid As SHITEMID
End Type

Private Type BROWSEINFO
    hOwner As Long
    pidlRoot As Long
    pszDisplayName As String
    lpszTitle As String
    ulFlags As Long
    lpfn As Long
    lParam As Long
    iImage As Long
End Type

'//
'// Win32s
'//

Private Declare Function GetOpenFileName Lib "comdlg32.dll" Alias "GetOpenFileNameA" (pOpenfilename As OPENFILENAME) As Long
Private Declare Function GetSaveFileName Lib "comdlg32.dll" Alias "GetSaveFileNameA" (pOpenfilename As OPENFILENAME) As Long
Private Declare Function PrintDlg Lib "comdlg32.dll" Alias "PrintDlgA" (pPrintdlg As PRINTDLGSTRUC) As Long
Private Declare Function ChooseColor Lib "comdlg32.dll" Alias "ChooseColorA" (pChoosecolor As COLORSTRUC) As Long
Private Declare Function ChooseFont Lib "comdlg32.dll" Alias "ChooseFontA" (pChoosefont As FONTSTRUC) As Long
Private Declare Function GlobalAlloc Lib "Kernel32" (ByVal wFlags As Long, ByVal dwBytes As Long) As Long
Private Declare Function GlobalFree Lib "Kernel32" (ByVal hMem As Long) As Long
Private Declare Function GlobalLock Lib "Kernel32" (ByVal hMem As Long) As Long
Private Declare Function GlobalUnlock Lib "Kernel32" (ByVal hMem As Long) As Long
Private Declare Sub CopyMemory Lib "Kernel32" Alias "RtlMoveMemory" (hpvDest As Any, hpvSource As Any, ByVal cbCopy As Long)
Private Declare Function ConnectToPrinterDlg Lib "winspool.drv" (ByVal hwnd As Long, ByVal Flags As Long) As Long
Private Declare Function SHGetPathFromIDList Lib "SHELL32.DLL" Alias "SHGetPathFromIDListA" (ByVal pidl As Long, ByVal pszPath As String) As Long
Private Declare Function SHGetSpecialFolderLocation Lib "SHELL32.DLL" (ByVal hwndOwner As Long, ByVal nFolder As Long, pidl As ITEMIDLIST) As Long
Private Declare Function SHBrowseForFolder Lib "SHELL32.DLL" Alias "SHBrowseForFolderA" (lpBrowseInfo As BROWSEINFO) As Long 'ITEMIDLIST
Private Declare Function WriteProfileString Lib "Kernel32" Alias "WriteProfileStringA" (ByVal lpszSection As String, ByVal lpszKeyName As String, ByVal lpszString As String) As Long
Private Declare Function GetProfileString Lib "Kernel32" Alias "GetProfileStringA" (ByVal lpAppName As String, ByVal lpKeyName As String, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long) As Long
Private Declare Function SendMessageByString Lib "user32" Alias "SendMessageA" (ByVal hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As String) As Long
Declare Function WinHelp Lib "user32" Alias "WinHelpA" (ByVal hwnd As Long, ByVal lpHelpFile As String, ByVal wCommand As Long, ByVal dwData As Long) As Long


'//
'// Constants (Public for Print Properties Structure)
'//

Public Const ppRangeAll = 0
Public Const ppRangePages = 1
Public Const ppRangeSelection = 2

'//
'// Constants (Public for Print Dialog Box)
'//

Public Const PD_NOSELECTION = &H4
Public Const PD_DISABLEPRINTTOFILE = &H80000
Public Const PD_PRINTTOFILE = &H20
Public Const PD_RETURNDC = &H100
Public Const PD_RETURNDEFAULT = &H400
Public Const PD_RETURNIC = &H200
Public Const PD_SELECTION = &H1
Public Const PD_SHOWHELP = &H800
Public Const PD_NOPAGENUMS = &H8
Public Const PD_PAGENUMS = &H2

'//
'// Constants (Public for WinHelp)
'//

Public Const HELP_COMMAND = &H102&
Public Const HELP_CONTENTS = &H3&
Public Const HELP_CONTEXT = &H1
Public Const HELP_CONTEXTPOPUP = &H8&
Public Const HELP_FORCEFILE = &H9&
Public Const HELP_HELPONHELP = &H4
Public Const HELP_INDEX = &H3
Public Const HELP_KEY = &H101
Public Const HELP_MULTIKEY = &H201&
Public Const HELP_PARTIALKEY = &H105&
Public Const HELP_QUIT = &H2
Public Const HELP_SETCONTENTS = &H5&
Public Const HELP_SETINDEX = &H5
Public Const HELP_SETWINPOS = &H203&


'//
'// Constants (Private)
'//

Private Const FW_BOLD = 700
Private Const GMEM_MOVEABLE = &H2
Private Const GMEM_ZEROINIT = &H40
Private Const GHND = (GMEM_MOVEABLE Or GMEM_ZEROINIT)
Private Const OFN_ALLOWMULTISELECT = &H200
Private Const OFN_CREATEPROMPT = &H2000
Private Const OFN_ENABLEHOOK = &H20
Private Const OFN_ENABLETEMPLATE = &H40
Private Const OFN_ENABLETEMPLATEHANDLE = &H80
Private Const OFN_EXPLORER = &H80000
Private Const OFN_EXTENSIONDIFFERENT = &H400
Private Const OFN_FILEMUSTEXIST = &H1000
Private Const OFN_HIDEREADONLY = &H4
Private Const OFN_LONGNAMES = &H200000
Private Const OFN_NOCHANGEDIR = &H8
Private Const OFN_NODEREFERENCELINKS = &H100000
Private Const OFN_NOLONGNAMES = &H40000
Private Const OFN_NONETWORKBUTTON = &H20000
Private Const OFN_NOREADONLYRETURN = &H8000
Private Const OFN_NOTESTFILECREATE = &H10000
Private Const OFN_NOVALIDATE = &H100
Private Const OFN_OVERWRITEPROMPT = &H2
Private Const OFN_PATHMUSTEXIST = &H800
Private Const OFN_READONLY = &H1
Private Const OFN_SHAREAWARE = &H4000
Private Const OFN_SHAREFALLTHROUGH = 2
Private Const OFN_SHARENOWARN = 1
Private Const OFN_SHAREWARN = 0
Private Const OFN_SHOWHELP = &H10
Private Const PD_ALLPAGES = &H0
Private Const PD_COLLATE = &H10
Private Const PD_ENABLEPRINTHOOK = &H1000
Private Const PD_ENABLEPRINTTEMPLATE = &H4000
Private Const PD_ENABLEPRINTTEMPLATEHANDLE = &H10000
Private Const PD_ENABLESETUPHOOK = &H2000
Private Const PD_ENABLESETUPTEMPLATE = &H8000
Private Const PD_ENABLESETUPTEMPLATEHANDLE = &H20000
Private Const PD_HIDEPRINTTOFILE = &H100000
Private Const PD_NONETWORKBUTTON = &H200000
Private Const PD_PRINTSETUP = &H40
Private Const PD_USEDEVMODECOPIES = &H40000
Private Const PD_USEDEVMODECOPIESANDCOLLATE = &H40000
Private Const PD_NOWARNING = &H80
Private Const CF_ANSIONLY = &H400&
Private Const CF_APPLY = &H200&
Private Const CF_BITMAP = 2
Private Const CF_PRINTERFONTS = &H2
Private Const CF_PRIVATEFIRST = &H200
Private Const CF_PRIVATELAST = &H2FF
Private Const CF_RIFF = 11
Private Const CF_SCALABLEONLY = &H20000
Private Const CF_SCREENFONTS = &H1
Private Const CF_BOTH = (CF_SCREENFONTS Or CF_PRINTERFONTS)
Private Const CF_DIB = 8
Private Const CF_DIF = 5
Private Const CF_DSPBITMAP = &H82
Private Const CF_DSPENHMETAFILE = &H8E
Private Const CF_DSPMETAFILEPICT = &H83
Private Const CF_DSPTEXT = &H81
Private Const CF_EFFECTS = &H100&
Private Const CF_ENABLEHOOK = &H8&
Private Const CF_ENABLETEMPLATE = &H10&
Private Const CF_ENABLETEMPLATEHANDLE = &H20&
Private Const CF_ENHMETAFILE = 14
Private Const CF_FIXEDPITCHONLY = &H4000&
Private Const CF_FORCEFONTEXIST = &H10000
Private Const CF_GDIOBJFIRST = &H300
Private Const CF_GDIOBJLAST = &H3FF
Private Const CF_INITTOLOGFONTSTRUCT = &H40&
Private Const CF_LIMITSIZE = &H2000&
Private Const CF_METAFILEPICT = 3
Private Const CF_NOFACESEL = &H80000
Private Const CF_NOVERTFONTS = &H1000000
Private Const CF_NOVECTORFONTS = &H800&
Private Const CF_NOOEMFONTS = CF_NOVECTORFONTS
Private Const CF_NOSCRIPTSEL = &H800000
Private Const CF_NOSIMULATIONS = &H1000&
Private Const CF_NOSIZESEL = &H200000
Private Const CF_NOSTYLESEL = &H100000
Private Const CF_OEMTEXT = 7
Private Const CF_OWNERDISPLAY = &H80
Private Const CF_PALETTE = 9
Private Const CF_PENDATA = 10
Private Const CF_SCRIPTSONLY = CF_ANSIONLY
Private Const CF_SELECTSCRIPT = &H400000
Private Const CF_SHOWHELP = &H4&
Private Const CF_SYLK = 4
Private Const CF_TEXT = 1
Private Const CF_TIFF = 6
Private Const CF_TTONLY = &H40000
Private Const CF_UNICODETEXT = 13
Private Const CF_USESTYLE = &H80&
Private Const CF_WAVE = 12
Private Const CF_WYSIWYG = &H8000
Private Const CFERR_CHOOSEFONTCODES = &H2000
Private Const CFERR_MAXLESSTHANMIN = &H2002
Private Const CFERR_NOFONTS = &H2001
Private Const CC_ANYCOLOR = &H100
Private Const CC_CHORD = 4
Private Const CC_CIRCLES = 1
Private Const CC_ELLIPSES = 8
Private Const CC_ENABLEHOOK = &H10
Private Const CC_ENABLETEMPLATE = &H20
Private Const CC_ENABLETEMPLATEHANDLE = &H40
Private Const CC_FULLOPEN = &H2
Private Const CC_INTERIORS = 128
Private Const CC_NONE = 0
Private Const CC_PIE = 2
Private Const CC_PREVENTFULLOPEN = &H4
Private Const CC_RGBINIT = &H1
Private Const CC_ROUNDRECT = 256 '
Private Const CC_SHOWHELP = &H8
Private Const CC_SOLIDCOLOR = &H80
Private Const CC_STYLED = 32
Private Const CC_WIDE = 16
Private Const CC_WIDESTYLED = 64
Private Const CCERR_CHOOSECOLORCODES = &H5000
Private Const LOGPIXELSY = 90
Private Const CCHDEVICENAME = 32
Private Const CCHFORMNAME = 32
Private Const SIMULATED_FONTTYPE = &H8000
Private Const PRINTER_FONTTYPE = &H4000
Private Const SCREEN_FONTTYPE = &H2000
Private Const BOLD_FONTTYPE = &H100
Private Const ITALIC_FONTTYPE = &H200
Private Const REGULAR_FONTTYPE = &H400
Private Const WM_CHOOSEFONT_GETLOGFONT = (&H400 + 1)
Private Const LBSELCHSTRING = "commdlg_LBSelChangedNotify"
Private Const SHAREVISTRING = "commdlg_ShareViolation"
Private Const FILEOKSTRING = "commdlg_FileNameOK"
Private Const COLOROKSTRING = "commdlg_ColorOK"
Private Const SETRGBSTRING = "commdlg_SetRGBColor"
Private Const FINDMSGSTRING = "commdlg_FindReplace"
Private Const HELPMSGSTRING = "commdlg_help"
Private Const CD_LBSELNOITEMS = -1
Private Const CD_LBSELCHANGE = 0
Private Const CD_LBSELSUB = 1
Private Const CD_LBSELADD = 2
Private Const NOERROR = 0
Private Const CSIDL_DESKTOP = &H0
Private Const CSIDL_PROGRAMS = &H2
Private Const CSIDL_CONTROLS = &H3
Private Const CSIDL_PRINTERS = &H4
Private Const CSIDL_PERSONAL = &H5
Private Const CSIDL_FAVORITES = &H6
Private Const CSIDL_STARTUP = &H7
Private Const CSIDL_RECENT = &H8
Private Const CSIDL_SENDTO = &H9
Private Const CSIDL_BITBUCKET = &HA
Private Const CSIDL_STARTMENU = &HB
Private Const CSIDL_DESKTOPDIRECTORY = &H10
Private Const CSIDL_DRIVES = &H11
Private Const CSIDL_NETWORK = &H12
Private Const CSIDL_NETHOOD = &H13
Private Const CSIDL_FONTS = &H14
Private Const CSIDL_TEMPLATES = &H15
Private Const BIF_RETURNONLYFSDIRS = &H1
Private Const BIF_DONTGOBELOWDOMAIN = &H2
Private Const BIF_STATUSTEXT = &H4
Private Const BIF_RETURNFSANCESTORS = &H8
Private Const BIF_BROWSEFORCOMPUTER = &H1000
Private Const BIF_BROWSEFORPRINTER = &H2000
Private Const HWND_BROADCAST = &HFFFF&
Private Const WM_WININICHANGE = &H1A

Public Sub SetDefaultPrinter(objPrn As Printer)

    Dim x As Long, szTmp As String
    
    szTmp = objPrn.DeviceName & "," & objPrn.DriverName & "," & objPrn.Port
    x = WriteProfileString("windows", "device", szTmp)
    x = SendMessageByString(HWND_BROADCAST, WM_WININICHANGE, 0&, "windows")
    
End Sub
Public Function GetDefaultPrinter() As String

    Dim x As Long, szTmp As String, dwBuf As Long

    dwBuf = 1024
    szTmp = Space(dwBuf + 1)
    x = GetProfileString("windows", "device", "", szTmp, dwBuf)
    GetDefaultPrinter = Trim(Left(szTmp, x))

End Function
Public Sub ResetDefaultPrinter(szBuf As String)

    Dim x As Long
    
    x = WriteProfileString("windows", "device", szBuf)
    x = SendMessageByString(HWND_BROADCAST, WM_WININICHANGE, 0&, "windows")

End Sub
Public Function BrowseFolder(f As Form, szDialogTitle As String) As String

    Dim x As Long, BI As BROWSEINFO, dwIList As Long, szPath As String, wPos As Integer
    
    BI.hOwner = f.hwnd
    BI.lpszTitle = szDialogTitle
    BI.ulFlags = BIF_RETURNONLYFSDIRS
    dwIList = SHBrowseForFolder(BI)
    szPath = Space$(512)
    x = SHGetPathFromIDList(ByVal dwIList, ByVal szPath)
    If x Then
        wPos = InStr(szPath, Chr(0))
        BrowseFolder = Left$(szPath, wPos - 1)
    Else
        BrowseFolder = ""
    End If

End Function
Public Function DialogConnectToPrinter(f As Form) As Boolean

    Dim x As Long
    DialogConnectToPrinter = True
    x = ConnectToPrinterDlg(f.hwnd, 0)
    
End Function
Private Function ByteToString(aBytes() As Byte) As String

    Dim dwBytePoint As Long, dwByteVal As Long, szOut As String
    
    dwBytePoint = LBound(aBytes)
    
    While dwBytePoint <= UBound(aBytes)
        
        dwByteVal = aBytes(dwBytePoint)
        
        If dwByteVal = 0 Then
            ByteToString = szOut
            Exit Function
        Else
            szOut = szOut & Chr$(dwByteVal)
        End If
        
        dwBytePoint = dwBytePoint + 1
    
    Wend
    
    ByteToString = szOut
    
End Function
Public Function DialogColor(f As Form, c As Control) As Boolean

    Dim x As Long, CS As COLORSTRUC, CustColor(16) As Long
    
    CS.lStructSize = Len(CS)
    CS.hwnd = f.hwnd
    CS.hInstance = App.hInstance
    CS.Flags = CC_SOLIDCOLOR
    CS.lpCustColors = String$(16 * 4, 0)
    x = ChooseColor(CS)
    If x = 0 Then
        DialogColor = False
    Else
        DialogColor = True
        c.ForeColor = CS.rgbResult
    End If
    
End Function


Public Function DialogFile(f As Form, wMode As Integer, szDialogTitle As String, szFilename As String, szFilter As String, szDefDir As String, szDefExt As String) As String

    Dim x As Long, OFN As OPENFILENAME, szFile As String, szFileTitle As String
    
    OFN.lStructSize = Len(OFN)
    OFN.hwnd = f.hwnd
    OFN.lpstrTitle = szDialogTitle
    OFN.lpstrFile = szFilename & String$(250 - Len(szFilename), 0)
    OFN.nMaxFile = 255
    OFN.lpstrFileTitle = String$(255, 0)
    OFN.nMaxFileTitle = 255
    OFN.lpstrFilter = szFilter
    OFN.nFilterIndex = 1
    OFN.lpstrInitialDir = szDefDir
    OFN.lpstrDefExt = szDefExt

    If wMode = 1 Then
        OFN.Flags = OFN_HIDEREADONLY Or OFN_PATHMUSTEXIST Or OFN_FILEMUSTEXIST
        x = GetOpenFileName(OFN)
    Else
        OFN.Flags = OFN_HIDEREADONLY Or OFN_OVERWRITEPROMPT Or OFN_PATHMUSTEXIST
        x = GetSaveFileName(OFN)
    End If
    
    If x <> 0 Then
    
        '// If InStr(OFN.lpstrFileTitle, Chr$(0)) > 0 Then
        '//     szFileTitle = Left$(OFN.lpstrFileTitle, InStr(OFN.lpstrFileTitle, Chr$(0)) - 1)
        '// End If
        If InStr(OFN.lpstrFile, Chr$(0)) > 0 Then
            szFile = Left$(OFN.lpstrFile, InStr(OFN.lpstrFile, Chr$(0)) - 1)
        End If
        '// OFN.nFileOffset is the number of characters from the beginning of the
        '// full path to the start of the file name
        '// OFN.nFileExtension is the number of characters from the beginning of the
        '// full path to the file's extention, including the (.)
        '// MsgBox "File Name is " & szFileTitle & Chr$(13) & Chr$(10) & "Full path and file is " & szFile, , "Open"
        
        '// DialogFile = szFile & "|" & szFileTitle
        DialogFile = szFile
    
    Else
    
        DialogFile = ""
        
    End If
    
End Function
Public Function DialogFont(f As Form, c As Control) As Boolean

    Dim LF As LOGFONT, FS As FONTSTRUC
    Dim lLogFontAddress As Long, lMemHandle As Long
    
    If c.FontBold Then LF.lfWeight = FW_BOLD
    If c.FontItalic = True Then LF.lfItalic = 1
    If c.FontUnderline = True Then LF.lfUnderline = 1
    If c.FontStrikethru = True Then LF.lfStrikeOut = 1
    
    FS.lStructSize = Len(FS)
    
    lMemHandle = GlobalAlloc(GHND, Len(LF))
    If lMemHandle = 0 Then
        DialogFont = False
        Exit Function
    End If
    
    lLogFontAddress = GlobalLock(lMemHandle)
    If lLogFontAddress = 0 Then
        DialogFont = False
        Exit Function
    End If
    
    CopyMemory ByVal lLogFontAddress, LF, Len(LF)
    FS.lpLogFont = lLogFontAddress
    FS.iPointSize = c.FontSize * 10
    FS.Flags = CF_SCREENFONTS Or CF_EFFECTS
    
    If ChooseFont(FS) = 1 Then
    
        CopyMemory LF, ByVal lLogFontAddress, Len(LF)
            
        If LF.lfWeight >= FW_BOLD Then
            c.FontBold = True
        Else
            c.FontBold = False
        End If
                        
        If LF.lfItalic = 1 Then
            c.FontItalic = True
        Else
            c.FontItalic = False
        End If
            
        If LF.lfUnderline = 1 Then
            c.FontUnderline = True
        Else
            c.FontUnderline = False
        End If
        
        If LF.lfStrikeOut = 1 Then
            c.FontStrikethru = True
        Else
            c.FontStrikethru = False
        End If
            
        c.FontName = ByteToString(LF.lfFaceName())
        c.FontSize = CLng(FS.iPointSize / 10)
        
        DialogFont = True
            
    Else
    
        DialogFont = False
            
    End If
    
End Function
Public Function DialogPrint(hwnd As Long, bPages As Boolean, Flags As Long) As PRINTPROPS

    Dim DM As DEVMODE, PD As PRINTDLGSTRUC
    Dim lpDM As Long, wNull As Integer, szDevName As String
    
    PD.lStructSize = Len(PD)
    PD.hwnd = hwnd
    PD.hDevMode = 0
    PD.hDevNames = 0
    PD.hDC = 0
    PD.Flags = Flags
    PD.nFromPage = 0
    PD.nToPage = 0
    PD.nMinPage = 0
    If bPages Then PD.nMaxPage = bPages - 1
    PD.nCopies = 0
    DialogPrint.Cancel = True
    
    If PrintDlg(PD) Then
    
        lpDM = GlobalLock(PD.hDevMode)
        CopyMemory DM, ByVal lpDM, Len(DM)
        lpDM = GlobalUnlock(PD.hDevMode)
        
        DialogPrint.Cancel = False
        
        DialogPrint.Device = Left$(DM.dmDeviceName, InStr(DM.dmDeviceName, Chr(0)) - 1)
        
        If PD.Flags And PD_PRINTTOFILE Then DialogPrint.ToFile = True Else DialogPrint.ToFile = False
        
        If PD.Flags And PD_PAGENUMS Then
            DialogPrint.Range = ppRangePages
            DialogPrint.FromPage = PD.nFromPage
            DialogPrint.ToPage = PD.nToPage
        ElseIf PD.Flags And PD_SELECTION Then
            DialogPrint.Range = ppRangeSelection
            DialogPrint.FromPage = 0
            DialogPrint.ToPage = 0
        Else
            DialogPrint.Range = ppRangeAll
            DialogPrint.FromPage = 0
            DialogPrint.ToPage = 0
        End If
        
        If PD.nCopies = 1 Then
            DialogPrint.Copies = DM.dmCopies
        End If
        
    End If
    
End Function
Public Function DialogPrintSetup(f As Form)

    Dim x As Long, PD As PRINTDLGSTRUC

    PD.lStructSize = Len(PD)
    PD.hwnd = f.hwnd
    PD.Flags = PD_PRINTSETUP
    x = PrintDlg(PD)
    
End Function
'---
Attribute VB_Name = "MODDiskInfo"
Option Explicit
Private Declare Function GetDiskFreeSpace Lib "kernel32" Alias "GetDiskFreeSpaceA" (ByVal lpRootPathName As String, lpSectorsPerCluster As Long, _
lpBytesPerSector As Long, lpNumberOfFreeClusters As Long, _
lpTotalNumberOfClusters As Long) As Long

Type DISKSPACEINFO
    RootPath As String * 3
    FreeBytes As Long
    TotalBytes As Long
    FreePcnt As Single
    UsedPcnt As Single
End Type
Global CurrentDisk As DISKSPACEINFO

Function GetDiskInfo(sRootPathName As String, sWhatInfo As String) As String
    'TO USE THIS FUNCTION:
    'INFO Options (Second Parameter):
    'FreeBytes, TotalBytes, FreePcnt, or UsedPcnt
    'Dim sMyInfo As String
    'sMyInfo = GetDiskInfo("c:\", "FreeBytes")
    Dim X As Long
    Dim lSectorsPerCluster As Long, lBytesPerSector As Long
    Dim lNumberOfFreeClusters As Long, lTotalNumberOfClusters As Long
    X = GetDiskFreeSpace(sRootPathName, lSectorsPerCluster, lBytesPerSector, lNumberOfFreeClusters, lTotalNumberOfClusters)
    GetDiskInfo = X
    If X Then
        CurrentDisk.RootPath = sRootPathName
        CurrentDisk.FreeBytes = lBytesPerSector * lSectorsPerCluster * lNumberOfFreeClusters
        CurrentDisk.TotalBytes = lBytesPerSector * lSectorsPerCluster * lTotalNumberOfClusters
        CurrentDisk.FreePcnt = (CurrentDisk.TotalBytes - CurrentDisk.FreeBytes) / CurrentDisk.TotalBytes
        CurrentDisk.UsedPcnt = CurrentDisk.FreeBytes / CurrentDisk.TotalBytes
    Else
        CurrentDisk.RootPath = ""
        CurrentDisk.FreeBytes = 0
        CurrentDisk.TotalBytes = 0
        CurrentDisk.FreePcnt = 0
        CurrentDisk.UsedPcnt = 0
    End If
    Select Case UCase(sWhatInfo)
        Case "ROOTPATH"
            GetDiskInfo = CurrentDisk.RootPath
        Case "FREEBYTES"
            GetDiskInfo = Format$(CurrentDisk.FreeBytes, "###,###,##0")
        Case "TOTALBYTES"
            GetDiskInfo = Format$(CurrentDisk.TotalBytes, "###,###,##0")
        Case "FREEPCNT"
            GetDiskInfo = Format$(CurrentDisk.FreePcnt, "Percent")
        Case "USEDPCNT"
            GetDiskInfo = Format$(CurrentDisk.UsedPcnt, "Percent")
    End Select
End Function
  

'---
Attribute VB_Name = "modGetRegistrySetting"
Option Explicit

'Registry Read permissions:
Private Const KEY_QUERY_VALUE = &H1&
Private Const KEY_ENUMERATE_SUB_KEYS = &H8&
Private Const KEY_NOTIFY = &H10&
Private Const READ_CONTROL = &H20000
Private Const STANDARD_RIGHTS_READ = READ_CONTROL
Private Const Key_Read = STANDARD_RIGHTS_READ Or KEY_QUERY_VALUE Or KEY_ENUMERATE_SUB_KEYS Or KEY_NOTIFY

Private Const REG_DWORD = 4&    ' 32-bit number

Private Declare Function RegCloseKey& Lib "advapi32.dll" (ByVal HKey&)
Private Declare Function RegOpenKeyExA& Lib "advapi32.dll" (ByVal HKey&, ByVal lpszSubKey$, dwOptions&, ByVal samDesired&, lpHKey&)
Private Declare Function RegQueryValueExA& Lib "advapi32.dll" (ByVal HKey&, ByVal lpszValueName$, lpdwRes&, lpdwType&, ByVal lpDataBuff$, nSize&)
Function GetRegistrySetting(lMainKey As Long, tSubKey As String, tValue As String) As String
    
    'lMainKey must be one of the Publicly declared HKEY constants
    '
    'Example call: GetRegistrySetting(HKEY_CURRENT_USER, "Control Panel\Desktop", "ScreenSaveUsePassword")
    '
    Dim lKeyType As Long            'returns the key type.  This function expects REG_SZ
    Dim lRetVal As Long             'returned by registry functions, should be 0&
    Dim lpHKey As Long              'return handle to opened key
    Dim lpcbData As Long            'length of data in returned string
    Dim tReturnedString As String   'returned string value
    Dim fTempDbl As Double
    
    'Open key
    lRetVal = RegOpenKeyExA(lMainKey, tSubKey, 0&, Key_Read, lpHKey)
    If lRetVal <> 0 Then
        GetRegistrySetting = ""
        Exit Function     'No key open, so leave
    End If
    
    'Set up a buffer for the data to be returned in
    lpcbData = 255
    tReturnedString = Space$(lpcbData)
    
    'Get the key
    lRetVal = RegQueryValueExA(lpHKey, tValue, ByVal 0&, lKeyType, tReturnedString, lpcbData)
    If lRetVal <> 0 Then
        GetRegistrySetting = ""   'Key still open, so finish up
    Else
        If lKeyType = REG_DWORD Then
            fTempDbl = Asc(Mid(tReturnedString, 1, 1)) + &H100& * Asc(Mid(tReturnedString, 2, 1)) + &H10000 * Asc(Mid(tReturnedString, 3, 1)) + &H1000000 * CDbl(Asc(Mid(tReturnedString, 4, 1)))
            tReturnedString = Format(fTempDbl, "000")
        End If
        GetRegistrySetting = Left(tReturnedString, lpcbData - 1)
    End If
    
    'Always close opened keys!
    lRetVal = RegCloseKey(lpHKey)
    
End Function
'---
Attribute VB_Name = "NoCloseMOD"
Option Explicit

Public Declare Function DeleteMenu Lib "user32" (ByVal hMenu As Long, ByVal nPosition As Long, ByVal wFlags As Long) As Long
Public Declare Function GetSystemMenu Lib "user32" (ByVal hwnd As Long, ByVal bRevert As Long) As Long

Public Const MF_BYPOSITION = &H400&

Public ReadyToClose As Boolean
Public Sub RemoveMenus(frm As Form, _
    remove_restore As Boolean, _
    remove_move As Boolean, _
    remove_size As Boolean, _
    remove_minimize As Boolean, _
    remove_maximize As Boolean, _
    remove_seperator As Boolean, _
    remove_close As Boolean)
Dim hMenu As Long
    
    ' Get the form's system menu handle.
    hMenu = GetSystemMenu(frm.hwnd, False)
    
    If remove_close Then DeleteMenu hMenu, 6, MF_BYPOSITION
    If remove_seperator Then DeleteMenu hMenu, 5, MF_BYPOSITION
    If remove_maximize Then DeleteMenu hMenu, 4, MF_BYPOSITION
    If remove_minimize Then DeleteMenu hMenu, 3, MF_BYPOSITION
    If remove_size Then DeleteMenu hMenu, 2, MF_BYPOSITION
    If remove_move Then DeleteMenu hMenu, 1, MF_BYPOSITION
    If remove_restore Then DeleteMenu hMenu, 0, MF_BYPOSITION
End Sub


'  Put This Code on the Forms.
'/////////////////////////////////////////////////////////
'Private Sub cmdClose_Click()
'    ReadyToClose = True
'End Sub

'Private Sub Form_Load()
'    RemoveMenus Me, False, False, False, False, False, True, True
'End Sub

' Cancel if ReadyToClose is false.
'Private Sub Form_QueryUnload(Cancel As Integer, UnloadMode As Integer)
'    Cancel = Not ReadyToClose
'End Sub

'/////////////////////////////////////////////////////////////////

'---
Option Explicit

Function Parse$ (ByVal sString As String, iReq As Integer, sDelim As String)
Dim sSt As String, iCnt As Integer, iPos As Integer

    If Len(sDelim) = 0 Then sDelim = ","
    sSt = sString & sDelim
    For iCnt = 1 To iReq
        iPos = InStr(sSt, sDelim)
        If iPos Then
            If iCnt = iReq Then     ' Requested string
                Parse$ = Left$(sSt, iPos - 1)
                Exit For
            End If
            If iPos = Len(sSt) Then ' No string left
                Parse$ = ""
                Exit For
            End If
            sSt = Mid$(sSt, iPos + Len(sDelim))
        Else
            Parse$ = sSt
            Exit For
        End If
    Next iCnt
End Function

'---
DEFINT A-Z
DECLARE FUNCTION ReadFileStructure% ()
DECLARE FUNCTION RightJust$ (Value$, FieldWidth%)
DECLARE FUNCTION ZeroJust$ (Number AS INTEGER)
DECLARE FUNCTION ReadDbfHdr% ()
DECLARE SUB DspDbfInfo ()
DECLARE SUB DspFileStructure ()
DECLARE SUB Pause ()
DECLARE SUB PrintDbfRecord (fv$(), RecNum%)
DECLARE SUB PrintReport ()
DECLARE SUB ReadDbfRecord (fv$())
 
'=================================================
'=   PROGRAM: PRINTDBF.BAS                       =
'=   PURPOSE: Print listings of dBASE III+/IV    =
'=            DBF files                          =
'=================================================
 
'-------------------------------------------------
' Initialize variables and create types          -
'-------------------------------------------------
 
CONST True = -1, False = 0
 
TYPE HeaderInfoType
   VersionNumber AS INTEGER
   LastUpdate    AS STRING * 8
   NumberRecords AS LONG
   HeaderLength  AS INTEGER
   RecordLength  AS INTEGER
   NumberFields  AS INTEGER
   FileSize      AS LONG
END TYPE
 
TYPE FieldInfoType
   FdName   AS STRING * 11
   FdType   AS STRING * 1
   FdLength AS INTEGER
   FdDec    AS INTEGER
END TYPE
 
DIM SHARED Hdr AS HeaderInfoType
DIM SHARED FileName$
 
FileName$ = "PLANETS.DBF"
 
'-------------------------------------------------
'  Main processing loop                          -
'-------------------------------------------------
 
   OPEN FileName$ FOR BINARY AS #1
   CLS
   ActionHdr = ReadDbfHdr
   SELECT CASE ActionHdr
      CASE 1
         BEEP
         PRINT "Not a dBASE III+ or IV file"
      CASE ELSE
         DspDbfInfo
         Pause
         DIM SHARED FLDS(Hdr.NumberFields)_
                         AS FieldInfoType
         ActionFile = ReadFileStructure
         SELECT CASE ActionFile
            CASE True
               CLS
               DspFileStructure
               Pause
               IF ActionHdr <> 2 THEN
                  CLS
                  PrintReport
                  Pause
               ELSE
                  CLS
                  PRINT "No records to print"
               END IF
            CASE False
               BEEP
               PRINT "Field information error"
            END SELECT
   END SELECT
   CLOSE #1
   END
 
SUB DspDbfInfo
  
'-------------------------------------------------
'Display dBASE file header information           -
'-------------------------------------------------
 
PRINT USING "dBASE Version         : #";_
                      Hdr.VersionNumber
PRINT "Database in use       : "; FileName$
PRINT USING "Number of data records: ########";_
                             Hdr.NumberRecords
PRINT "Date of last update   : "; Hdr.LastUpdate
PRINT USING "Header length         :     ####";_
                              Hdr.HeaderLength
PRINT USING "Record length         :     ####";_
                              Hdr.RecordLength
PRINT USING "Number of fields      :      ###";_
                              Hdr.NumberFields
PRINT USING "File size             : ########";_
                                  Hdr.FileSize
 
END SUB
 
SUB DspFileStructure
  
'-------------------------------------------------
'Purpose: Display the structure of the dBASE file-
'         Name, Field Type, Length and number    -
'         of decimals if a number                -
'-------------------------------------------------
 
FieldTitleS$ =_
    "Field  Field Name  Type        Width     Dec"
FieldString1$ = "  ###  \         \ "
FieldString2$ = "\         \   ###      ##"
 
PRINT : PRINT FieldTitleS$
 
FOR I = 1 TO Hdr.NumberFields
   PRINT USING FieldString1$; I; FLDS(I).FdName;
   SELECT CASE FLDS(I).FdType
      CASE "C": ty$ = "Character"
      CASE "L": ty$ = "Logical"
      CASE "N": ty$ = "Number"
      CASE "F": ty$ = "Floating Pt"
      CASE "D": ty$ = "Date"
      CASE "M": ty$ = "Memo"
      CASE ELSE: ty$ = "Unknown"
   END SELECT
   PRINT USING FieldString2$; ty$;_
     FLDS(I).FdLength; FLDS(I).FdDec
NEXT I
PRINT "   ** Total **"; TAB(33);
PRINT USING "####"; Hdr.RecordLength
 
END SUB
 
SUB Pause
  PRINT
  PRINT "Press any key to continue"
  WHILE INKEY$ = "": WEND
END SUB
 
SUB PrintDbfRecord (fv$(), RecNum)
  
'-------------------------------------------------
'Purpose: Print the record to the screen.  Left  -
'         justify character, date and logical    -
'         fields.  Right justify numeric fields  -
'         and ignore memo fields                 -
'Input  : Field values store in character array, -
'         current record number                  -
'-------------------------------------------------
 
' Print rec # & delete status
ColumnSpace = 4              'Room between columns
PRINT USING "####### !"; RecNum; fv$(0);
 
ColumnLocation = 10          'Set current location
FOR I = 1 TO Hdr.NumberFields
  IF FLDS(I).FdType <> "M" THEN
    PRINT TAB(ColumnLocation);
    IF FLDS(I).FdType = "N" OR   _
       FLDS(I).FdType = "F" THEN
      PRINT RightJust$(fv$(I), FLDS(I).FdLength);
    ELSE
      PRINT fv$(I);
    END IF
'       Set next print location
    ColumnLocation = ColumnLocation +_
       FLDS(I).FdLength + ColumnSpace
  END IF
NEXT I
PRINT
 
END SUB
 
SUB PrintReport
  
'-------------------------------------------------
'Purpose: Main printing routine                  -
'Calls  : ReadDbfRecord                          -
'         PrintDbfRecord                         -
'-------------------------------------------------
 
DIM FieldValues$(Hdr.NumberFields)
PRINT : PRINT
PRINT "Report on the "; FileName$; " file"
PRINT
FOR I = 1 TO Hdr.NumberRecords
   CALL ReadDbfRecord(FieldValues$())
   CALL PrintDbfRecord(FieldValues$(), I)
NEXT I
END SUB
 
FUNCTION ReadDbfHdr
 
'-------------------------------------------------
'Purpose: Read the dBASE file header information -
'         and store in the header record         -                           
'-------------------------------------------------
 
HdrStr$ = SPACE$(32)
GET #1, , HdrStr$               'Read dBASE Header
 
Hdr.VersionNumber = ASC(LEFT$(HdrStr$, 1)) AND (7)
 
UpdYY$ = ZeroJust$(ASC(MID$(HdrStr$, 2, 1)))
UpdMM$ = ZeroJust$(ASC(MID$(HdrStr$, 3, 1)))
UpdDD$ = ZeroJust$(ASC(MID$(HdrStr$, 4, 1)))
 
Hdr.LastUpdate = UpdMM$+"/"+UpdDD$+"/"+UpdYY$
 
Hdr.NumberRecords = CVL(MID$(HdrStr$, 5, 4))
Hdr.HeaderLength = CVI(MID$(HdrStr$, 9, 2))
Hdr.RecordLength = CVI(MID$(HdrStr$, 11, 2))
 
Hdr.NumberFields = (Hdr.HeaderLength - 33) / 32
Hdr.FileSize = Hdr.HeaderLength + Hdr.RecordLength_
                          * Hdr.NumberRecords + 1
 
IF Hdr.VersionNumber <> 3 THEN
   ReadDbfHdr = 1                'Not a dBASE file
   EXIT FUNCTION
END IF
 
IF Hdr.NumberRecords = 0 THEN
   ReadDbfHdr = 2                'No records
   EXIT FUNCTION
END IF
ReadDbfHdr = 0                   'No errors
END FUNCTION
 
SUB ReadDbfRecord (fv$())
  
'-------------------------------------------------
'Purpose: Read a dBASE record, format date and   -
'         logical fields for output              -
'Input  : Array of Field values                  -
'-------------------------------------------------
 
F$ = SPACE$(Hdr.RecordLength)
GET #1, , F$                      'Read the record
 
fv$(0) = LEFT$(F$, 1)    'Read deleted record mark
FPOS = 2
 
FOR I = 1 TO Hdr.NumberFields
 
   fv$(I) = MID$(F$, FPOS, FLDS(I).FdLength)
 
   SELECT CASE FLDS(I).FdType  'Adjust field types
      CASE "D"                 'Modify date format
         y$ = LEFT$(fv$(I), 4)
         M$ = MID$(fv$(I), 5, 2)
         d$ = RIGHT$(fv$(I), 2)
         fv$(I) = M$ + "/" + d$ + "/" + y$
      CASE "L"                 'Standardize T or F
          SELECT CASE UCASE$(fv$(I))
             CASE "Y", "T": fv$(I) = ".T."
             CASE "N", "F": fv$(I) = ".F."
             CASE ELSE: fv$(I) = ".?."
          END SELECT
      CASE ELSE
   END SELECT
   FPOS = FPOS + FLDS(I).FdLength 'Set next fld
'   PRINT fv$(I)
 
NEXT I
END SUB
 
FUNCTION ReadFileStructure
  
'-------------------------------------------------
'Purpose: Read the file structure store in the   -
'         dBASE file header.                     -
'-------------------------------------------------
 
FOR I = 1 TO Hdr.NumberFields
   Fld$ = SPACE$(32)
   GET #1, , Fld$           'Get field info string
   FLDS(I).FdName = LEFT$(Fld$, 11)
   FLDS(I).FdType = MID$(Fld$, 12, 1)
   FLDS(I).FdLength = ASC(MID$(Fld$, 17, 1))
   FLDS(I).FdDec = ASC(MID$(Fld$, 18, 1))
NEXT I
HeaderTerminator$ = INPUT$(1, #1)   'Last hdr byte
IF ASC(HeaderTerminator$) <> 13 THEN
   ReadFileStructure = False       'Bad Dbf header
END IF
ReadFileStructure = True
END FUNCTION
 
FUNCTION RightJust$ (Value$, FieldWidth)
  
'-------------------------------------------------
'Purpose: Right justify a string by padding it   -
'         with spaces on the left                -
'Input  : The character value to justify, the    -
'         width of the field to fit              -
'Output : A right justified string to print      -
'-------------------------------------------------
 
RightJust$ = RIGHT$(STRING$(FieldWidth, " ") +_
                          Value$, FieldWidth)
END FUNCTION
 
DEFSNG A-Z
FUNCTION ZeroJust$ (Number AS INTEGER)
  
'-------------------------------------------------
'Purpose: Add a leading zero to numbers less     -
'         than 10 so they take as much room as   -
'         numbers 10 and larger                  -
'Input  : The number to standardize              -
'Output : The adjusted number                    -
'-------------------------------------------------
 
N$ = STR$(Number)
LengthN = LEN(N$) - 1'Subtract 1 for leading space
N$ = RIGHT$("0" + RIGHT$(N$, LengthN), 2)
ZeroJust$ = N$
END FUNCTION


'---
Attribute VB_Name = "ModShorty"
Option Explicit
    'API calls for long filename support
    Declare Function LoadLibraryEx32W Lib "Kernel" (ByVal lpszFile As String, ByVal hFile As Long, ByVal dwFlags As Long) As Long
    Declare Function FreeLibrary32W Lib "Kernel" (ByVal hDllModule As Long) As Long
    Declare Function GetProcAddress32W Lib "Kernel" (ByVal hInstance As Long, ByVal FunctionName As String) As Long
    Declare Function FindFirstFileA Lib "Kernel" Alias "CallProc32W" (ByVal lpszFile As String, aFindFirst As WIN32_FIND_DATA, ByVal lpfnFunction As Long, ByVal fAddressConvert As Long, ByVal dwParams As Long) As Long
    Declare Function GetShortPathNameA Lib "Kernel" Alias "CallProc32W" (ByVal lpszLongFile As String, ByVal lpszShortFile As String, ByVal lBuffer As Long, ByVal lpfnFunction As Long, ByVal fAddressConvert As Long, ByVal dwParams As Long) As Long
    Declare Function lcreat Lib "Kernel" Alias "_lcreat" (ByVal lpPathName As String, ByVal iAttribute As Integer) As Integer

    Private hInstKernel As Long
    Private lpGetShortPathNameA As Long
    Private lpFindFirstFileA As Long

    'Define structures for api calls

    Type FILETIME
       dwLowDateTime As Long
       dwHighDateTime As Long
    End Type

    Const MAX_PATH = 260

    Type WIN32_FIND_DATA
       dwFileAttributes As Long
       ftCreationTime As FILETIME
       ftLastAccessTime As FILETIME
       ftLastWriteTime As FILETIME
       nFileSizeHigh As Long
       nFileSizeLow As Long
       dwReserved0 As Long
       dwReserved1 As Long
       cFileName As String * MAX_PATH
       cAlternate As String * 14
    End Type

Function GetShortFilename(Filename As String) As String
    '=========================================================
    'Returns the ShortFileName of a file if in a 32 bit system
    'Else returns Filename. You MUST check the validity of the
    'filename after this function. If this function fails, it
    'will return the long filename it was passed.
    '=========================================================
   On Error GoTo GetShortFilename_Error
   Dim sFF As WIN32_FIND_DATA
   Dim a As Long
   Dim szShortFilename As String * 256
   Dim p As Integer
   'Load Kernel32 DLL - if you are on a 16 bit system this is where it would fail
   hInstKernel = LoadLibraryEx32W("Kernel32.dll", 0&, 0&)
   'Addresses of the long filename functions
   lpGetShortPathNameA = GetProcAddress32W(hInstKernel, "GetShortPathNameA")
   'Get the short name for the directory
   a = GetShortPathNameA(Filename, szShortFilename, 256&, lpGetShortPathNameA, 6&, 3&)
   p = InStr(szShortFilename, Chr$(0))
   Filename = LCase$(Left$(szShortFilename, p - 1))
   GetShortFilename = Filename
   'Release the Kernel if necessary
   a = FreeLibrary32W(hInstKernel)
   Exit Function
GetShortFilename_Error:
   ' must be no Win32 support, so just return the passed in filename
   GetShortFilename = Filename
   Exit Function
End Function


'---
Attribute VB_Name = "VBAMAPI32"
Option Explicit

'***************************************************
'   MAPI Message holds information about a message
'***************************************************

Type MapiMessage
    Reserved As Long
    Subject As String
    NoteText As String
    MessageType As String
    DateReceived As String
    ConversationID As String
    Flags As Long
    RecipCount As Long
    FileCount As Long
End Type


'************************************************
'   MAPIRecip holds information about a message
'   originator or recipient
'************************************************

Type MapiRecip
    Reserved As Long
    RecipClass As Long
    Name As String
    Address As String
    EIDSize As Long
    EntryID As String
End Type


'******************************************************
'   MapiFile holds information about file attachments
'******************************************************

Type MapiFile
    Reserved As Long
    Flags As Long
    Position As Long
    PathName As String
    FileName As String
    FileType As Long ' <<< NOT String!
End Type


'***************************
'   FUNCTION Declarations
'***************************

Declare Function MAPILogon Lib "VBAMAP32.DLL" Alias "BMAPILogon" (ByVal UIParam&, ByVal User$, ByVal Password$, ByVal Flags&, ByVal Reserved&, Session&) As Long
Declare Function MAPILogoff Lib "VBAMAP32.DLL" Alias "BMAPILogoff" (ByVal Session&, ByVal UIParam&, ByVal Flags&, ByVal Reserved&) As Long
Declare Function MAPIDetails Lib "VBAMAP32.DLL" Alias "BMAPIDetails" (ByVal Session&, ByVal UIParam&, Recipient As MapiRecip, ByVal Flags&, ByVal Reserved&) As Long
Declare Function MAPIResolveName Lib "VBAMAP32.DLL" Alias "BMAPIResolveName" (ByVal Session&, ByVal UIParam&, ByVal UserName$, ByVal Flags&, ByVal Reserved&, Recipient As MapiRecip) As Long
Declare Function MAPISendDocuments Lib "VBAMAP32.DLL" Alias "BMAPISendDocuments" (ByVal UIParam&, ByVal DelimStr$, ByVal FilePaths$, ByVal FileNames$, ByVal Reserved&) As Long
Declare Function MAPIFindNext Lib "VBAMAP32.DLL" Alias "BMAPIFindNext" (ByVal Session&, ByVal UIParam&, ByVal MsgType$, ByVal SeedMsgID$, ByVal Flag&, ByVal Reserved&, MsgID$) As Long
Declare Function MAPIDeleteMail Lib "VBAMAP32.DLL" Alias "BMAPIDeleteMail" (ByVal Session&, ByVal UIParam&, ByVal MsgID$, ByVal Flags&, ByVal Reserved&) As Long
Declare Function MAPIAddress Lib "VBAMAP32.DLL" Alias "BMAPIAddress" (ByVal Session&, ByVal UIParam&, ByVal Caption$, ByVal EditFields&, ByVal Label$, RecipCount&, Recipients() As MapiRecip, ByVal Flags&, ByVal Reserved&) As Long
Declare Function MAPISaveMail Lib "VBAMAP32.DLL" Alias "BMAPISaveMail" (ByVal Session&, ByVal UIParam&, Message As MapiMessage, Recipient As MapiRecip, File As MapiFile, ByVal Reserved&, MsgID$) As Long
Declare Function MAPISendMail Lib "VBAMAP32.DLL" Alias "BMAPISendMail" (ByVal Session&, ByVal UIParam&, Message As MapiMessage, Recipient As MapiRecip, File As MapiFile, ByVal Flags&, ByVal Reserved&) As Long
Declare Function MAPIReadMail Lib "VBAMAP32.DLL" Alias "BMAPIReadMail" (ByVal Session&, ByVal UIParam&, ByVal MsgID$, ByVal Flags&, ByVal Reserved&, Message As MapiMessage, Originator As MapiRecip, recips() As MapiRecip, files() As MapiFile) As Long


'**************************
'   CONSTANT Declarations
'**************************
'

Global Const SUCCESS_SUCCESS = 0
Global Const MAPI_USER_ABORT = 1
Global Const MAPI_E_FAILURE = 2
Global Const MAPI_E_LOGIN_FAILURE = 3
Global Const MAPI_E_DISK_FULL = 4
Global Const MAPI_E_INSUFFICIENT_MEMORY = 5
Global Const MAPI_E_BLK_TOO_SMALL = 6
Global Const MAPI_E_TOO_MANY_SESSIONS = 8
Global Const MAPI_E_TOO_MANY_FILES = 9
Global Const MAPI_E_TOO_MANY_RECIPIENTS = 10
Global Const MAPI_E_ATTACHMENT_NOT_FOUND = 11
Global Const MAPI_E_ATTACHMENT_OPEN_FAILURE = 12
Global Const MAPI_E_ATTACHMENT_WRITE_FAILURE = 13
Global Const MAPI_E_UNKNOWN_RECIPIENT = 14
Global Const MAPI_E_BAD_RECIPTYPE = 15
Global Const MAPI_E_NO_MESSAGES = 16
Global Const MAPI_E_INVALID_MESSAGE = 17
Global Const MAPI_E_TEXT_TOO_LARGE = 18
Global Const MAPI_E_INVALID_SESSION = 19
Global Const MAPI_E_TYPE_NOT_SUPPORTED = 20
Global Const MAPI_E_AMBIGUOUS_RECIPIENT = 21
Global Const MAPI_E_MESSAGE_IN_USE = 22
Global Const MAPI_E_NETWORK_FAILURE = 23
Global Const MAPI_E_INVALID_EDITFIELDS = 24
Global Const MAPI_E_INVALID_RECIPS = 25
Global Const MAPI_E_NOT_SUPPORTED = 26

Global Const MAPI_E_NO_LIBRARY = 999
Global Const MAPI_E_INVALID_PARAMETER = 998

Global Const MAPI_ORIG = 0
Global Const MAPI_TO = 1
Global Const MAPI_CC = 2
Global Const MAPI_BCC = 3

Global Const MAPI_UNREAD = 1
Global Const MAPI_RECEIPT_REQUESTED = 2
Global Const MAPI_SENT = 4


'***********************
'   FLAG Declarations
'***********************

Global Const MAPI_LOGON_UI = &H1
Global Const MAPI_NEW_SESSION = &H2
Global Const MAPI_DIALOG = &H8
Global Const MAPI_UNREAD_ONLY = &H20
Global Const MAPI_ENVELOPE_ONLY = &H40
Global Const MAPI_PEEK = &H80
Global Const MAPI_GUARANTEE_FIFO = &H100
Global Const MAPI_BODY_AS_FILE = &H200
Global Const MAPI_AB_NOMODIFY = &H400
Global Const MAPI_SUPPRESS_ATTACH = &H800
Global Const MAPI_FORCE_DOWNLOAD = &H1000

Global Const MAPI_OLE = &H1
Global Const MAPI_OLE_STATIC = &H2


'---
'Windows API Constants

'This is a declaration of type structure and global var.
'for the printer orientation function

Type Orientstructure
    Orientation As Long
    Pad As String * 16
End Type

Global PrtStruct As Orientstructure

'These are the api declarations you need
Declare Function WritePrivateProfileSTring% Lib "Kernel" (ByVal lpAppName$, ByVal lpKeyname$, ByVal lpString$, ByVal lpFileName$)
Declare Function GetPrivateProfileString% Lib "Kernel" (ByVal lpAppName$, ByVal lpKeyname As Any, ByVal lpDefault$, ByVal lpReturnedString$, ByVal nSize%, ByVal lpFileName$)
Declare Function GetWindowsDirectory Lib "Kernel" (ByVal lpBuffer As String, ByVal nSize As Integer) As Integer
Declare Function GetProfileString Lib "Kernel" (ByVal lpAppName$, ByVal lpKeyname As Any, ByVal lpDefault$, ByVal lpReturned$, ByVal Size%)
Declare Function SndPlaySound Lib "MMSYSTEM" (ByVal File$, ByVal PlayType%) As Integer
Declare Function PrtOrient% Lib "GDI" Alias "Escape" (ByVal hDC%, ByVal nEsc%, ByVal nLen%, lpData As Orientstructure, lpOut As Any)

'Examples for the three functions
'==================================================================================
'WriteProfile : Writes/Changes Keyword to ini file
'               Remark : ini file is created auto. when it is not already  there

    'WriteProfile "PC.INI","Program","Directory","C:\DOS"
'==================================================================================
'ReadProfile  : Reads Keyword from ini file
    
    ' result$ = ReadProfile("PC.INI","Program","Directory")
'==================================================================================
'Centerform   : Centers form on screen

    ' Centerform Form1
'==================================================================================
'PlaySound    : Plays wave file
    
    ' PlaySound "C:\BB.WAV"
'==================================================================================

'==================================================================================

'==================================================================================

Sub Centerform (CurForm As Form)
    
    ' Sub/Function Name       : Centerform
    ' Purpose                 : Centers form on screen
    ' Parameters              : Form Object
    ' Created by              : Paul Treffers
    ' Date Created            : 11/05/94
    
    
    Dim xPos As Integer
    Dim yPos As Integer
    Dim wForm As Integer
    Dim hForm As Integer
    Dim nTop As Integer
    Dim nLeft As Integer
    
    xPos = Screen.Width
    yPos = Screen.Height
    wForm = CurForm.Width
    hForm = CurForm.Height
    nTop = (yPos - hForm) / 2
    nLeft = (xPos - wForm) / 2
    CurForm.Top = nTop
    CurForm.Left = nLeft
End Sub

Function GetPrinterOrientation () As Integer
    
    ' Sub/Function Name       : GetPrinterOrientation
    ' Purpose                 : Returns Orientation of Default Printer
    ' Parameters              : None
    ' ReturnValue             : 1 = Printer Orientation is Portrait
    '                           2 = Printer Orientation is Landscape
    ' Created by              : Paul Treffers
    ' Date Created            : 11/08/94
    
    Dim Orientation As Integer
    PrtStruct.Orientation = 0
    Orientation = PrtOrient(Printer.hDC, 30, Len(PrtStruct), PrtStruct, 0&)
    GetPrinterOrientation = Orientation
End Function

Sub LandScape ()
    
    ' Sub/Function Name       : Landscape
    ' Purpose                 : Sets default printer to landscape
    ' Parameters              : None
    ' Created by              : Paul Treffers
    ' Date Created            : 11/08/94
    Dim ResValue As Integer
    PrtStruct.Orientation = 2
    ResValue = PrtOrient%(Printer.hDC, 30, Len(PrtStruct), PrtStruct, 0&)
    Printer.EndDoc
End Sub

Sub pLAYSOUND (SoundFile As String)
    
    ' Sub/Function Name       : PlaySound
    ' Purpose                 : Play Wave File
    ' Parameters              : Wave file
    ' Created by              : Paul Treffers
    ' Date Created            : 11/07/94
  
  Dim PlayType As Integer
  If SoundFile > "" Then
    On Error Resume Next
    PlayType = 1
    PlayType = SndPlaySound(SoundFile, PlayType)
    On Error GoTo 0
  Else
    Beep
  End If
End Sub

Sub Portrait ()
    
    ' Sub/Function Name       : Portrait
    ' Purpose                 : Sets default printer to portrait
    ' Parameters              : None
    ' Created by              : Paul Treffers
    ' Date Created            : 11/08/94
    
    Dim ResValue As Integer

    PrtStruct.Orientation = 1
    ResValue = PrtOrient%(Printer.hDC, 30, Len(PrtStruct), PrtStruct, 0&)
    Printer.EndDoc

End Sub

Function ReadProfile (IniFile As String, Section As String, Keyword As String) As String
    
    ' Sub/Function Name       : ReadProfile
    ' Purpose                 : Reads keyword from ini file
    ' Parameters              : IniFile -> Ini file to read
    '                           Section  -> Section name in ini file
    '                           Keyword   -> Keyword in section to read
    ' Return Value            : requested keyword

    ' Created by              : Paul Treffers
    ' Date Created            : 11/05/94

    Dim EntrySpecial As Integer
    Dim WinDir As String
    Dim Res As Integer
    Dim File As String
    Dim ReturnString As String
    Dim NullPos As Integer
    
    If Keyword = "0" Then
        EntrySpecial = 0
    End If
    
    'Here you get the Windows directory where the ini
    'file is stored in. If you do not want to have
    'the Windows directory as default, remove GetWindowsDirectory Function
    'and specify your own directory as your ini file directory
    
    WinDir = Space$(20)
    Res = GetWindowsDirectory(WinDir, 20)
    
    'Check here if Windir has a Null String and
    'add IniFile to var. File
    File = Left$(WinDir, InStr(1, WinDir$, Chr$(0)) - 1)
    File = File & "\" & IniFile
    
    ReturnString = Space$(200)
    
    If Keyword <> "0" Then
        'Get keyword from section and check if there is a Null
        'value in it. Just to be sure
        Res = GetPrivateProfileString%(Section, Keyword, "", ReturnString, 200, File)
        NullPos = InStr(1, ReturnString, Chr$(0))
        If NullPos > 0 Then
            ReadProfile = RTrim$(Left$(ReturnString, NullPos - 1))
        Else
            ReadProfile = RTrim$(ReturnString)
        End If
    Else
        Res = GetPrivateProfileString%(Section, 0&, "", ReturnString, 200, File)
        ReadProfile = ReturnString
    End If
End Function

Sub WriteProfile (IniFile As String, Section As String, Keyword As String, Entry As String)
    
    ' Sub/Function Name       : WriteProfile
    ' Purpose                 : Writes keyword to ini file
    ' Parameters              : IniFile  -> Ini file to read
    '                           Section  -> Section name in ini file
    '                           Keyword  -> Keyword in section to read
    '                           Entry    -> Keyword entry to save
    ' Created by              : Paul Treffers
    ' Date Created            : 11/05/94

    Dim WinDir As String
    Dim Res As Integer
    Dim File As String
    WinDir = Space$(20)
    Res = GetWindowsDirectory(WinDir, 20)
    File$ = Left$(WinDir, InStr(1, WinDir, Chr$(0)) - 1)
    File$ = File$ & "\" & IniFile
    Res% = WritePrivateProfileSTring(Section, Keyword, Entry, File)
End Sub

'---
Option Explicit

Declare Sub SetWindowPos Lib "User" (ByVal hWnd As Integer, ByVal hWndInsertAfter As Integer, ByVal X As Integer, ByVal Y As Integer, ByVal cx As Integer, ByVal cy As Integer, ByVal wFlags As Integer)
   Global Const SWP_NOACTIVATE = &H10
   Global Const SWP_SHOWWINDOW = &H40
   Global Const HWND_TOPMOST = -1
   Global Const HWND_NOTOPMOST = -2

Sub SetOnTop (Pos%, aForm As Form)

' Description
'     Makes aForm the top-most window
'
' Parameters
'     Name                    Type     Value
'     -------------------------------------------------------------------------
'     Pos                     Integer  HWND_TOPMOST   if form is to be on top
'                                      HWND_NOTOPMOST if form is be not on top
'     aForm                   Form     The form to set (not) on top
'
' Returns
'     Nothing
'
' Last modified by Jens Balchen 10.03.1996

   SetWindowPos aForm.hWnd, Pos%, 0, 0, 0, 0, SWP_NOACTIVATE Or SWP_SHOWWINDOW

End Sub

'---
Attribute VB_Name = "MaLordsBas"
'MaLord's Bas created only by:MaLord
'I will try to update my bas file just about every 2 weeks or so.
'If you want the newer version please visit my web page
' at http://come.to/malord
'E-Mail me at malord@hotmail.com if you have any questions or comments

'You can modify this bas file in any way I really don't care.
'If you do though, make sure you change the name and change
' who made it.

'If you find any bugs or problems with this file please e-mail me
' at malord@hotmail.com.
Option Explicit

'FormDrag variables
Dim lastx, lasty, mousey, mousex
Global DontMove As Boolean

'Types
Type POINTAPI
        X As Long
        Y As Long
End Type

Type RECT
        Left As Long
        Top As Long
        Right As Long
        Bottom As Long
End Type

Type WINDOWPLACEMENT
        Length As Long
        Flags As Long
        showCmd As Long
        ptMinPosition As POINTAPI
        ptMaxPosition As POINTAPI
        rcNormalPosition As RECT
End Type

'Menu Functions
Declare Function AppendMenu Lib "user32" Alias "AppendMenuA" (ByVal hMenu As Long, ByVal wFlags As Long, ByVal wIDNewItem As Long, ByVal lpNewItem As String) As Long
Declare Function CreateMenu Lib "user32" () As Long
Declare Function CreatePopupMenu Lib "user32" () As Long
Declare Sub DrawMenuBar Lib "user32" (ByVal hWnd As Integer)
Declare Function DeleteMenu Lib "user32" (ByVal hMenu As Long, ByVal nPosition As Long, ByVal wFlags As Long)
Declare Function DestroyMenu Lib "user32" (ByVal hMenu As Long)
Declare Function GetMenu Lib "user32" (ByVal hWnd As Long) As Long
Declare Function GetSubMenu Lib "user32" (ByVal hMenu&, ByVal nPos&)
Declare Function TrackPopupMenu Lib "user32" (ByVal hMenu&, ByVal wFlags&, ByVal X&, ByVal Y&, ByVal nReserved&, ByVal hWnd&, ByVal lpReserved&)
Declare Function InsertMenuBystring Lib "user32" Alias "InsertMenuA" (ByVal hMenu As Long, ByVal nPosition As Long, ByVal wFlags As Long, ByVal wIDNewItem As Long, ByVal lpNewItem$)
Declare Function InsertMenuBynum Lib "user32" Alias "InsertMenuA" (ByVal hMenu As Long, ByVal nPosition As Long, ByVal wFlags As Long, ByVal wIDNewItem As Long, ByVal lpNewItem&)
Declare Function AppendMenuBynum Lib "user32" Alias "AppendMenuA" (ByVal hMenu As Long, ByVal wFlags As Long, ByVal wIDNewItem As Long, ByVal lpNewItem&)
Declare Function AppendMenuByString Lib "user32" Alias "AppendMenuA" (ByVal hMenu As Long, ByVal wFlags As Long, ByVal wIDNewItem As Long, ByVal lpNewItem$)
Declare Function GetMenuItemID Lib "user32" (ByVal hMenu As Long, ByVal nPos As Long) As Long
Declare Function GetMenuItemCount Lib "user32" (ByVal hMenu As Long) As Long
Declare Function GetMenuString Lib "user32" Alias "GetMenuStringA" (ByVal hMenu As Long, ByVal wIDItem As Long, ByVal lpString As String, ByVal nMaxCount As Long, ByVal wFlag As Long) As Long
Declare Function GetSystemMenu Lib "user32" (ByVal hWnd As Long, ByVal bRevert As Long) As Long
Declare Function RemoveMenu Lib "user32" (ByVal hMenu As Long, ByVal nPosition As Long, ByVal wFlags As Long) As Long

'Window Functions
Declare Function BringWindowToTop Lib "user32" (ByVal hWnd As Long) As Long
Declare Function MoveWindow Lib "user32" (ByVal hWnd As Long, ByVal X As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal bRepaint As Long) As Long
Declare Function SetParent Lib "user32" (ByVal hWndChild As Long, ByVal hWndNewParent As Long) As Long
Declare Function GetParent Lib "user32" (ByVal hWnd As Long) As Long
Declare Function FindWindow Lib "user32" Alias "FindWindowA" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long
Declare Function FindWindowEx Lib "user32" Alias "FindWindowExA" (ByVal hWnd1 As Long, ByVal hWnd2 As Long, ByVal lpsz1 As String, ByVal lpsz2 As String) As Long
Declare Function ShowWindow Lib "user32" (ByVal hWnd As Long, ByVal nCmdShow As Long) As Long
Declare Function GetTopWindow Lib "user32" (ByVal hWnd As Long) As Long
Declare Function SetWindowPos Lib "user32" (ByVal hWnd As Long, ByVal hWndInsertAfter As Long, ByVal X As Long, ByVal Y As Long, ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long) As Long
Declare Function GetWindowTextLength Lib "user32" Alias "GetWindowTextLengthA" (ByVal hWnd As Long) As Long
Declare Function GetWindowText Lib "user32" Alias "GetWindowTextA" (ByVal hWnd As Long, ByVal lpString As String, ByVal cch As Long) As Long
Declare Function GetWindow Lib "user32" (ByVal hWnd As Integer, ByVal wCmd As Integer) As Integer
Declare Function EnableWindow Lib "user32" (ByVal hWnd As Long, ByVal cmd As Long) As Long
Declare Function FlashWindow Lib "user32" (ByVal hWnd As Long, ByVal bInvert As Long) As Long
Declare Function IsWindowVisible Lib "user32" (ByVal hWnd As Long) As Long
Declare Function ReleaseCapture Lib "user32" () As Long
Declare Function WindowFromPoint Lib "user32" (ByVal xPoint As Long, ByVal yPoint As Long) As Long
Declare Function GetWindowPlacement Lib "user32" (ByVal hWnd As Long, lpwndpl As WINDOWPLACEMENT) As Long
Declare Function SetWindowPlacement Lib "user32" (ByVal hWnd As Long, lpwndpl As WINDOWPLACEMENT) As Long
Declare Function GetWindowWord Lib "user32" (ByVal hWnd As Long, ByVal nIndex As Long) As Integer
Declare Function SetWindowWord Lib "user32" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal wNewWord As Long) As Long
Declare Function GetWindowLong Lib "user32" Alias "GetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Declare Function SetWindowLong Lib "user32" Alias "SetWindowLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Declare Function GetClassWord Lib "user32" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Declare Function SetClassWord Lib "user32" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal wNewWord As Long) As Long
Declare Function GetClassLong Lib "user32" Alias "GetClassLongA" (ByVal hWnd As Long, ByVal nIndex As Long) As Long
Declare Function SetClassLong Lib "user32" Alias "SetClassLongA" (ByVal hWnd As Long, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
Declare Function GetDesktopWindow Lib "user32" () As Long

'GDI, Region, and RECT Functions
Declare Function GetDC Lib "user32" (ByVal hWnd As Long) As Long
Declare Function DeleteObject Lib "gdi32" (ByVal hObject As Long) As Long
Declare Function CreatePen Lib "gdi32" (ByVal nPenStyle As Long, ByVal nWidth As Long, ByVal crColor As Long) As Long
Declare Function CreateSolidBrush Lib "gdi32" (ByVal crColor As Long) As Long
Declare Function GetSysColor Lib "user32" (ByVal nIndex As Long) As Long
Declare Function GetSystemMetrics Lib "user32" (ByVal nIndex As Long) As Long
Declare Function GetWindowDC Lib "user32" (ByVal hWnd As Long) As Long
Declare Function GetWindowRect Lib "user32" (ByVal hWnd As Long, lpRect As RECT) As Long
Declare Function Rectangle Lib "gdi32" (ByVal hdc As Long, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Declare Function ReleaseDC Lib "user32" (ByVal hWnd As Long, ByVal hdc As Long) As Long
Declare Function SelectObject Lib "gdi32" (ByVal hdc As Long, ByVal hObject As Long) As Long
Declare Function SetBkColor Lib "gdi32" (ByVal hdc As Long, ByVal crColor As Long) As Long
Declare Function SetTextColor Lib "gdi32" (ByVal hdc As Long, ByVal crColor As Long) As Long
Declare Function SetBkMode Lib "gdi32" (ByVal hdc As Long, ByVal mode As Long) As Long
Declare Function DrawText Lib "user32" Alias "DrawTextA" (ByVal hdc As Long, ByVal lpStr As String, ByVal nCount As Long, lpRect As RECT, ByVal wFormat As Long) As Long
Declare Function FrameRgn Lib "gdi32" (ByVal hdc As Long, ByVal hRgn As Long, ByVal hBrush As Long, ByVal nWidth As Long, ByVal nHeight As Long) As Long
Declare Function InvertRgn Lib "gdi32" (ByVal hdc As Long, ByVal hRgn As Long) As Long
Declare Function CreateRectRgn Lib "gdi32" (ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Declare Function CombineRgn Lib "gdi32" (ByVal hDestRgn As Long, ByVal hSrcRgn1 As Long, ByVal hSrcRgn2 As Long, ByVal nCombineMode As Long) As Long
Declare Function SetWindowRgn Lib "user32" (ByVal hWnd As Long, ByVal hRgn As Long, ByVal bRedraw As Long) As Long
Declare Function FillRect Lib "user32" (ByVal hdc As Long, lpRect As RECT, ByVal hBrush As Long) As Long
Declare Function FrameRect Lib "user32" (ByVal hdc As Long, lpRect As RECT, ByVal hBrush As Long) As Long
Declare Function InvertRect Lib "user32" (ByVal hdc As Long, lpRect As RECT) As Long
Declare Function SetRect Lib "user32" (lpRect As RECT, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long) As Long
Declare Function SetRectEmpty Lib "user32" (lpRect As RECT) As Long
Declare Function CopyRect Lib "user32" (lpDestRect As RECT, lpSourceRect As RECT) As Long
Declare Function InflateRect Lib "user32" (lpRect As RECT, ByVal X As Long, ByVal Y As Long) As Long
Declare Function IntersectRect Lib "user32" (lpDestRect As RECT, lpSrc1Rect As RECT, lpSrc2Rect As RECT) As Long
Declare Function UnionRect Lib "user32" (lpDestRect As RECT, lpSrc1Rect As RECT, lpSrc2Rect As RECT) As Long
Declare Function SubtractRect Lib "user32" (lprcDst As RECT, lprcSrc1 As RECT, lprcSrc2 As RECT) As Long
Declare Function OffsetRect Lib "user32" (lpRect As RECT, ByVal X As Long, ByVal Y As Long) As Long
Declare Function IsRectEmpty Lib "user32" (lpRect As RECT) As Long
Declare Function EqualRect Lib "user32" (lpRect1 As RECT, lpRect2 As RECT) As Long
Declare Function PtInRect Lib "user32" (lpRect As RECT, pt As POINTAPI) As Long

'Mouse Functions
Declare Function SwapMouseButton Lib "user32" (ByVal bSwap As Long) As Long
Declare Function GetDoubleClickTime Lib "user32" () As Long
Declare Function SetDoubleClickTime Lib "user32" (ByVal wCount As Long) As Long
Declare Function ShowCursor Lib "user32" (ByVal bShow As Long) As Long
Declare Function SetCursorPos Lib "user32" (ByVal X As Long, ByVal Y As Long) As Long
Declare Function SetCursor Lib "user32" (ByVal hCursor As Long) As Long
Declare Function GetCursorPos Lib "user32" (lpPoint As POINTAPI) As Long
Declare Function ClipCursor Lib "user32" (lpRect As Any) As Long
Declare Function GetClipCursor Lib "user32" (lprc As RECT) As Long

'Other Functions
Declare Function SendMessageByNum& Lib "user32" Alias "SendMessageA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As Long)
Declare Function SendMessageByString Lib "user32" Alias "SendMessageA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, ByVal lParam As String) As Long
Declare Function SendMessage Lib "user32" Alias "SendMessageA" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Integer, ByVal lParam As Long) As Long

Declare Function WritePrivateProfileString& Lib "kernel32" Alias "WritePrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As String, ByVal lpString As Any, ByVal lpFileName As String)
Declare Function GetPrivateProfileString& Lib "kernel32" Alias "GetPrivateProfileStringA" (ByVal lpApplicationName As String, ByVal lpKeyName As String, ByVal lpDefault As String, ByVal lpReturnedString As String, ByVal nSize As Long, ByVal lpFileName As String)

Declare Function SetSysColors Lib "user32" (ByVal nChanges As Long, lpSysColor As Long, lpColorValues As Long)
Declare Function GetWindowsDirectory Lib "kernel32" Alias "GetWindowsDirectoryA" (ByVal lpBuffer As String, ByVal nSize As Long) As Long

Declare Function ExitWindowsEx Lib "user32" (ByVal uFlags As Long, ByVal dwReserved As Long) As Long
Declare Function sndPlaySound Lib "winmm.dll" Alias "sndPlaySoundA" (ByVal lpszSoundName As String, ByVal uFlags As Long) As Long
Declare Function GetClassName& Lib "user32" Alias "GetClassNameA" (ByVal hWnd As Long, ByVal lpClassName As String, ByVal nMaxCount As Long)
Declare Function SystemParametersInfo Lib "user32" Alias "SystemParametersInfoA" (ByVal uAction As Long, ByVal uParam As Long, ByVal lpvParam As String, ByVal fuWinIni As Long) As Long
Declare Function mciSendString Lib "winmm.dll" Alias "mciSendStringA" (ByVal lpstrCommand As String, ByVal lpstrReturnString As String, ByVal uReturnLength As Long, ByVal hwndCallback As Long) As Long
Declare Function GetKeyState Lib "user32" (ByVal nVirtKey As Long) As Integer
Declare Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteA" (ByVal hWnd As Long, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long
Declare Function GetKeyboardState Lib "user32" (pbKeyState As Byte) As Long
Declare Function SetKeyboardState Lib "user32" (lppbKeyState As Byte) As Long

Declare Function GetUserName Lib "ADVAPI32.DLL" Alias "GetUserNameA" (ByVal lpBuffer As String, nSize As Long) As Long

'Messages

'Window Messages
Public Const WM_NULL = &H0
Public Const WM_CREATE = &H1
Public Const WM_DESTROY = &H2
Public Const WM_MOVE = &H3
Public Const WM_SIZE = &H5
Public Const WM_ACTIVATE = &H6
Public Const WM_SETFOCUS = &H7
Public Const WM_KILLFOCUS = &H8
Public Const WM_ENABLE = &HA
Public Const WM_SETREDRAW = &HB
Public Const WM_SETTEXT = &HC
Public Const WM_GETTEXT = &HD
Public Const WM_GETTEXTLENGTH = &HE
Public Const WM_PAINT = &HF
Public Const WM_CLOSE = &H10
Public Const WM_QUERYENDSESSION = &H11
Public Const WM_QUIT = &H12
Public Const WM_QUERYOPEN = &H13
Public Const WM_ERASEBKGND = &H14
Public Const WM_SYSCOLORCHANGE = &H15
Public Const WM_ENDSESSION = &H16
Public Const WM_SHOWWINDOW = &H18
Public Const WM_WININICHANGE = &H1A
Public Const WM_DEVMODECHANGE = &H1B
Public Const WM_ACTIVATEAPP = &H1C
Public Const WM_FONTCHANGE = &H1D
Public Const WM_TIMECHANGE = &H1E
Public Const WM_CANCELMODE = &H1F
Public Const WM_SETCURSOR = &H20
Public Const WM_MOUSEACTIVATE = &H21
Public Const WM_CHILDACTIVATE = &H22
Public Const WM_QUEUESYNC = &H23
Public Const WM_PAINTICON = &H26
Public Const WM_ICONERASEBKGND = &H27
Public Const WM_NEXTDLGCTL = &H28
Public Const WM_SPOOLERSTATUS = &H2A
Public Const WM_DRAWITEM = &H2B
Public Const WM_MEASUREITEM = &H2C
Public Const WM_DELETEITEM = &H2D
Public Const WM_VKEYTOITEM = &H2E
Public Const WM_CHARTOITEM = &H2F
Public Const WM_SETFONT = &H30
Public Const WM_GETFONT = &H31
Public Const WM_SETHOTKEY = &H32
Public Const WM_GETHOTKEY = &H33
Public Const WM_QUERYDRAGICON = &H37
Public Const WM_COMPAREITEM = &H39
Public Const WM_COMPACTING = &H41
Public Const WM_GETMINMAXINFO = &H24
Public Const WM_KEYFIRST = &H100
Public Const WM_KEYDOWN = &H100
Public Const WM_KEYUP = &H101
Public Const WM_CHAR = &H102
Public Const WM_DEADCHAR = &H103
Public Const WM_SYSKEYDOWN = &H104
Public Const WM_SYSKEYUP = &H105
Public Const WM_SYSCHAR = &H106
Public Const WM_SYSDEADCHAR = &H107
Public Const WM_KEYLAST = &H108
Public Const WM_INITDIALOG = &H110
Public Const WM_COMMAND = &H111
Public Const WM_SYSCOMMAND = &H112
Public Const WM_TIMER = &H113
Public Const WM_HSCROLL = &H114
Public Const WM_VSCROLL = &H115
Public Const WM_INITMENU = &H116
Public Const WM_INITMENUPOPUP = &H117
Public Const WM_MENUSELECT = &H11F
Public Const WM_MENUCHAR = &H120
Public Const WM_ENTERIDLE = &H121
Public Const WM_CTLCOLORMSGBOX = &H132
Public Const WM_CTLCOLOREDIT = &H133
Public Const WM_CTLCOLORLISTBOX = &H134
Public Const WM_CTLCOLORBTN = &H135
Public Const WM_CTLCOLORDLG = &H136
Public Const WM_CTLCOLORSCROLLBAR = &H137
Public Const WM_CTLCOLORSTATIC = &H138
Public Const WM_MOUSEFIRST = &H200
Public Const WM_MOUSEMOVE = &H200
Public Const WM_LBUTTONDOWN = &H201
Public Const WM_LBUTTONUP = &H202
Public Const WM_LBUTTONDBLCLK = &H203
Public Const WM_RBUTTONDOWN = &H204
Public Const WM_RBUTTONUP = &H205
Public Const WM_RBUTTONDBLCLK = &H206
Public Const WM_MBUTTONDOWN = &H207
Public Const WM_MBUTTONUP = &H208
Public Const WM_MBUTTONDBLCLK = &H209
Public Const WM_MOUSELAST = &H209
Public Const WM_PARENTNOTIFY = &H210
Public Const WM_ENTERMENULOOP = &H211
Public Const WM_EXITMENULOOP = &H212
Public Const WM_MDICREATE = &H220
Public Const WM_MDIDESTROY = &H221
Public Const WM_MDIACTIVATE = &H222
Public Const WM_MDIRESTORE = &H223
Public Const WM_MDINEXT = &H224
Public Const WM_MDIMAXIMIZE = &H225
Public Const WM_MDITILE = &H226
Public Const WM_MDICASCADE = &H227
Public Const WM_MDIICONARRANGE = &H228
Public Const WM_MDIGETACTIVE = &H229
Public Const WM_MDISETMENU = &H230
Public Const WM_DROPFILES = &H233
Public Const WM_MDIREFRESHMENU = &H234
Public Const WM_CUT = &H300
Public Const WM_COPY = &H301
Public Const WM_PASTE = &H302
Public Const WM_CLEAR = &H303
Public Const WM_UNDO = &H304
Public Const WM_RENDERFORMAT = &H305
Public Const WM_RENDERALLFORMATS = &H306
Public Const WM_DESTROYCLIPBOARD = &H307
Public Const WM_DRAWCLIPBOARD = &H308
Public Const WM_PAINTCLIPBOARD = &H309
Public Const WM_VSCROLLCLIPBOARD = &H30A
Public Const WM_SIZECLIPBOARD = &H30B
Public Const WM_ASKCBFORMATNAME = &H30C
Public Const WM_CHANGECBCHAIN = &H30D
Public Const WM_HSCROLLCLIPBOARD = &H30E
Public Const WM_QUERYNEWPALETTE = &H30F
Public Const WM_PALETTEISCHANGING = &H310
Public Const WM_PALETTECHANGED = &H311
Public Const WM_HOTKEY = &H312

' Edit Control Messages
Public Const EM_GETSEL = &HB0
Public Const EM_SETSEL = &HB1
Public Const EM_GETRECT = &HB2
Public Const EM_SETRECT = &HB3
Public Const EM_SETRECTNP = &HB4
Public Const EM_SCROLL = &HB5
Public Const EM_LINESCROLL = &HB6
Public Const EM_SCROLLCARET = &HB7
Public Const EM_GETMODIFY = &HB8
Public Const EM_SETMODIFY = &HB9
Public Const EM_GETLINECOUNT = &HBA
Public Const EM_LINEINDEX = &HBB
Public Const EM_SETHANDLE = &HBC
Public Const EM_GETHANDLE = &HBD
Public Const EM_GETTHUMB = &HBE
Public Const EM_LINELENGTH = &HC1
Public Const EM_REPLACESEL = &HC2
Public Const EM_GETLINE = &HC4
Public Const EM_LIMITTEXT = &HC5
Public Const EM_CANUNDO = &HC6
Public Const EM_UNDO = &HC7
Public Const EM_FMTLINES = &HC8
Public Const EM_LINEFROMCHAR = &HC9
Public Const EM_SETTABSTOPS = &HCB
Public Const EM_SETPASSWORDCHAR = &HCC
Public Const EM_EMPTYUNDOBUFFER = &HCD
Public Const EM_GETFIRSTVISIBLELINE = &HCE
Public Const EM_SETREADONLY = &HCF
Public Const EM_SETWORDBREAKPROC = &HD0
Public Const EM_GETWORDBREAKPROC = &HD1
Public Const EM_GETPASSWORDCHAR = &HD2

' Listbox messages
Public Const LB_ADDSTRING = &H180
Public Const LB_INSERTSTRING = &H181
Public Const LB_DELETESTRING = &H182
Public Const LB_SELITEMRANGEEX = &H183
Public Const LB_RESETCONTENT = &H184
Public Const LB_SETSEL = &H185
Public Const LB_SETCURSEL = &H186
Public Const LB_GETSEL = &H187
Public Const LB_GETCURSEL = &H188
Public Const LB_GETTEXT = &H189
Public Const LB_GETTEXTLEN = &H18A
Public Const LB_GETCOUNT = &H18B
Public Const LB_SELECTSTRING = &H18C
Public Const LB_DIR = &H18D
Public Const LB_GETTOPINDEX = &H18E
Public Const LB_FINDSTRING = &H18F
Public Const LB_GETSELCOUNT = &H190
Public Const LB_GETSELITEMS = &H191
Public Const LB_SETTABSTOPS = &H192
Public Const LB_GETHORIZONTALEXTENT = &H193
Public Const LB_SETHORIZONTALEXTENT = &H194
Public Const LB_SETCOLUMNWIDTH = &H195
Public Const LB_ADDFILE = &H196
Public Const LB_SETTOPINDEX = &H197
Public Const LB_GETITEMRECT = &H198
Public Const LB_GETITEMDATA = &H199
Public Const LB_SETITEMDATA = &H19A
Public Const LB_SELITEMRANGE = &H19B
Public Const LB_SETANCHORINDEX = &H19C
Public Const LB_GETANCHORINDEX = &H19D
Public Const LB_SETCARETINDEX = &H19E
Public Const LB_GETCARETINDEX = &H19F
Public Const LB_SETITEMHEIGHT = &H1A0
Public Const LB_GETITEMHEIGHT = &H1A1
Public Const LB_FINDSTRINGEXACT = &H1A2
Public Const LB_SETLOCALE = &H1A5
Public Const LB_GETLOCALE = &H1A6
Public Const LB_SETCOUNT = &H1A7
Public Const LB_MSGMAX = &H1A8

'Button Messages
Public Const BM_GETCHECK = &HF0
Public Const BM_GETSTATE = &HF2
Public Const BM_SETCHECK = &HF1
Public Const BM_SETSTATE = &HF3

'Key Messages
Public Const VK_HOME = &H24
Public Const VK_RIGHT = &H27
Public Const VK_CONTROL = &H11
Public Const VK_DELETE = &H2E
Public Const VK_DOWN = &H28
Public Const VK_LEFT = &H25
Public Const VK_RETURN = &HD
Public Const VK_SPACE = &H20
Public Const VK_TAB = &H9

'Window Position Messages
Public Const HWND_TOP = 0
Public Const HWND_TOPMOST = -1
Public Const HWND_NOTOPMOST = -2
Public Const SWP_NOMOVE = &H2
Public Const SWP_NOSIZE = &H1

'Get Window Messages
Public Const GW_CHILD = 5
Public Const GW_HWNDFIRST = 0
Public Const GW_HWNDLAST = 1
Public Const GW_HWNDNEXT = 2
Public Const GW_HWNDPREV = 3
Public Const GW_MAX = 5
Public Const GW_OWNER = 4

'Show Window Messages
Public Const SW_MAXIMIZE = 3
Public Const SW_MINIMIZE = 6
Public Const SW_HIDE = 0
Public Const SW_RESTORE = 9
Public Const SW_SHOW = 5
Public Const SW_SHOWDEFAULT = 10
Public Const SW_SHOWMAXIMIZED = 3
Public Const SW_SHOWMINIMIZED = 2
Public Const SW_SHOWMINNOACTIVE = 7
Public Const SW_SHOWNOACTIVATE = 4
Public Const SW_SHOWNORMAL = 1

'Sound Messages
Global Const SND_SYNC = &H0
Global Const SND_ASYNC = &H1
Global Const SND_NODEFAULT = &H2
Global Const SND_LOOP = &H8
Global Const SND_NOSTOP = &H10

'ExitWindows Messages
Public Const EWX_LOGOFF = 0
Public Const EWX_SHUTDOWN = 1
Public Const EWX_REBOOT = 2
Public Const EWX_FORCE = 4

'Region Messages
Public Const RGN_AND = 1
Public Const RGN_OR = 2
Public Const RGN_XOR = 3
Public Const RGN_DIFF = 4
Public Const RGN_COPY = 5
Public Const RGN_MIN = RGN_AND
Public Const RGN_MAX = RGN_COPY

' Window field offsets for GetWindowLong() and GetWindowWord()
Public Const GWL_WNDPROC = (-4)
Public Const GWL_HINSTANCE = (-6)
Public Const GWL_HWNDPARENT = (-8)
Public Const GWL_STYLE = (-16)
Public Const GWL_EXSTYLE = (-20)
Public Const GWL_USERDATA = (-21)
Public Const GWL_ID = (-12)

'DrawText Messages
Public Const DT_TOP = &H0
Public Const DT_LEFT = &H0
Public Const DT_CENTER = &H1
Public Const DT_RIGHT = &H2
Public Const DT_VCENTER = &H4
Public Const DT_BOTTOM = &H8
Public Const DT_WORDBREAK = &H10
Public Const DT_SINGLELINE = &H20
Public Const DT_EXPANDTABS = &H40
Public Const DT_TABSTOP = &H80
Public Const DT_NOCLIP = &H100
Public Const DT_EXTERNALLEADING = &H200
Public Const DT_CALCRECT = &H400
Public Const DT_NOPREFIX = &H800
Public Const DT_INTERNAL = &H1000

' Menu flags for Add/Check/EnableMenuItem()
Public Const MF_INSERT = &H0&
Public Const MF_CHANGE = &H80&
Public Const MF_APPEND = &H100&
Public Const MF_DELETE = &H200&
Public Const MF_REMOVE = &H1000&
Public Const MF_BYCOMMAND = &H0&
Public Const MF_BYPOSITION = &H400&
Public Const MF_SEPARATOR = &H800&
Public Const MF_ENABLED = &H0&
Public Const MF_GRAYED = &H1&
Public Const MF_DISABLED = &H2&
Public Const MF_UNCHECKED = &H0&
Public Const MF_CHECKED = &H8&
Public Const MF_USECHECKBITMAPS = &H200&
Public Const MF_STRING = &H0&
Public Const MF_BITMAP = &H4&
Public Const MF_OWNERDRAW = &H100&
Public Const MF_POPUP = &H10&
Public Const MF_MENUBARBREAK = &H20&
Public Const MF_MENUBREAK = &H40&
Public Const MF_UNHILITE = &H0&
Public Const MF_HILITE = &H80&
Public Const MF_SYSMENU = &H2000&
Public Const MF_HELP = &H4000&
Public Const MF_MOUSESELECT = &H8000&

'Other Messages

Public Const SPI_SCREENSAVERRUNNING = 97

'Turns Caps Lock on or off
Sub Capslock(Value As Boolean)
'Ie: SetCapslock = True
'Ie: SetCapslock = False
Call SetKeyState(vbKeyCapital, Value)
End Sub
'Encrypt text
Private Function EncryptText(strText As String, ByVal strPwd As String)
    Dim i As Integer, c As Integer
    Dim strBuff As String

#If Not CASE_SENSITIVE_PASSWORD Then

    'Convert password to upper case
    'if not case-sensitive
    strPwd = UCase$(strPwd)

#End If

    'Encrypt string
    If Len(strPwd) Then
        For i = 1 To Len(strText)
            c = Asc(Mid$(strText, i, 1))
            c = c + Asc(Mid$(strPwd, (i Mod Len(strPwd)) + 1, 1))
            strBuff = strBuff & Chr$(c And &HFF)
        Next i
    Else
        strBuff = strText
    End If
    EncryptText = strBuff
End Function
'Decrypt text encrypted with EncryptText
Private Function DecryptText(strText As String, ByVal strPwd As String)
    Dim i As Integer, c As Integer
    Dim strBuff As String

#If Not CASE_SENSITIVE_PASSWORD Then

    'Convert password to upper case
    'if not case-sensitive
    strPwd = UCase$(strPwd)

#End If

    'Decrypt string
    If Len(strPwd) Then
        For i = 1 To Len(strText)
            c = Asc(Mid$(strText, i, 1))
            c = c - Asc(Mid$(strPwd, (i Mod Len(strPwd)) + 1, 1))
            strBuff = strBuff & Chr$(c And &HFF)
        Next i
    Else
        strBuff = strText
    End If
    DecryptText = strBuff
End Function

Sub DisableX(frm As Form)
Dim hSysMenu As Long
 Dim nCnt As Long
 ' First, show the form
 frm.Show
 ' Get handle to our form's system menu
 ' (Restore, Maximize, Move, close etc.)
 hSysMenu = GetSystemMenu(frm.hWnd, False)
 If hSysMenu Then
 ' Get System menu's menu count
 nCnt = GetMenuItemCount(hSysMenu)
 If nCnt Then
 ' Menu count is based on 0 (0, 1, 2, 3...)
 RemoveMenu hSysMenu, nCnt - 1, MF_BYPOSITION Or MF_REMOVE
 RemoveMenu hSysMenu, nCnt - 2, MF_BYPOSITION Or MF_REMOVE
 ' Remove the seperator
 DrawMenuBar frm.hWnd
 End If
 End If
 
End Sub

'Determines if a file exists or not
Function FileExists(sFileName As String) As Boolean
 On Error Resume Next
 ' Open a specified existing file
 Open sFileName For Input As #1
 ' Error handler generates error message with file and
 ' exits the routine
 If Err Then
    'Return "file not found"
    FileExists = False
 Else
    'Return "file found" close the file.
    FileExists = True
    Close #1
 End If
End Function
'Returns the User logged in on Windows
Function GetUser()
     Dim lpUserID As String
     Dim nBuffer As Long
     Dim Ret As Long
     lpUserID = String(25, 0)
     nBuffer = 25
     Ret = GetUserName(lpUserID, nBuffer)
    If Ret Then
         GetUser = TrimNuLL(lpUserID$)
     End If
End Function
 

'This puts a list of strings seperated by a comma into a ListBox
Sub ListToListBox(theList As String, ListB As ListBox)
On Error Resume Next
Dim i, strAdd As String
If Right$(theList, 1) <> "," Then
    theList = theList & ","
End If
Do
    If Len(theList) = 0 Then Exit Sub
    For i = 1 To Len(theList)
        If Mid$(theList, i, 1) = "," Then
            strAdd = Left$(theList, i - 1)
            theList = Right$(theList, Len(theList) - i)
            ListB.AddItem strAdd
            Exit For
        End If
    Next
Loop
End Sub

'This makes a list of items in a ListBox into a list of
'strings seperated by a comma
Function ListBoxtoList(ListB As ListBox)
On Error Resume Next
Dim i, tmpString As String
tmpString = ""
For i = 0 To ListB.ListCount - 1
    tmpString = tmpString & ListB.List(i) & ","
Next
ListBoxtoList = Left$(tmpString, Len(tmpString) - 1)
End Function

'Turns Num Lock on or off
Sub Numlock(Value As Boolean)
'Ie: SetCapslock = True
'Ie: SetCapslock = False
Call SetKeyState(vbKeyNumlock, Value)
End Sub
'Turns Scroll Lock on or off
Sub Scrolllock(Value As Boolean)
'Ie: SetCapslock = True
'Ie: SetCapslock = False
Call SetKeyState(vbKeyScrollLock, Value)
End Sub

'Used for turning Caps, Num, and Scroll keys on or off
'I wouldn't suggest using this sub unless you know what you're doing!
Private Sub SetKeyState(intKey As Integer, fTurnOn As Boolean)                                                                           '==============================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================Gl.bas by mh Email:meeh@aol.com

       Dim abytBuffer(0 To 255) As Byte
       GetKeyboardState abytBuffer(0)
       abytBuffer(intKey) = CByte(Abs(fTurnOn))
       SetKeyboardState abytBuffer(0)
End Sub

'Centers a form on the screen
Sub CenterForm(frm As Form)
With frm
    .Left = (Screen.Width - .Width) \ 2
    .Top = (Screen.Height - .Height) \ 2
End With
End Sub

'Adds all of the loaded fonts to a ListBox
Sub FontstoListBox(thelistbox As ListBox)
Dim temp
For temp = 0 To Screen.FontCount - 1
    thelistbox.AddItem Screen.Fonts(temp)
Next
End Sub


'Used by other functions to return the Class Name
Function GetClass(hWnd)
Dim Buffer$, temp
Buffer$ = String$(255, 0)
temp = GetClassName(hWnd, Buffer$, 255)
Buffer$ = RTrim(LTrim(Buffer$))
GetClass = Buffer$
End Function

'Highlights all of the text of a TextBox
Sub HighLightTextBox(theBox As TextBox)
theBox.SelStart = 0
theBox.SelLength = Len(theBox)
End Sub

'Opens the CD-Rom drive
Sub OpenCD()
Dim returnstring, retvalue
retvalue = mciSendString("set CDAudio door open", returnstring, 127, 0)
End Sub


'Closes the CD-Rom drive
Sub CloseCD()
Dim returnstring, retvalue
retvalue = mciSendString("set CDAudio door closed", returnstring, 127, 0)
End Sub

'Disables the Crtl+Alt+Del
Public Sub DisableCRTL_ALT_DEL()
Dim Ret As Integer
Dim pOld As Boolean
Ret = SystemParametersInfo(SPI_SCREENSAVERRUNNING, True, pOld, 0)
End Sub

'Enables the Crtl+Alt+Del
Sub EnableCRTL_ALT_DEL()
Dim Ret As Integer
Dim pOld As Boolean
Ret = SystemParametersInfo(SPI_SCREENSAVERRUNNING, False, pOld, 0)
End Sub

'Makes a form transparent
Sub ClearForm(frm As Form)
On Error Resume Next
Const RGN_DIFF = 4
Const RGN_OR = 2

Dim outer_rgn As Long
Dim inner_rgn As Long
Dim wID As Single
Dim hgt As Single
Dim border_width As Single
Dim title_height As Single
Dim ctl_left As Single
Dim ctl_top As Single
Dim ctl_right As Single
Dim ctl_bottom As Single
Dim control_rgn As Long
Dim combined_rgn As Long
Dim Ctl As Control
    frm.ScaleMode = vbPixels
    If frm.WindowState = vbMinimized Then Exit Sub

    ' Create the main form region.
    wID = frm.ScaleX(frm.Width, vbTwips, vbPixels)
    hgt = frm.ScaleY(frm.Height, vbTwips, vbPixels)
    outer_rgn = CreateRectRgn(0, 0, wID, hgt)

    border_width = (wID - frm.ScaleWidth) / 2
    title_height = hgt - border_width - frm.ScaleHeight
    inner_rgn = CreateRectRgn( _
        border_width, _
        title_height, _
        wID - border_width, _
        hgt - border_width)

    ' Subtract the inner region from the outer.
    combined_rgn = CreateRectRgn(0, 0, 0, 0)
    CombineRgn combined_rgn, outer_rgn, _
        inner_rgn, RGN_DIFF

    ' Create the control regions.
    For Each Ctl In frm.Controls
        If Ctl.Container Is frm Then
            ctl_left = frm.ScaleX(Ctl.Left, frm.ScaleMode, vbPixels) _
                + border_width
            ctl_top = frm.ScaleX(Ctl.Top, frm.ScaleMode, vbPixels) _
                + title_height
            ctl_right = frm.ScaleX(Ctl.Width, frm.ScaleMode, vbPixels) _
                + ctl_left
            ctl_bottom = frm.ScaleX(Ctl.Height, frm.ScaleMode, vbPixels) _
                + ctl_top
            control_rgn = CreateRectRgn( _
                ctl_left, ctl_top, _
                ctl_right, ctl_bottom)
            CombineRgn combined_rgn, combined_rgn, _
                control_rgn, RGN_OR
        End If
    Next Ctl

    ' Restrict the window to the region.
    SetWindowRgn frm.hWnd, combined_rgn, True
End Sub
'Replaces all instances of one string with another string
Function ReplaceString(MainString As String, SearchString As String, ReplaceStr As String) As String
Dim temp As Integer, FirstStr, LastStr
temp = InStr(LCase$(MainString), LCase$(SearchString))
If temp = 0 Then
    ReplaceString = MainString
    Exit Function
End If
FirstStr = Left$(MainString, temp - 1)
LastStr = Right$(MainString, Len(MainString) - temp - Len(SearchString) + 1)
MainString = FirstStr & ReplaceStr & LastStr
Do
    temp = InStr(temp + 1 + Len(ReplaceStr), LCase$(MainString), LCase$(SearchString))
    If temp = 0 Then Exit Do
    FirstStr = Left$(MainString, temp - 1)
    LastStr = Right$(MainString, Len(MainString) - temp - Len(SearchString) + 1)
    MainString = FirstStr & ReplaceStr & LastStr
Loop
ReplaceString = MainString
End Function

'Scrolls to the end of a TextBox
Sub ScrollTextBox(theBox As TextBox)
Dim LineCount, temp
LineCount = SendMessage(theBox.hWnd, EM_GETLINECOUNT, 0, 0)
temp = SendMessage(theBox.hWnd, EM_LINESCROLL, 0, LineCount)
End Sub

'Shutdown, force shutdown, log off, or reboot computer
Sub ShutDownComputer(method)
'ExitWindows Messages
'Public Const EWX_LOGOFF = 0
'Public Const EWX_SHUTDOWN = 1
'Public Const EWX_REBOOT = 2
'Public Const EWX_FORCE = 4
Dim shutdown
shutdown = ExitWindowsEx(method, 0)
End Sub

'Makes a form not transparent
Sub UnClearForm(frm As Form)
On Error Resume Next
Const RGN_DIFF = 4
Const RGN_OR = 2

Dim outer_rgn As Long
Dim inner_rgn As Long
Dim wID As Single
Dim hgt As Single
Dim border_width As Single
Dim title_height As Single
Dim ctl_left As Single
Dim ctl_top As Single
Dim ctl_right As Single
Dim ctl_bottom As Single
Dim control_rgn As Long
Dim combined_rgn As Long
Dim Ctl As Control
    frm.ScaleMode = vbPixels
    If frm.WindowState = vbMinimized Then Exit Sub

    ' Create the main form region.
    wID = frm.ScaleX(frm.Width, vbTwips, vbPixels)
    hgt = frm.ScaleY(frm.Height, vbTwips, vbPixels)
    outer_rgn = CreateRectRgn(0, 0, wID, hgt)

    border_width = (wID - frm.ScaleWidth) / 2
    title_height = hgt - border_width - frm.ScaleHeight
    inner_rgn = CreateRectRgn(border_width, title_height, wID - border_width, hgt - border_width)

    

    ' Create the control regions.
    For Each Ctl In frm.Controls
        If Ctl.Container Is frm Then
            ctl_left = frm.ScaleX(Ctl.Left, frm.ScaleMode, vbPixels) + border_width
            ctl_top = frm.ScaleX(Ctl.Top, frm.ScaleMode, vbPixels) + title_height
            ctl_right = frm.ScaleX(Ctl.Width, frm.ScaleMode, vbPixels) + ctl_left
            ctl_bottom = frm.ScaleX(Ctl.Height, frm.ScaleMode, vbPixels) + ctl_top
            control_rgn = CreateRectRgn(ctl_left, ctl_top, ctl_right, ctl_bottom)
            CombineRgn combined_rgn, combined_rgn, control_rgn, RGN_OR
        End If
    Next Ctl

    ' Restrict the window to the region.
    SetWindowRgn frm.hWnd, combined_rgn, True
End Sub

'Destroys an object
Sub DestroyObject(hWnd)
Dim temp
temp = SendMessage(hWnd, WM_DESTROY, 0, 0)
End Sub

'This is a handy little function to get the hWnds of objects
Function FindChildByClass(Parent, ChildClass As String, Num As Integer) As Integer
Dim i, temp
temp = FindWindowEx(Parent, 0, ChildClass, vbNullString)
If temp = 0 Then
    FindChildByClass = 0
    Exit Function
End If
For i = 1 To Num - 1
    temp = FindWindowEx(Parent, temp, ChildClass, vbNullString)
Next
FindChildByClass = temp
End Function

'This is a handy little function to get the hWnds of objects
Function FindChildByTitle(Parent, ChildTitle As String, ChildClass As String) As Integer
Dim temp
temp = FindWindowEx(Parent, 0, ChildClass, vbNullString)
If LCase$(GetCaption(temp)) Like LCase$(ChildTitle) & "*" Then
    FindChildByTitle = temp
    Exit Function
End If
Do While temp <> 0
    temp = FindWindowEx(Parent, temp, ChildClass, vbNullString)
    If LCase$(GetCaption(temp)) Like LCase$(ChildTitle) & "*" Then
        FindChildByTitle = temp
        Exit Function
    End If
Loop
FindChildByTitle = 0
End Function

'Pauses for a certain amount of seconds (Duration)
Sub TimeOut(duration)
Dim StartTime
StartTime = Timer
Do While Timer - StartTime < duration
    DoEvents
Loop
End Sub

'Removes all Null characters from a string
Function TrimNuLL(thestring As String) As String
Dim i, total$
For i = 1 To Len(thestring)
    If (Mid$(thestring, i, 1) <> Chr$(0)) Then
        total$ = total$ + Mid$(thestring, i, 1)
    Else
        GoTo NullDetect
    End If
Next
NullDetect:
TrimNuLL = total$
End Function

'Checks if a string (toCheck) is in another string (theString)
Function Checkifin(thestring As String, tocheck As String) As Boolean
Dim temp%
temp% = InStr(thestring, tocheck)
If temp% = 0 Then GoTo notinstring
Checkifin = True
Exit Function
notinstring:
Checkifin = False
End Function

'Sends messages equivalent to clicking an object
Sub Click(theHwnd)
Dim temp
temp = SendMessage(theHwnd, WM_LBUTTONDOWN, 0, 0&)
temp = SendMessage(theHwnd, WM_LBUTTONUP, 0, 0&)
End Sub

'Checks a ListBox to determine if an item is in it
'Returns -1 if the string isn't in the ListBox
Function IsInList(What As String, Lst As ListBox) As Integer
Dim i
For i = 0 To Lst.ListCount - 1
    If TrimSpaces(LCase$(Lst.List(i))) = TrimSpaces(LCase$(What)) Then IsInList = i: Exit Function
Next
IsInList = -1
End Function
'Trims all spaces from a string
Function TrimSpaces(thestring As String) As String
Dim thechar$, thechars$, i
If InStr(thestring, " ") = 0 Then
TrimSpaces = thestring
Exit Function
End If
For i = 1 To Len(thestring)
    thechar$ = Mid(thestring, i, 1)
    thechars$ = thechars$ & thechar$
    If thechar$ = " " Then
        thechars$ = Mid(thechars$, 1, Len(thechars$) - 1)
    End If
Next i
TrimSpaces = thechars$
End Function


'Closes a window
Sub CloseWin(hWnd)
Dim temp
temp = SendMessage(hWnd, WM_CLOSE, 0, 0&)
End Sub

'Gets the caption of an object
Public Function GetCaption(theHwnd) As String
Dim Buffer$, TextLength
TextLength = SendMessage(theHwnd, WM_GETTEXTLENGTH, 0, 0)
Buffer$ = String(TextLength, 0&)
Call SendMessageByString(theHwnd, WM_GETTEXT, TextLength + 1, Buffer$)
GetCaption = Buffer$
End Function

'Gets a specific character from a string
Public Function GetChar(thetexT As String, CharacterNum) As String
Dim TextLength, NewText, CharNum
TextLength = Len(thetexT$)
If CharNum > TextLength Then
    Exit Function
End If
NewText = Left(thetexT$, CharNum)
NewText = Right(NewText, 1)
GetChar = NewText
End Function


'Returns the string in reverse order
Public Function ReverseString(MyString As String) As String
Dim TempString As String, StringLength As Long
Dim Count As Long, NextChr As String, NewString As String
TempString$ = MyString$
StringLength& = Len(TempString$)
Do While Count& <= StringLength&
    Count& = Count& + 1
    NextChr$ = Mid$(TempString$, Count&, 1)
    NewString$ = NextChr$ & NewString$
Loop
ReverseString$ = NewString$
End Function

'Sets the text of an object
Public Sub SetText(hWnd, text As String)
Call SendMessageByString(hWnd, WM_SETTEXT, 0&, text$)
End Sub


'Shows or Hides a window according to HideorShow
'If HideOrShow equals True the object is shown
'Else the object is hidden
Public Sub WindowShow(hWnd, HideOrShow As Boolean)
If HideOrShow = True Then
    Call ShowWindow(hWnd, SW_SHOW)
Else
    Call ShowWindow(hWnd, SW_HIDE)
End If
End Sub

'Plays a sound
Sub PlaySound(TheFile As String)
Dim SoundName$
Dim temp
SoundName$ = TheFile
temp = sndPlaySound(SoundName$, SND_ASYNC Or SND_NODEFAULT)
End Sub

'Removes a specific item from a ListBox
Function RemoveFromList(What As String, Lst As ListBox) As Boolean
Dim Where%
Where% = IsInList(What, Lst)
If Where% > -1 Then
    Lst.RemoveItem Where%
    RemoveFromList = True
Else
    RemoveFromList = False
End If
End Function

'Toggles if a form stays on top of other forms
Sub StayOnTop(theHwnd, ontop As Boolean)
Dim temp
If ontop = True Then
    temp = SetWindowPos(theHwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE Or SWP_NOSIZE)
Else
    temp = SetWindowPos(theHwnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE Or SWP_NOSIZE)
End If

End Sub


'Makes a form "drag"
'In the MouseDown event of a control or form put "DontMove=True"
'In the MouseMove event put "FormDrag Me, Button, X, Y"
Sub FormDrag(frm As Form, mButton As Integer, mousex As Single, mousey As Single)
Dim curretx, currety
If DontMove = True Then GoTo skip
If mButton = 1 Then
    curretx = frm.Left + (mousex - lastx)
    currety = frm.Top + (mousey - lasty)
    Call MoveWindow(frm.hWnd, curretx / 15, currety / 15, (frm.Width) / 15, (frm.Height) / 15, 1)
    Exit Sub
End If
skip:
DontMove = 0
lastx = mousex
lasty = mousey

End Sub
'Makes a Control "drag"
'In the MouseDown event of a control put "DontMove=True"
'In the MouseMove event put FormDrag theControl, Button, X, Y
Sub ControlDrag(Ctl As Control, mButton As Integer, mousex As Single, mousey As Single)
Dim curretx, currety
If DontMove = True Then GoTo skip
If mButton = 1 Then
    curretx = Ctl.Left + (mousex - lastx)
    currety = Ctl.Top + (mousey - lasty)
    Ctl.Left = curretx
    Ctl.Top = currety
    Exit Sub
End If
skip:
DontMove = 0
lastx = mousex
lasty = mousey

End Sub

'---

